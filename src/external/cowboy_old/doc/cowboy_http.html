<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Module cowboy_http</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module cowboy_http</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Core HTTP parsing API.


<h2><a name="description">Description</a></h2>Core HTTP parsing API.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-headers">headers()</a></h3>
<p><tt>headers() = [{binary(), iodata()}]</tt></p>


<h3 class="typedecl"><a name="type-status">status()</a></h3>
<p><tt>status() = non_neg_integer() | binary()</tt></p>


<h3 class="typedecl"><a name="type-version">version()</a></h3>
<p><tt>version() = {Major::non_neg_integer(), Minor::non_neg_integer()}</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#asctime_date-1">asctime_date/1</a></td><td>Parse an asctime date.</td></tr>
<tr><td valign="top"><a href="#authorization-2">authorization/2</a></td><td>Parse authorization value according rfc 2617.</td></tr>
<tr><td valign="top"><a href="#ce_identity-1">ce_identity/1</a></td><td>Decode an identity content.</td></tr>
<tr><td valign="top"><a href="#conneg-2">conneg/2</a></td><td>Parse a conneg header (Accept-Charset, Accept-Encoding),
  followed by an optional quality value.</td></tr>
<tr><td valign="top"><a href="#content_type-1">content_type/1</a></td><td>Parse a content type.</td></tr>
<tr><td valign="top"><a href="#cookie_list-1">cookie_list/1</a></td><td>Parse a list of cookies.</td></tr>
<tr><td valign="top"><a href="#cookie_to_iodata-3">cookie_to_iodata/3</a></td><td>Convert a cookie name, value and options to its iodata form.</td></tr>
<tr><td valign="top"><a href="#digits-1">digits/1</a></td><td>Parse a list of digits as a non negative integer.</td></tr>
<tr><td valign="top"><a href="#entity_tag_match-1">entity_tag_match/1</a></td><td>Parse either a list of entity tags or a "*".</td></tr>
<tr><td valign="top"><a href="#expectation-2">expectation/2</a></td><td>Parse an expectation.</td></tr>
<tr><td valign="top"><a href="#http_date-1">http_date/1</a></td><td>Parse an HTTP date (RFC1123, RFC850 or asctime date).</td></tr>
<tr><td valign="top"><a href="#language_range-2">language_range/2</a></td><td>Parse a language range, followed by an optional quality value.</td></tr>
<tr><td valign="top"><a href="#list-2">list/2</a></td><td>Parse a list of the given type.</td></tr>
<tr><td valign="top"><a href="#media_range-2">media_range/2</a></td><td>Parse a media range.</td></tr>
<tr><td valign="top"><a href="#nonempty_list-2">nonempty_list/2</a></td><td>Parse a non-empty list of the given type.</td></tr>
<tr><td valign="top"><a href="#params-2">params/2</a></td><td>Parse a list of parameters (a=b;c=d).</td></tr>
<tr><td valign="top"><a href="#quoted_string-2">quoted_string/2</a></td><td>Parse a quoted string.</td></tr>
<tr><td valign="top"><a href="#rfc1123_date-1">rfc1123_date/1</a></td><td>Parse an RFC1123 date.</td></tr>
<tr><td valign="top"><a href="#rfc850_date-1">rfc850_date/1</a></td><td>Parse an RFC850 date.</td></tr>
<tr><td valign="top"><a href="#te_chunked-2">te_chunked/2</a></td><td>Decode a stream of chunks.</td></tr>
<tr><td valign="top"><a href="#te_identity-2">te_identity/2</a></td><td>Decode an identity stream.</td></tr>
<tr><td valign="top"><a href="#token-2">token/2</a></td><td>Parse a token.</td></tr>
<tr><td valign="top"><a href="#token_ci-2">token_ci/2</a></td><td>Parse a case-insensitive token.</td></tr>
<tr><td valign="top"><a href="#urldecode-1">urldecode/1</a></td><td>Decode a URL encoded binary.</td></tr>
<tr><td valign="top"><a href="#urldecode-2">urldecode/2</a></td><td>Decode a URL encoded binary.</td></tr>
<tr><td valign="top"><a href="#urlencode-1">urlencode/1</a></td><td>URL encode a string binary.</td></tr>
<tr><td valign="top"><a href="#urlencode-2">urlencode/2</a></td><td>URL encode a string binary.</td></tr>
<tr><td valign="top"><a href="#version_to_binary-1">version_to_binary/1</a></td><td>Convert an HTTP version tuple to its binary form.</td></tr>
<tr><td valign="top"><a href="#whitespace-2">whitespace/2</a></td><td>Skip whitespace.</td></tr>
<tr><td valign="top"><a href="#x_www_form_urlencoded-1">x_www_form_urlencoded/1</a></td><td></td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="asctime_date-1">asctime_date/1</a></h3>
<div class="spec">
<p><tt>asctime_date(Data::binary()) -&gt; any()</tt><br></p>
</div><p>Parse an asctime date.</p>

<h3 class="function"><a name="authorization-2">authorization/2</a></h3>
<div class="spec">
<p><tt>authorization(UserPass::binary(), Type::binary()) -&gt; {binary(), any()} | {error, badarg}</tt><br></p>
</div><p>Parse authorization value according rfc 2617.
  Only Basic authorization is supported so far.</p>

<h3 class="function"><a name="ce_identity-1">ce_identity/1</a></h3>
<div class="spec">
<p><tt>ce_identity(Data::binary()) -&gt; {ok, binary()}</tt><br></p>
</div><p>Decode an identity content.</p>

<h3 class="function"><a name="conneg-2">conneg/2</a></h3>
<div class="spec">
<p><tt>conneg(Data::binary(), Fun::function()) -&gt; any()</tt><br></p>
</div><p>Parse a conneg header (Accept-Charset, Accept-Encoding),
  followed by an optional quality value.</p>

<h3 class="function"><a name="content_type-1">content_type/1</a></h3>
<div class="spec">
<p><tt>content_type(Data::binary()) -&gt; any()</tt><br></p>
</div><p>Parse a content type.</p>

<h3 class="function"><a name="cookie_list-1">cookie_list/1</a></h3>
<div class="spec">
<p><tt>cookie_list(Data::binary()) -&gt; [{binary(), binary()}] | {error, badarg}</tt><br></p>
</div><p><p>Parse a list of cookies.</p>
 
  We need a special function for this because we need to support both
  $; and $, as separators as per RFC2109.</p>

<h3 class="function"><a name="cookie_to_iodata-3">cookie_to_iodata/3</a></h3>
<div class="spec">
<p><tt>cookie_to_iodata(Name::iodata(), Value::iodata(), Opts::<a href="cowboy_req.html#type-cookie_opts">cowboy_req:cookie_opts()</a>) -&gt; iodata()</tt><br></p>
</div><p>Convert a cookie name, value and options to its iodata form.</p>

<h3 class="function"><a name="digits-1">digits/1</a></h3>
<div class="spec">
<p><tt>digits(Data::binary()) -&gt; non_neg_integer() | {error, badarg}</tt><br></p>
</div><p>Parse a list of digits as a non negative integer.</p>

<h3 class="function"><a name="entity_tag_match-1">entity_tag_match/1</a></h3>
<div class="spec">
<p><tt>entity_tag_match(Data::binary()) -&gt; any()</tt><br></p>
</div><p>Parse either a list of entity tags or a "*".</p>

<h3 class="function"><a name="expectation-2">expectation/2</a></h3>
<div class="spec">
<p><tt>expectation(Data::binary(), Fun::function()) -&gt; any()</tt><br></p>
</div><p>Parse an expectation.</p>

<h3 class="function"><a name="http_date-1">http_date/1</a></h3>
<div class="spec">
<p><tt>http_date(Data::binary()) -&gt; any()</tt><br></p>
</div><p>Parse an HTTP date (RFC1123, RFC850 or asctime date).</p>

<h3 class="function"><a name="language_range-2">language_range/2</a></h3>
<div class="spec">
<p><tt>language_range(Data::binary(), Fun::function()) -&gt; any()</tt><br></p>
</div><p>Parse a language range, followed by an optional quality value.</p>

<h3 class="function"><a name="list-2">list/2</a></h3>
<div class="spec">
<p><tt>list(Data::binary(), Fun::function()) -&gt; list() | {error, badarg}</tt><br></p>
</div><p>Parse a list of the given type.</p>

<h3 class="function"><a name="media_range-2">media_range/2</a></h3>
<div class="spec">
<p><tt>media_range(Data::binary(), Fun::function()) -&gt; any()</tt><br></p>
</div><p>Parse a media range.</p>

<h3 class="function"><a name="nonempty_list-2">nonempty_list/2</a></h3>
<div class="spec">
<p><tt>nonempty_list(Data::binary(), Fun::function()) -&gt; [any(), ...] | {error, badarg}</tt><br></p>
</div><p>Parse a non-empty list of the given type.</p>

<h3 class="function"><a name="params-2">params/2</a></h3>
<div class="spec">
<p><tt>params(Data::binary(), Fun::function()) -&gt; any()</tt><br></p>
</div><p>Parse a list of parameters (a=b;c=d).</p>

<h3 class="function"><a name="quoted_string-2">quoted_string/2</a></h3>
<div class="spec">
<p><tt>quoted_string(X1::binary(), Fun::function()) -&gt; any()</tt><br></p>
</div><p>Parse a quoted string.</p>

<h3 class="function"><a name="rfc1123_date-1">rfc1123_date/1</a></h3>
<div class="spec">
<p><tt>rfc1123_date(Data::binary()) -&gt; any()</tt><br></p>
</div><p>Parse an RFC1123 date.</p>

<h3 class="function"><a name="rfc850_date-1">rfc850_date/1</a></h3>
<div class="spec">
<p><tt>rfc850_date(Data::binary()) -&gt; any()</tt><br></p>
</div><p>Parse an RFC850 date.</p>

<h3 class="function"><a name="te_chunked-2">te_chunked/2</a></h3>
<div class="spec">
<p><tt>te_chunked(Bin, TransferState) -&gt; more | {more, non_neg_integer(), Bin, TransferState} | {ok, Bin, TransferState} | {ok, Bin, Bin, TransferState} | {done, non_neg_integer(), Bin} | {error, badarg}</tt>
<ul class="definitions"><li><tt>Bin = binary()</tt></li><li><tt>TransferState = {non_neg_integer(), non_neg_integer()}</tt></li></ul></p>
</div><p>Decode a stream of chunks.</p>

<h3 class="function"><a name="te_identity-2">te_identity/2</a></h3>
<div class="spec">
<p><tt>te_identity(Bin, TransferState) -&gt; {ok, Bin, TransferState} | {done, Bin, non_neg_integer(), Bin}</tt>
<ul class="definitions"><li><tt>Bin = binary()</tt></li><li><tt>TransferState = {non_neg_integer(), non_neg_integer()}</tt></li></ul></p>
</div><p>Decode an identity stream.</p>

<h3 class="function"><a name="token-2">token/2</a></h3>
<div class="spec">
<p><tt>token(Data::binary(), Fun::function()) -&gt; any()</tt><br></p>
</div><p>Parse a token.</p>

<h3 class="function"><a name="token_ci-2">token_ci/2</a></h3>
<div class="spec">
<p><tt>token_ci(Data::binary(), Fun::function()) -&gt; any()</tt><br></p>
</div><p><p>Parse a case-insensitive token.</p>
 
  Changes all characters to lowercase.</p>

<h3 class="function"><a name="urldecode-1">urldecode/1</a></h3>
<div class="spec">
<p><tt>urldecode(Bin::binary()) -&gt; binary()</tt><br></p>
</div><p>Equivalent to <a href="#urldecode-2"><tt>urldecode(Bin, crash)</tt></a>.</p>
<p>Decode a URL encoded binary.</p>

<h3 class="function"><a name="urldecode-2">urldecode/2</a></h3>
<div class="spec">
<p><tt>urldecode(Bin::binary(), OnError::crash | skip) -&gt; binary()</tt><br></p>
</div><p>Decode a URL encoded binary.
  The second argument specifies how to handle percent characters that are not
  followed by two valid hex characters. Use <code>skip</code> to ignore such errors,
  if <code>crash</code> is used the function will fail with the reason <code>badarg</code>.</p>

<h3 class="function"><a name="urlencode-1">urlencode/1</a></h3>
<div class="spec">
<p><tt>urlencode(Bin::binary()) -&gt; binary()</tt><br></p>
</div><p>Equivalent to <a href="#urlencode-2"><tt>urlencode(Bin, [])</tt></a>.</p>
<p>URL encode a string binary.</p>

<h3 class="function"><a name="urlencode-2">urlencode/2</a></h3>
<div class="spec">
<p><tt>urlencode(Bin::binary(), Opts::[noplus | upper]) -&gt; binary()</tt><br></p>
</div><p>URL encode a string binary.
  The <code>noplus</code> option disables the default behaviour of quoting space
  characters, <code>\s</code>, as <code>+</code>. The <code>upper</code> option overrides the default behaviour
  of writing hex numbers using lowecase letters to using uppercase letters
  instead.</p>

<h3 class="function"><a name="version_to_binary-1">version_to_binary/1</a></h3>
<div class="spec">
<p><tt>version_to_binary(X1::<a href="#type-version">version()</a>) -&gt; binary()</tt><br></p>
</div><p>Convert an HTTP version tuple to its binary form.</p>

<h3 class="function"><a name="whitespace-2">whitespace/2</a></h3>
<div class="spec">
<p><tt>whitespace(Data::binary(), Fun::function()) -&gt; any()</tt><br></p>
</div><p>Skip whitespace.</p>

<h3 class="function"><a name="x_www_form_urlencoded-1">x_www_form_urlencoded/1</a></h3>
<div class="spec">
<p><tt>x_www_form_urlencoded(Qs::binary()) -&gt; [{binary(), binary() | true}]</tt><br></p>
</div>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Feb 13 2013, 19:54:01.</i></p>
</body>
</html>
