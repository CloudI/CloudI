<html>
<head>
  <title>CloudI: A Cloud as an Interface - Frequently Asked Questions</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta content="Cloud Framework for fault-tolerant distributed processing with dynamic load balancing" name="description" />
  <meta content="cloud, private cloud, framework, erlang, c++, distributed, fault tolerant, distributed systems, fault-tolerant, embarrassingly parallel, divide and conquer, work pool, cloudi" name="keywords" />
  <meta content="global" name="distribution" />
  <meta content="This document copyright 2009-2012 by Michael Truog" name="copyright" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <link rel="stylesheet" type="text/css" title="print"
        href="print.css" />
  <meta http-equiv="Default-Style" content="print" />
  <link rel="shortcut icon" href="images/cloud.ico" type="image/x-icon" />
</head>
<body>

<div id="header">
<a href="http://cloudi.org/">
Cloud<font style="font-family: serif">I</font><img width=156 height=106 src="images/cloud.png" />
</a>
</div>
<br />
<div id="navigation">
  <ul>
    <li><a href="faq.html" class="active">FAQ</a></li>
    <li><a href="http://sourceforge.net/projects/cloudi/files/latest/download" target="_blank">Download</a></li>
    <li><a href="https://github.com/okeuday/CloudI/tree/master#readme">Source</a></li>
    <li><a href="http://cloudi.org/support.html">Support</a></li>
  </ul>
</div>

<div id="content">
  <h1>Frequently Asked Questions</h1>
  <center><h3>version 1.0.0b<br />last updated on June 24 2012</h3></center>

  <a name="1_contents"></a>
  <h2>1 - Introduction to CloudI</h2>
  <ul class="faq">
    <li><a href="#1_Name"         >1.1 - Why is it named "Cloud<font style="font-family: serif">I</font>"?</a></li>
    <li><a href="#1_Pronounce"    >1.2 - How is CloudI pronounced?</a></li>
    <li><a href="#1_Clouds"       >1.3 - How does CloudI compare to other "Clouds"?</a></li>
    <li><a href="#1_WhatIs"       >1.4 - What is CloudI?</a></li>
    <li><a href="#1_OS"           >1.5 - On what Operating Systems does CloudI run?</a></li>
    <li><a href="#1_Commercial"   >1.6 - Is Commercial support available for CloudI?</a></li>
    <li><a href="#1_ReallyFree"   >1.7 - Is CloudI really free?</a></li>
    <li><a href="#1_WhoDevelops"  >1.8 - Who develops CloudI?</a></li>
    <li><a href="#1_PrivateCloud" >1.9 - Can I use CloudI as a Private Cloud?</a></li>
    <li><a href="#1_OnlineService">1.10 - Can I use CloudI as an Online Service?</a></li>
    <li><a href="#1_CAP"          >1.11 - What CAP theorem guarantees does CloudI provide?</a></li>
    <li><a href="#1_REST"         >1.12 - Does CloudI support REST?</a></li>
    <li><a href="#1_PaaS"         >1.13 - Is CloudI a Platform as a Service (PaaS)?</a></li>
    <li><a href="#1_HowAbout"     >1.14 - Why doesn't CloudI integrate with ProductX?</a></li>
  </ul>
  <a name="2_contents"></a>
  <h2>2 - Learning about CloudI</h2>
  <ul class="faq">
    <li><a href="#2_WebPages"      >2.1 - Web Pages</a></li>
    <li><a href="#2_MailingList"   >2.2 - Mailing List</a></li>
    <li><a href="#2_IRC"           >2.3 - Internet Relay Chat (IRC)</a></li>
    <li><a href="#2_RSS"           >2.4 - RSS Feeds</a></li>
    <li><a href="#2_Presentations" >2.5 - Presentations</a></li>
    <li><a href="#2_Reporting Bugs">2.6 - Reporting Bugs</a></li>
  </ul>
  <a name="3_contents"></a>
  <h2>3 - CloudI Installation Guide</h2>
  <ul class="faq">
    <li><a href="#3_Overview"    >3.1 - Overview</a></li>
    <li><a href="#3_Options"     >3.2 - Installation Options</a></li>
    <li><a href="#3_OSX"         >3.3 - OS X Installation</a></li>
    <li><a href="#3_Running"     >3.4 - Running CloudI</a></li>
    <li><a href="#3_Config"      >3.5 - Configuration</a></li>
  </ul>
  <a name="4_contents"></a>
  <h2>4 - General Questions</h2>
  <ul class="faq">
    <li><a href="#4_API"        >4.1 - How do I integrate external software with CloudI?</a></li>
    <li><a href="#4_JobAPI"     >4.2 - How do I control CloudI dynamically?</a></li>
    <li><a href="#4_PubSub"     >4.3 - How do I use Publisher/Subscriber messaging?</a></li>
    <li><a href="#4_RPC"        >4.4 - How do I use Remote Procedure Calls (RPC)?</a></li>
    <li><a href="#4_WebServices">4.5 - How do I create Web Services?</a></li>
    <li><a href="#4_ACLs"       >4.6 - How do I use Access Control Lists (ACLs)?</a></li>
    <li><a href="#4_ServiceFail">4.7 - How do I Migrate a Service from a Failed or Failing Node?</a></li>
    <li><a href="#4_URLregex"   >4.8 - Can I use Regular Expressions with Service Names (URLs)?</a></li>
    <li><a href="#4_ThreadSafe" >4.9 - Is the CloudI API thread-safe?</a></li>
    <li><a href="#4_Speed"      >4.10 - How can CloudI requests take advantage of cache coherency, minimum network latency, and any logical grouping?</a></li>
  </ul>
  <a name="5_contents"></a>
  <h2>5 - Migrating to CloudI</h2>
  <ul class="faq">
    <li><a href="#5_Performance">5.1 - Performance Considerations</a></li>
    <li><a href="#5_Scalability">5.2 - Scalability Considerations</a></li>
    <li><a href="#5_Stability"  >5.3 - Stability and Fault-Tolerance Considerations</a></li>
    <li><a href="#5_Integration">5.4 - Integration Considerations</a></li>
    <li><a href="#5_LoadTesting">5.5 - Load Testing</a></li>
  </ul>
  <a name="6_contents"></a>
  <h2>6 - Services</h2>
  <ul class="faq">
    <li><a href="#6_C"       >6.1 - C/C++ Service Implementation</a></li>
    <li><a href="#6_Erlang"  >6.2 - Erlang Service Implementation</a></li>
    <li><a href="#6_Java"    >6.3 - Java Service Implementation</a></li>
    <li><a href="#6_Python"  >6.4 - Python Service Implementation</a></li>
    <li><a href="#6_Ruby"    >6.5 - Ruby Service Implementation</a></li>
    <li><a href="#6_HTTP"    >6.6 - HTTP Integration</a></li>
    <li><a href="#6_ZeroMQ"  >6.7 - ZeroMQ Integration</a></li>
  </ul>
  <a name="7_contents"></a>
  <h2>7 - Databases</h2>
  <ul class="faq">
    <li><a href="#7_CouchDB"    >7.1 - CouchDB Integration</a></li>
    <li><a href="#7_memcached"  >7.2 - memcached Integration</a></li>
    <li><a href="#7_PostgreSQL" >7.3 - PostgreSQL Integration</a></li>
    <li><a href="#7_MySQL"      >7.4 - MySQL Integration</a></li>
    <li><a href="#7_TokyoTyrant">7.5 - Tokyo Tyrant Integration</a></li>
    <li><a href="#7_Other"      >7.6 - Other Database Integration</a></li>
  </ul>

  <hr \>
  <h2>1 - Introduction to CloudI</h2>

  <a name="1_Name"></a>
  <h3>1.1 - Why is it named "Cloud<font style="font-family: serif">I</font>"?</h3>
  <p class="paragraph">
    A <strong>Cloud</strong> is more dynamic than a 3 dimensional
    <strong>Grid</strong> and is more ubiquitous than the legend of 
    <strong>Beowulf</strong>, so it is easy to understand why computing Clouds 
    are the next generation distributed systems.  The relevant connotations the 
    word Cloud contains are: dynamic, supervision, intermingle, and points 
    (i.e., point clouds).  Any computing Cloud should offer dynamic
    configuration, should supervise processes in a fault-tolerant way,
    offer easy integration and should support an arbitrarily large number
    of processes (respectively).  This project offers Cloud functionality
    facilitated by the <a href="http://en.wikipedia.org/wiki/Erlang_%28programming_language%29" target="_blank">Erlang programming language</a>
    and its implementation of the <a href="http://en.wikipedia.org/wiki/Actor_model" target="_blank">Actor Model</a>.
  </p>
  <p class="paragraph">
    CloudI has an "<font style="font-family: serif">I</font>" suffix for
    several connotations: cloudy, one, singularity, interface, and
    independence.  CloudI is referred to as "A Cloud as an Interface" because
    a light-weight interface facilitates Cloud functionality.
    The interface supports multiple programming languages and is called the
    CloudI API.  CloudI supports private cloud development and deployment,
    so only one Cloud is necessary for Cloud functionality with implicit
    security.  CloudI is also able to facilitate online services and offers
    extreme connection scalability.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_Pronounce"></a>
  <h3>1.2 - How is CloudI pronounced?</h3>
  <p class="paragraph">
    As "cloud-e" /kla&#650;di/ (think: Cloud <a href="http://en.wikipedia.org/wiki/Erlang_%28programming_language%29" target="_blank">Erlang</a>).
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_Clouds"></a>
  <h3>1.3 - How does CloudI compare to other "Clouds"?</h3>
  <p class="block">
    Currently, "Clouds" generally fall into two categories:
    <table><tr><td>
    &#149;</td><td>Infrastructure as a Service (IaaS)
    </td><td>- Hypervisor "Clouds"
    </td></tr><tr><td>
    &#149;</td><td>Platform as a Service (PaaS)
    </td><td>- Integration "Clouds"
    </td></tr></table>
  </p>
  <h4>Hypervisor "Clouds"</h4>
  <p class="paragraph">
    Hypervisor "Clouds" are the most popular type of Cloud because of the
    amount of revenue they can generate as a service.
    Popular examples include:
    <a href="http://en.wikipedia.org/wiki/Amazon_EC2" target="_blank">Amazon Web Services (AWS)</a>,
    <a href="http://en.wikipedia.org/wiki/OpenStack" target="_blank">OpenStack</a>,
    <a href="http://en.wikipedia.org/wiki/Cloud.com" target="_blank">CloudStack</a>,
    <a href="http://en.wikipedia.org/wiki/Eucalyptus_%28computing%29" target="_blank">Eucalyptus</a>,
    <a href="http://en.wikipedia.org/wiki/OpenNebula" target="_blank">OpenNebula</a>,
    and
    <a href="http://en.wikipedia.org/wiki/Nimbus_%28cloud_computing%29" target="_blank">Nimbus</a>.  The <a href="http://en.wikipedia.org/wiki/Hypervisors" target="_blank">Hypervisor</a>
    has existed since 1965 when software was used on the IBM 360/65 to
    emulate an IBM 7080 with computation time split between the separate modes.
    Modern Hypervisors provide Operating System virtualization to provide
    better security and reliability.  There is meant to be minimal software
    development effort when utilizing a virtualized Operating System, so
    it is an obvious choice for source code that is not actively developed
    (<a href="http://en.wikipedia.org/wiki/Legacy_software" target="_blank">legacy software</a>)
    and lacks reliability/scalability.  Part of the reason Hypervisors
    have not been popular in the past is because virtualization increases
    the hardware requirements for the same amount of processing.  Hardware
    has advanced enough that many software applications are unable to fully
    utilize the hardware capacity that has become commonplace.  For software
    that is often idle, Hypervisors can provide cost savings on both
    hardware and power without software modifications.
  </p>
  <h4>Integration "Clouds"</h4>
  <p class="paragraph">
    Integration "Clouds" provide software developers with a platform for
    simpler integration development.
    Popular examples include:
    <a href="http://en.wikipedia.org/wiki/AppScale" target="_blank">AppScale</a>,
    <a href="http://en.wikipedia.org/wiki/Cloud_Foundry" target="_blank">CloudFoundry</a>,
    OpenShift,
    and
    <a href="http://en.wikipedia.org/wiki/Heroku" target="_blank">Heroku</a>.
    Generally, Integration "Clouds" provide software packages for common
    scripting language deployment scenarios (typically Python and Ruby
    web frameworks).  Integration "Clouds" (PaaS) normally do not provide
    fault-tolerance or reliability, so they are typically deployed with a
    Hypervisor.
  </p>
  <p class="paragraph">
    CloudI is an Integration Cloud that focuses on flexible integration
    that is efficient, scalable, and fault-tolerant.  CloudI does not
    force a user to use particular software libraries but instead provides
    light-weight interfaces for integration.  Scalability and fault-tolerance
    are both provided by CloudI's usage of the 
    <a href="http://en.wikipedia.org/wiki/Erlang_%28programming_language%29" target="_blank">Erlang programming language</a>.
    This means that no Hypervisor is necessary to make CloudI's processes
    reliable, so there can be a performance benefit when using CloudI.
    Scalability is a natural gain with CloudI's Erlang concurrency which 
    reduces the amount of power and hardware necessary to facilitate
    external connections, making CloudI a greener solution!
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_WhatIs"></a>
  <h3>1.4 - What is CloudI?</h3>
  <h4>Short Answer</h4>
  <p class="paragraph">
    An application server that efficiently integrates with many languages,
    many databases, and many messaging buses in a way that is both scalable
    and fault-tolerant.
  </p>
  <h4>Long Answer</h4>
  <p class="paragraph">
    CloudI is an implementation of <a href="#1_Name">Cloud functionality</a>
    that can be developed and deployed publicly or privately.  CloudI provides
    a simple server back-end that can be used for infrastructure development
    of data processing systems, event processing systems, web services, and
    combinations thereof.  CloudI is a system that enforces <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">RESTful development practices</a>
    and provides a <a href="http://en.wikipedia.org/wiki/Service_oriented_architecture" target="_blank">Service Oriented Architecture (SOA)</a>.
    CloudI services communicate with messaging that can be controlled by simple
    Access Control List (ACL) entries (to provide service communication
    isolation).
  </p>
  <p class="paragraph">
    CloudI was architected to easily integrate with other services, software,
    and frameworks.  The CloudI API provides a light-weight interface for
    creating services in C/C++, Erlang, Java, Python, and Ruby.  By using
    CloudI, external software can become more scalable and fault-tolerant
    by utilizing CloudI's load balancing of CloudI requests.  CloudI
    messaging enforces realtime constraints using timeouts, so that request
    failures can be handled locally within the service where they are most
    relevant.  ACL entries explicitly allow or deny communication between
    services and are a simple method of isolating critical services from
    potentially volatile services.  All CloudI API usage in languages other
    than Erlang receive the isolation of Operating System processes
    and are called external services.  External services can utilize the
    CloudI API with any threading library to achieve greater scalability and
    reduce internal latency.  The Erlang CloudI API is used to create
    internal services which utilize light-weight Erlang processes.
    <a href="#6_contents">Examples of using the CloudI API</a>
    are provided as integration tests or internal services.
  </p>
  <p class="paragraph">
    The Job API provides dynamic configuration which is accessible from any
    allowed CloudI service (i.e., allowed based on the ACL entries).  The
    Job API is accessible remotely by using Erlang terms or JSON-RPC over HTTP.
    <a href="https://github.com/okeuday/CloudI/tree/master/src/job_api#readme" target="_blank">Examples of using the Job API</a>
    are provided as separate integration tests.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_OS"></a>
  <h3>1.5 - On what Operating Systems does CloudI run?</h3>
  <p class="paragraph">
    CloudI runs on UNIX-based operating systems like Linux (<a href="http://www.ubuntu.com/" target="_blank">Ubuntu</a>, etc.)
    and BSDs (<a href="http://www.freebsd.org/" target="_blank">FreeBSD</a>, <a href="http://www.openbsd.org/" target="_blank">OpenBSD</a>, <a href="http://www.netbsd.org/" target="_blank">NetBSD</a>, <a href="http://www.apple.com/macosx/" target="_blank">OSX</a>, etc.).
    CloudI development has primarily taken place on Ubuntu and other
    Operating Systems may not be completely tested yet.  Windows may work
    by using <a href="http://www.cygwin.com/" target="_blank">Cygwin</a>
    for dependencies.
  </p>
  <p class="paragraph">
    <a href="http://www.erlang.org/doc/installation_guide/INSTALL.html" target="_blank">Erlang</a>
    must be able to run on the system for CloudI to function properly.
    So, checking Erlang support would be a good place to start if you are
    experimenting with a different Operating System.  The information here
    will be updated as more Operating Systems are tested.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_Commercial"></a>
  <h3>1.6 - Is Commercial support available for CloudI?</h3>
  <p>
    <ul>
      <li>Integration Development</li>
      <li>Operations Maintenance</li>
    </ul>
    Contact <a href="mailto:mjtruog@gmail.com">Michael Truog</a>
    if you are interested in commercial CloudI support.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_ReallyFree"></a>
  <h3>1.7 - Is CloudI really free?</h3>
  <p class="paragraph">
    CloudI is completely free.  CloudI uses a <a href="LICENSE.txt" target="_blank">BSD license</a>
    which permits reuse for personal or commercial purposes.  Small amounts of
    source code is included that is under the <a href="http://www.erlang.org/EPLICENSE" target="_blank">Erlang Public License</a>
    (e.g., part of the <a href="https://github.com/okeuday/CloudI/tree/master/src/api/java/com" target="_blank">Java CloudI API</a> and <a href="https://github.com/okeuday/CloudI/blob/master/src/lib/cloudi/src/list_pg.erl" target="_blank">list_pg.erl</a>) like <a href="http://www.erlang.org/" target="_blank">Erlang</a>
    itself.  All external source code dependencies are also under a
    BSD license.  Some conditional external source code dependencies
    (not included by default) are under other licenses
    (e.g., <a href="http://www.zeromq.org/" target="_blank">ZeroMQ</a>
    is under the LGPL license).  For a more detailed look at the
    licenses of external dependencies, please check the <a href="https://github.com/okeuday/CloudI/blob/master/src/external/README.markdown#readme" target="_blank">src/external/README</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_WhoDevelops"></a>
  <h3>1.8 - Who develops CloudI?</h3>
  <p class="paragraph">
    <a href="mailto:mjtruog@gmail.com">Michael Truog</a>
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_PrivateCloud" ></a>
  <h3>1.9 - Can I use CloudI as a Private Cloud?</h3>
  <p class="paragraph">
    Yes!  CloudI provides everything for running a Cloud in isolation
    (i.e., without a connection to the Internet).  For more details,
    please refer to <a href="#1_WhatIs">"1.4 - What is CloudI?"</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_OnlineService"></a>
  <h3>1.10 - Can I use CloudI as an Online Service?</h3>
  <p class="paragraph">
    Yes!  CloudI accepts incoming HTTP traffic and can be easily extended
    to handle other incoming protocols.  For more details,
    please refer to <a href="#1_WhatIs">"1.4 - What is CloudI?"</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_CAP"></a>
  <h3>1.11 - What CAP theorem guarantees does CloudI provide?</h3>
  <p class="paragraph">
    CloudI is an <a href="http://en.wikipedia.org/wiki/CAP_theorem" target="_blank">AP-type distributed system</a>
    (guarantees of Availability and Partition tolerance). A Consistency
    guarantee (the guarantee not provided by CloudI) can be provided by
    either a CloudI service interface to a database driver or a
    CloudI service interface to a messaging bus (i.e., to a persistent
    message queue).  In both cases, a request can be sent to the CloudI
    service with the CloudI API (if the response is stored, the request
    succeeded).
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_REST"></a>
  <h3>1.12 - Does CloudI support REST?</h3>
  <p class="paragraph">
    Yes!  CloudI is a system that enforces <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">RESTful development practices</a>.
    For more details please refer to <a href="#1_WhatIs">"1.4 - What is CloudI?"</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_PaaS"></a>
  <h3>1.13 - Is CloudI a Platform as a Service (PaaS)?</h3>
  <p class="paragraph">
    Yes!  CloudI can be used as a <a href="http://en.wikipedia.org/wiki/Platform_as_a_service" target="_blank">Platform as a Service (PaaS)</a>
    and is the first <a href="#1_Clouds">fault-tolerant PaaS open source project</a>.
    CloudI is not limited to the development of web services and has
    a broader focus.  CloudI also does not enforce particular development
    libraries on the programmer, so it is a much more flexible framework.
    For more details please refer to <a href="#1_WhatIs">"1.4 - What is CloudI?"</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_HowAbout"></a>
  <h3>1.14 - Why doesn't CloudI integrate with ProductX?</h3>
  <p class="paragraph">
    There are many possibilities for CloudI integration.  If you know of a
    public product that you think should be integrated or if you need
    commercial support for a private product, contact
    <a href="mailto:mjtruog@gmail.com">Michael Truog</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <hr \>
  <h2>2 - Learning about CloudI</h2>

  <a name="2_WebPages"></a>
  <h3>2.1 - Web Pages</h3>
  <table><tr><td>
  Main Web Site:
  </td><td>
  <a href="http://cloudi.org">http://cloudi.org</a>
  </td></tr><tr><td>
  Source Code:
  </td><td>
  <a href="https://github.com/okeuday/CloudI#readme" target="_blank">https://github.com/okeuday/CloudI</a>
  </td></tr><tr><td>
  Releases:
  </td><td>
  <a href="http://sourceforge.net/projects/cloudi/files/" target="_blank">http://sourceforge.net/projects/cloudi/files/</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <a name="2_MailingList"></a>
  <h3>2.2 - Mailing List</h3>
  <table><tr><td>
  Email Address:
  </td><td>
  <a href="mailto:cloudi-questions@googlegroups.com" target="_blank">cloudi-questions@googlegroups.com</a>
  </td></tr><tr><td>
  Subscribe:
  </td><td>
  <a href="http://groups.google.com/group/cloudi-questions/subscribe" target="_blank">http://groups.google.com/group/cloudi-questions/subscribe</a>
  </td></tr><tr><td>
  Archive:
  </td><td>
  <a href="http://groups.google.com/group/cloudi-questions" target="_blank">http://groups.google.com/group/cloudi-questions</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <a name="2_IRC"></a>
  <h3>2.3 - Internet Relay Chat (IRC)</h3>
  <table><tr><td>
  IRC Server:
  </td><td>
  <a href="http://freenode.net/irc_servers.shtml" target="_blank">irc.freenode.net</a>
  </td></tr><tr><td>
  Chat Room:
  </td><td>
  <a href="http://webchat.freenode.net?randomnick=1&channels=cloudi" target="_blank">#cloudi (#erlang can offer additional help, if necessary)</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <a name="2_RSS"></a>
  <h3>2.4 - RSS Feeds</h3>
  <table><tr><td>
  Development:
  </td><td>
  <a href="https://github.com/feeds/okeuday/commits/CloudI/master" target="_blank">https://github.com/feeds/okeuday/commits/CloudI/master</a>
  </td></tr><tr><td>
  Releases:
  </td><td>
  <a href="http://sourceforge.net/api/file/index/project-id/281423/mtime/desc/limit/20/rss" target="_blank">http://sourceforge.net/api/file/index/project-id/281423/mtime/desc/limit/20/rss</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <a name="2_Presentations"></a>
  <h3>2.5 - Presentations</h3>
  <table><tr><td>
  Version 0.1.6
  </td><td>
  <a href="docs/cloudi_erlounge_vancouver2011.pdf" target="_blank">2011 ErLounge Meetup Vancouver BC (slides)</a>
  </td></tr><tr><td>
  Version 0.1.5
  </td><td>
  <a href="docs/cloudi_erlounge_sfbay2011.pdf" target="_blank">2011 ErLounge Meetup SF Bay Area (slides)</a>
  </td></tr><tr><td>
  Version 0.0.9
  </td><td>
  <a href="docs/cloudi_ef_sfbay2010.pdf" target="_blank">2010 Erlang Factory SF Bay Area (slides)</a> <a href="docs/cloudi_ef_sfbay2010.txt" target="_blank">(demo text)</a>
  </td></tr><tr><td>
  Version 0.0.8
  </td><td>
  <a href="http://vimeo.com/8192137" target="_blank">2009 Erlang User Conference (video)</a> <a href="docs/cloudi_euc2009.pdf" target="_blank">(slides)</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <a name="2_Reporting Bugs"></a>
  <h3>2.6 - Reporting Bugs</h3>
  <table><tr><td>
  Bug Reports:
  </td><td>
  <a href="https://github.com/okeuday/CloudI/issues/new" target="_blank">https://github.com/okeuday/CloudI/issues/new</a>
  </td></tr><tr><td>
  <a href="#2_MailingList">Mailing List:</a>
  </td><td>
  <a href="mailto:cloudi-questions@googlegroups.com" target="_blank">cloudi-questions@googlegroups.com</a>
  </td></tr></table>
  <p class="paragraph">
    If you are unsure whether you have found a bug, please send an email to the
    mailing list.  Otherwise, you can easily enter a bug report for the problem
    by using the online form.
  </p>
  <div class="top"><a href="#2_contents">Top</a></div>

  <hr \>
  <h2>3 - CloudI Installation Guide</h2>

  <a name="3_Overview"></a>
  <h3>3.1 - Overview</h3>
  <p>
    Installation of CloudI from source (within the archive's "src" directory)
    uses the typical open source command sequence of:
    <ol style="font-family: monospace">
      <li>./configure</li>
      <li>make</li>
      <li>make install</li>
    </ol>
    Currently, it is best to install into a local directory with a command like:
    <pre>
./configure --prefix=`pwd`/../cloudi_install
    </pre>
    More work will be occurring on the build system (autoconf/automake/rebar)
    to make sure the deployment is more typical for UNIX systems
    (i.e., all configuration in "etc" and all logs in "/var/logs")
    but this work is not yet complete.
  </p>
  <p class="paragraph">
    All the supported languages
    are currently required for the configuration, so that the generated
    configuration uses valid paths and the integration tests can be run.
    So, that means that the configuration will expect a C compiler,
    a C++ compiler, Java Development Kit (JDK), Python, Ruby (&ge; 1.9), and
    Erlang (&ge; R14B01, <a href="http://www.erlang.org/download.html" target="_blank">preferably R14B02 or later</a>).
    Dependencies as they are packaged for different operating systems are
    listed below:
    <table><tr><th>
    Operating System
    </th><th>
    Packages
    </th></tr><tr><td>
    Ubuntu<br />(apt-get install &lt;package(s)&gt;)
    </td><td>
    <ul>
      <li>g++</li>
      <li>libboost-thread-dev</li>
      <li>libboost-dev</li>
      <li>default-jdk</li>
      <li>python</li>
      <li>ruby1.9</li>
      <li>libgmp3-dev</li>
    </ul>
    </td></tr></table>
  </p>
  <div class="top"><a href="#3_contents">Top</a></div>

  <a name="3_Options"></a>
  <h3>3.2 - Installation Options</h3>
  <p>
    Common CloudI installation configuration options
    ("./configure" command line arguments) are:
    <table><tr><td>
    --prefix="/path/to/install/"
    </td><td>
    Specify an Installation Path
    </td></tr><tr><td>
    --with-zeromq
    </td><td>
    Include <a href="http://www.zeromq.org/" target="_blank">ZeroMQ</a> support
    </td></tr></table>
  </p>
  <p class="paragraph">
    For more installation configuration option details, please refer to
    <a href="https://github.com/okeuday/CloudI/blob/master/src/INSTALL" target="_blank">src/INSTALL</a>.
  </p>
  <div class="top"><a href="#3_contents">Top</a></div>

  <a name="3_OSX"></a>
  <h3>3.3 - OS X Installation</h3>
  <p class="paragraph">
    To install CloudI dependencies on OSX you either need <a href="http://www.macports.org/" target="_blank">macports</a> or
    <a href="https://mxcl.github.com/homebrew/" target="_blank">homebrew</a>.
    With macports, CloudI configuration can be executed with:
  </p>
  <p style="font-family: monospace">
    CXXFLAGS="-I/opt/local/include" LDFLAGS="-L/opt/local/lib" ./configure
  </p>
  <div class="top"><a href="#3_contents">Top</a></div>

  <a name="3_Running"></a>
  <h3>3.4 - Running CloudI</h3>
  <p>
    If CloudI is installed in PREFIX (set with the configure script --prefix=
    command line argument), then CloudI can be started with:
<pre>
PREFIX/bin/cloudi start
</pre>
    To stop the running CloudI node, execute:
<pre>
PREFIX/bin/cloudi stop
</pre>
  </p>
  <p class="paragraph">
    When CloudI is running, CloudI logging output will be appended to
    PREFIX/logs/cloudi.log (the installation will change in the future to
    put the log into /var/log/cloudi.log if CloudI is installed with sufficient
    permissions).
  </p>
  <div class="top"><a href="#3_contents">Top</a></div>

  <a name="3_Config"></a>
  <h3>3.5 - Configuration</h3>
  <p class="paragraph">
    The CloudI configuration provides all the initial parameters for startup.
    It is also possible to do the same configuration with the CloudI Job API
    (so, the configuration can also be done dynamically as described in
    <a href="#4_JobAPI">"4.2 - How do I control CloudI dynamically?"</a>).
  </p>
  <p class="paragraph">
    The configuration is organized into sections for the ACLs, Jobs, Nodes, and
    Logging.  The ACLs provide a name which can be referenced by a Job to
    either explicitly allow or deny communication between services
    (based on service name prefixes, see 
    <a href="#4_ACLs">"4.6 - How do I use Access Control Lists (ACLs)?"</a>
    for more information).
  </p>
  <p class="paragraph">
    The Jobs configuration specifies both the services that are ran
    and the order in which the services should be started.  The "internal" Jobs
    are Erlang modules that use the cloudi_job behavior.  The "external" Jobs
    are all non-Erlang languages that use the CloudI API.  There is more
    information about service integration in
    <a href="#6_C">"6 - Services"</a> and
    <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <p class="paragraph">
    The Nodes configuration lists all CloudI nodes that should be connected.
    This allows the CloudI node connections to reconnect after network failures.
  </p>
  <p class="paragraph">
    The Logging configuration specifies the logging level and whether the
    logging output should be directed to a different CloudI node
    (which is present in the Nodes section).  If the logging is redirected to
    a different CloudI node, it is possible to lose logging data when a network
    outage occurs.  However, if the node has failed, the logging output will
    be stored locally until the node reconnects (i.e., the logging output is
    redirected to the CloudI node automatically, when it is connected).
  </p>
  <p>
    Below is a summary of the layout of the CloudI configuration file.  The
    ()s have been used to specify the configuration parameters that are
    supplied.  You can find this file in
    <a href="https://github.com/okeuday/CloudI/blob/master/src/cloudi.conf.in" target="_blank">src/cloudi.conf.in</a>
    within the source code repository (in its state before it gets modified
    by the local operating system configuration parameters) or
    PREFIX/var/log/cloudi/cloudi.log after the installation.
<pre>
{acl, [
    {(AliasName), [(ServiceNamePrefix) or (AliasName), ...]}
    ...
]}.
{jobs, [
    {internal,
     (ServiceNamePrefix),
     (ErlangModuleName),
     (ModuleInitializationList),
     (DestinationRefreshMethod),
     (InitializationTimeout),
     (DefaultAsynchronousTimeout),
     (DefaultSynchronousTimeout),
     (DestinationDenyACL),
     (DestinationAllowACL),
     (ProcessCount),
     (MaxR),
     (MaxT),
     (ServiceOptionsPropList)},
    {external,
     (ServiceNamePrefix),
     (ExecutableFilePath),
     (ExecutableCommandLineArguments),
     (ExecutableEnvironmentalVariables),
     (DestinationRefreshMethod),
     (Protocol),
     (ProtocolBufferSize),
     (InitializationTimeout),
     (DefaultAsynchronousTimeout),
     (DefaultSynchronousTimeout),
     (DestinationDenyACL),
     (DestinationAllowACL),
     (ProcessCount),
     (ThreadCount),
     (MaxR),
     (MaxT),
     (ServiceOptionsPropList)},
    ...
]}.
{nodes, [
    'cloudi@hostname1',
    ...
]}.
{logging, [
    {level, trace}, % levels: off, fatal, error, warn, info, debug, trace
    {redirect, undefined or (Node)}
]}.
</pre>
  </p>
  <p class="paragraph">
    The default configuration runs a variety of integration tests
    which are used to test CloudI:
    <ul>
      <li>hexpi</li>
      <li>http</li>
      <li>http_req</li>
      <li>zeromq</li>
      <li>msg_size</li>
      <li>messaging</li>
    </ul>
    Some of the tests are explained within <a href="#6_C">"6 - Services"</a>.
    All of the tests can be found within the source code repository in
    <a href="https://github.com/okeuday/CloudI/tree/master/src/tests" target="_blank">src/tests</a>.  There is no reason to keep the tests within the
    configuration once you start using CloudI for your own integration.
  </p>
  <div class="top"><a href="#3_contents">Top</a></div>

  <hr \>
  <h2>4 - General Questions</h2>

  <a name="4_API"></a>
  <h3>4.1 - How do I integrate external software with CloudI?</h3>
  <p class="paragraph">
    There are many integration points for external software to become CloudI
    services or utilize CloudI services.  The current integration points are:
    <ul>
      <li>CloudI API</li>
      <li>ZeroMQ</li>
      <li>HTTP</li>
      <li>Supported databases
      <ul>
        <li>CouchDB</li>
        <li>memcached</li>
        <li>MySQL</li>
        <li>PostgreSQL</li>
        <li>Tokyo Tyrant</li>
      </ul>
      </li>
    </ul>
  </p>
  <h4>CloudI API</h4>
  <p class="paragraph">
    The CloudI API provides a light-weight interface for creating services
    in C/C++, Erlang, Java, Python, and Ruby.  Services subscribe to receive
    requests from other services using the CloudI API "subscribe" function
    call.  The subscribe function call takes a suffix string that is expected to
    contain a path using a forward slash '/' (e.g., /cloudi/api/json_rpc/).
    However, the service configuration provides the prefix for the subscription
    function call, so "/cloudi/api/" is provided as a configuration prefix
    (for the Job API service) but the subscribe function call only needs to
    be called with the string "json_rpc/" so that a subscription takes place
    for any services sending requests to "/cloudi/api/json_rpc/",
    which is called a "name".
  </p>
  <p class="paragraph">
    The requests are load balanced across all the services that have subscribed
    to the same name during the lookup to find the request destination.
    There is a service configuration parameter called the "destination refresh"
    that determines how the internal CloudI load balancing occurs when a
    request is sent from that service.  The possible destination refresh
    values are: 
    <ul>
      <li>lazy_closest</li>
      <li>lazy_random</li>
      <li>immediate_closest</li>
      <li>immediate_random</li>
      <li>none</li>
    </ul>
    The "none" destination refresh is used for services that never send
    requests (i.e., they only receives requests) and creates
    an error that terminates the service if the service does send a request.
    The "lazy" prefix destination refresh methods use an older cached value
    for determining service destinations, so services that communicate
    primarily with long-lived services can use a "lazy" prefix destination
    refresh for more scalable communication.  The "immediate" prefix
    destination refresh methods always use current information for
    determining service destinations, so services that communicate primarily
    with short-lived services can always send to relevant destinations.
    The "closest" suffix destination refresh methods always prefer
    services that exist on the local CloudI node, over remote CloudI nodes.
    The "random" suffix destination refresh methods load balances evenly
    across all services on all CloudI nodes.
  </p>
  <p class="paragraph">
    The following functions exist in the CloudI API for sending a request:
    <ul>
      <li>send_async</li>
      <li>send_sync</li>
      <li>mcast_async</li>
    </ul>
    The "send" prefix functions send a binary message (uninterpreted raw data)
    to a single service name (which is then load balanced among the available
    services).  If the service name does not exist, the request will be retried
    until the request timeout elapses and no binary data will be returned
    (i.e., returning no data is equivalent to a timeout).  
    If a service receives a request while handling an older request, the
    request is queued based on its priority, where -128 is the highest priority,
    0 is the default priority and 127 is the lowest priority.
    The "mcast" prefix
    function provides publish functionality, so a binary message is published
    to all services that have subscribed to a single service name.  However,
    the "mcast" prefix function is slightly different from other publish
    functionality because it returns all the transaction ids (UUIDs used
    to uniquely identify a request among all CloudI nodes) so that responses
    (if any are returned) may be retrieved.  A service can utilize publish
    behavior that doesn't return data by simply returning no data
    (since returning no data is equivalent to a timeout).  The "async" suffix
    functions (i.e., asynchronous) only return the transaction id of the
    sent request(s) so that the response may be queried with the
    "recv_async" function.  The "recv_async" function can also be used with a
    null UUID to return the oldest response that was received.
    If no services are available for the name of
    the destination, the "async" suffix function will block until the
    destination is found to send the request by retrying the send until
    the timeout elapses (i.e., the asynchronous sends are asynchronous after
    the send takes place).  The "sync" suffix function will block until
    a response is returned or the timeout elapses.  If a response is returned
    with no data, a timeout will be returned instead.  If the request
    destination name is blocked by an Access Control List (ACL) entry, a
    timeout will be returned immediately from the send function.
  </p>
  <p class="paragraph">
    When a service receives a request, it is passed as a parameter to the
    callback function.  The callback function was specified as an argument
    to the "subscribe" function.  However, in Erlang all requests use the
    same callback function which is cloudi_job_handle_request/11.
    Within the callback function any send or receive operations can take place.
    When the callback function wants to terminate it can either return a result
    or forward the request to another service name by using the "return"
    function or the "forward" function, respectively.  If the service does not
    want to return a response, the service can simply call "return" with
    an empty binary response value and it will be interpreted as if the
    request timeout elapsed.  Using the "forward" function will decrease the
    request timeout slightly (by 100ms) to prevent requests from causing
    persistent traffic.
  </p>
  <p class="paragraph">
    The Access Control List (ACL) is simply a list of strings that define
    prefixes that must be explicitly allowed or denied when determining if a
    service can send to the service name.  If a prefix is both allowed and
    denied, the prefix is denied (deny takes precedence).  When defining ACLs,
    it is possible to use Erlang atoms to represent lists of string prefixes
    so that logical groupings are created.  The ACL atoms are then able to
    be specified anywhere a normal ACL string might be present.  So, it is
    best to group ACL string prefixes based on context to simplify the
    configuration specification.  A complete service name is also a valid
    ACL string for explicitly blocking or allowing a single service name,
    though this usage of ACLs is uncommon.
  </p>
  <p class="paragraph">
    The CloudI API external service requests are limited to 2GB when using
    the tcp protocol.  Using the udp protocol for external services is
    experimental (it limits service requests to the minimum of both the
    loopback MTU and the buffer size).
    The buffer size for external services is typically set
    to 16384 bytes because that is a power of 2 closest to the MTU of the
    loopback device (normally 16436 on Linux).  External service configuration
    can specify the number of threads per process and the number of processes
    which should be spawned, so that each thread receives an instance of the
    CloudI API.  This means that there can be one ioloop per thread per process
    for maximum throughput.
  </p>
  <a name="4_API_ZeroMQ"></a>
  <h4>ZeroMQ</h4>
  <p class="paragraph">
    ZeroMQ integration provides a way of connecting to external <a href="http://www.zeromq.org/" target="_blank">ZeroMQ</a>
    messaging or other CloudI nodes by using ZeroMQ as the messaging bus.
    The cloudi_job_zeromq service is an Erlang service that provides
    ZeroMQ integration by defining a set of mappings between service names
    and the ZeroMQ destinations.  To use ZeroMQ with CloudI, you need to make
    sure and enable ZeroMQ with the configuration script (with
    "./configure --with-zeromq").  The cloudi_job_zeromq configuration
    (in the cloudi.conf file or through the Job API jobs_add/1 function)
    allows key/value tuples with the following key atoms: outbound, inbound,
    publish, subscribe, push, and pull, which are the following ZeroMQ
    equivalents: ZMQ_REQ, ZMQ_REP, ZMQ_PUB, ZMQ_SUB, ZMQ_PUSH, and ZMQ_PULL,
    respectively.  The value is a tuple that contains a mapping key/value
    where the key is the service name suffix and the value is the list of
    ZeroMQ endpoints.  However, the publish and subscribe ZeroMQ configuration
    is slightly more complex because instead of a service name, it contains
    a list of key/value ZeroMQ subscription mapping where the key is the
    service name suffix and the value is the ZeroMQ subscription string.
    The example configuration file entry below should illustrate the ZeroMQ
    service configuration:
    <pre>
% an entry in the cloudi.conf configuration file
% that uses the ZeroMQ service
{internal,
    "/tests/zeromq/",
    % inbound/outbound message paths much be acyclic
    % (if they are not, you will receive a erlzmq EFSM error
    %  because the ZeroMQ REQ has received 2 zmq_send calls)
    cloudi_job_zeromq,
    % outbound ZeroMQ requests connect a CloudI name to a ZeroMQ endpoint
    [{outbound, {"zigzag_start", ["ipc:///tmp/cloudizigzagstart"]}},
    % inbound ZeroMQ replies connect a ZeroMQ endpoint to a CloudI name
     {inbound, {"zigzag_step1", ["ipc:///tmp/cloudizigzagstart"]}},
     {outbound, {"zigzag_step1", ["inproc://zigzagstep1"]}},
     {inbound, {"zigzag_step2", ["inproc://zigzagstep1"]}},
    % ZeroMQ publish connects a CloudI name to a ZeroMQ (subscribe) name
    % as {CloudI name (suffix), ZeroMQ name for message prefix}
    % for any number of endpoints
     {publish, {[{"zigzag_step2", "/zeromq/step2"}],
                ["inproc://zigzagstep2a",
                 "ipc:///tmp/cloudizigzagstep2b",
                 "inproc://zigzagstep2c",
                 "ipc:///tmp/cloudizigzagstep2d"]}},
    % ZeroMQ subscribe connects a CloudI name to a ZeroMQ (subscribe) name
    % as {CloudI name (suffix), ZeroMQ name for subscribe setsocketopt}
    % for any number of endpoints
     {subscribe, {[{"zigzag_step3a", "/zeromq/step2"},
                   {"zigzag_step3b", "/zeromq/step2"}],
                  ["inproc://zigzagstep2a",
                   "ipc:///tmp/cloudizigzagstep2b",
                   "inproc://zigzagstep2c",
                   "ipc:///tmp/cloudizigzagstep2d"]}},
     {outbound, {"zigzag_step3a", ["inproc://zigzagstep3"]}},
     {inbound, {"zigzag_finish", ["inproc://zigzagstep3"]}}],
    immediate_closest,
    5000, 5000, 5000, [api], undefined, 2, 5, 300, []}
    </pre>
  </p>
  <a name="4_API_HTTP"></a>
  <h4>HTTP</h4>
  <p class="paragraph">
    The Erlang service cloudi_job_http accepts HTTP traffic and
    makes the HTTP requests CloudI requests where the HTTP path in the URL
    is used as the service name.
    By default, the HTTP method is specified as a suffix on the HTTP path
    (e.g., "/index.html/get") but this can be disabled with the
    "use_method_suffix" configuration parameter.
    When a HTTP request is received
    the corresponding service name will be called with the request contents
    (uncompressed, if the request was compressed).  The headers are passed
    within the "request info" as key-value pairs that is request meta-data.
    The content type of the
    response is either forced by the configuration (with "content_type") or
    it is determined by the file extension on the service name.
  </p>
  <h4>Supported Databases</h4>
  <p class="paragraph">
    All the supported databases can be accessed by CloudI services.
    The CloudI Erlang service that provides database support
    (e.g., cloudi_job_db_pgsql, cloudi_job_db_mysql, etc.) uses
    the database name as the service name suffix.  Services can send requests
    to the database service name in the appropriate format to
    interact with the database.  The format to send is either SQL for an
    SQL database or a command tuple if it is a NoSQL database
    (e.g., {'set', "key", "value"}).
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_JobAPI"></a>
  <h3>4.2 - How do I control CloudI dynamically?</h3>
  <p class="paragraph">
    CloudI's configuration can be changed dynamically while it is running
    by using the Job API.  The Job API can be used by any CloudI services.
    However, typical usage of the Job API would use raw HTTP requests or
    JSON-RPC over HTTP.  A complex example of using the Job API through
    JSON-RPC over HTTP with python code can be found in <a href="https://github.com/okeuday/CloudI/blob/master/src/tests/job_api/run.py" target="_blank">src/tests/job_api/run.py</a>.
    Some simpler examples of using the Job API can be found at
    <a href="https://github.com/okeuday/CloudI/blob/master/src/tests/job_api/path.py" target="_blank">src/tests/job_api/path.py</a>,
    <a href="https://github.com/okeuday/CloudI/blob/master/src/tests/job_api/logging_off.py" target="_blank">src/tests/job_api/logging_off.py</a> and
    <a href="https://github.com/okeuday/CloudI/blob/master/src/tests/job_api/logging_on.py" target="_blank">src/tests/job_api/logging_on.py</a>.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_PubSub"></a>
  <h3>4.3 - How do I use Publisher/Subscriber messaging?</h3>
  <p class="paragraph">
    The simplest way to use publisher/subscriber functionality is to use the
    CloudI API functions "mcast_async" for publishing and "subscribe" for
    subscribing.  For more details please refer to the <a href="#4_API">CloudI API documentation</a>.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_RPC"></a>
  <h3>4.4 - How do I use Remote Procedure Calls (RPC)?</h3>
  <p class="paragraph">
    Remote procedure calls can easily be used within CloudI services with a
    CloudI API "send_sync" function call.  The RPC procedure name is used
    as a service name suffix and the RPC parameters are stored in the
    request body.  The request body is simply uninterpreted
    binary data, so no format is imposed on the user of the CloudI API.
    Any request meta-data should be specified as key-value pairs within the
    "request info" parameter.  The "response info" parameter can be used
    for response meta-data in the same way.
    For more details please refer to the <a href="#4_API">CloudI API documentation</a>.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_WebServices"></a>
  <h3>4.5 - How do I create Web Services?</h3>
  <p class="paragraph">
    Web Services are simply CloudI services that accept incoming HTTP traffic
    coming from the cloudi_job_http service.  The request body is either
    the body of the uncompressed PUT or POST request, or it is the
    GET query string.
    For more details please refer to the <a href="#4_API">CloudI API documentation</a>.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_ACLs"></a>
  <h3>4.6 - How do I use Access Control Lists (ACLs)?</h3>
  <p class="paragraph">
    Access Control Lists (ACLs) are used to explicitly allow or deny requests
    from being sent to service name prefixes.  Two separate ACL parameters are
    specified for each service configuration to allow or deny destinations.
    If an ACL is not provided, the atom 'undefined' is used instead.  An ACL is
    provided as a list of strings that are service name prefixes.  Instead of a
    string, an atom alias may be provided that was defined in the 'acl'
    configuration so that the service configuration is simpler and more
    consistent (i.e., without strings that are replicated among the service
    configuration entries).  A fake sample from a configuration file can
    illustrate how this works:
<pre>
{acl, [
    {alias1, ["/service/name/prefix1", "/service/name/prefix2", alias2]},
    {alias2, ["/subsystem1/prefix1", "/subsystem2/prefix1"]}
]}.
{jobs, [
    {internal,
     (ServiceNamePrefix),
     (ErlangModuleName),
     (ModuleInitializationList),
     (DestinationRefreshMethod),
     (InitializationTimeout),
     (DefaultAsynchronousTimeout),
     (DefaultSynchronousTimeout),

     % ACL DENY LIST
     % (e.g, valid values could be: undefined or [alias1] or [alias2] or etc.)
     (DestinationDenyList),
     
     % ACL ALLOW LIST
     % (e.g, valid values could be: undefined or [alias1] or [alias2] or etc.)
     (DestinationAllowList),

     (ProcessCount),
     (MaxR),
     (MaxT),
     (ServiceOptionsPropList)},
    {external,
     (ServiceNamePrefix),
     (ExecutableFilePath),
     (ExecutableCommandLineArguments),
     (ExecutableEnvironmentalVariables),
     (DestinationRefreshMethod),
     (Protocol),
     (ProtocolBufferSize),
     (InitializationTimeout),
     (DefaultAsynchronousTimeout),
     (DefaultSynchronousTimeout),

     % ACL DENY LIST
     % (e.g, valid values could be: undefined or [alias1] or [alias2] or etc.)
     (DestinationDenyList),

     % ACL ALLOW LIST
     % (e.g, valid values could be: undefined or [alias1] or [alias2] or etc.)
     (DestinationAllowList),

     (ProcessCount),
     (ThreadCount),
     (MaxR),
     (MaxT),
     (ServiceOptionsPropList)},
]}.
...
</pre>
  </p>
  <p class="paragraph">
    The Job API supports dynamically starting services by supplying a 'jobs'
    list in the same format as the configuration file.  The Job API also
    supports defining multiple 'acl' aliases that may be referenced from
    dynamically configured services.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_ServiceFail"></a>
  <h3>4.7 - How do I Migrate a Service from a Failed or Failing Node?</h3>
  <p class="paragraph">
    A migration would imply that there is unavoidable latency during a
    switchover from a failed node to a healthy node.  To avoid failover latency
    and improve scalability, services are replicated on all nodes.  Proper
    service implementation dictates that services will only cache data.
    All dynamic state a service uses should be accessed and/or stored by a
    database.  To communicate with a database, a service should use the
    CloudI API to send requests to a configured CloudI database integration
    service.  The implementation of services that avoids state-keeping within
    the service's data structures is required to make sure a service is
    scalable, fault-tolerant and can recover from a failure without losing
    a significant amount of data.
  </p>
  <p class="paragraph">
    So, a service should not need to be migrated from a node.  If a node has
    failed there are many possible courses of action:
    <ul>
      <li>Shutdown CloudI on the Failed Node</li>
      <li>Stop the Service on the Failed Node by using the Job API</li>
      <li>Disconnect the Failed Node from the Network to Diagnose in Isolation</li>
    </ul>
    Since services are replicated on other nodes the system is fault-tolerant
    and can operate without a failed node.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_URLregex"></a>
  <h3>4.8 - Can I use Regular Expressions with Service Names (URLs)?</h3>
  <p class="paragraph">
    A simpler substitute for regular expressions is provided for matching
    CloudI service names.  The "*" character (a wildcard character) is
    used to match 1 or more character within a service name
    (i.e., a regex of '.+').  However, the sequence "**" is invalid and
    will cause the operation to fail.  Any number of wildcard characters can
    be used with the subscribe and unsubscribe CloudI API functions
    to create service names that match many patterns.  While this approach
    may seem unusual, it helps keep service name lookups both efficient
    and parallel (i.e., within the Erlang code, without any need to call an
    external regex integration library).
  </p>
  <p class="paragraph">
    Another possibility is just using explicit service names, even when the
    service name contains a dynamic parameter.  Using all possible service
    names is bounded by the memory available.  To give an idea of the memory
    consumption, on a 64-bit machine using service names that contain a
    single dynamic integer, 1 million integers used within 1 million
    subscribe CloudI API calls will consume roughly 100 MB of RAM when the
    CloudI service is ran (i.e., the service that performs the subscribe
    CloudI API calls).  All other CloudI services that use a "lazy"
    destination refresh method will replicate the service name data
    structure, so that will increase the node's memory consumption.
    So, depending on your needs and your memory limitations, you may want to
    use explicit service names or service names with wildcard characters.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_ThreadSafe"></a>
  <h3>4.9 - Is the CloudI API thread-safe?</h3>
  <p class="paragraph">
    The CloudI API is not thread-safe (i.e., it is not reentrant)
    because it is meant to be used by individual threads that are configured
    within the CloudI job configuration (e.g., using the CloudI configuration
    file or the CloudI Job API).  This approach avoids any lock contention
    issues outside of the Erlang VM.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_Speed"></a>
  <h3>4.10 - How can CloudI requests take advantage of cache coherency, minimum network latency, and any logical grouping?</h3>
  <p class="paragraph">
    To provide better computing node grouping, service names should uniquely
    describe the context of the node.  If the context is provided, then there
    is a natural grouping for CloudI requests with any CloudI API usage that
    uses the associated service name(s).
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <hr \>
  <h2>5 - Migrating to CloudI</h2>

  <a name="5_Performance"></a>
  <h3>5.1 - Performance Considerations</h3>
  <p class="paragraph">
    There is a latency penalty for communicating with a non-Erlang CloudI
    service because of the extra binary encoding and decoding when using
    the socket that connects the CloudI Erlang VM to the non-Erlang CloudI
    service Operating System (OS) process' thread.  The preemption of
    an Erlang VM scheduler thread by a CloudI service OS thread may
    degrade Erlang VM performance because of a mismatch between the
    kernel scheduler and the Erlang VM scheduler.  The kernel scheduler only
    knows when data is available to a process while the Erlang VM is able to
    schedule based on message queue size.  So, the Erlang VM scheduling
    is able to intelligently schedule CloudI services more so than the
    kernel scheduling.  However, the problem is unavoidable with current OSes
    and can be minimized by having a sufficiently large number of non-Erlang
    CloudI service threads and/or processes created to handle the throughput.
    The mismatch between the kernel scheduler and the Erlang VM scheduler is
    minimized by CloudI's management of CloudI requests, since an external
    service thread is only provided a single request at a time (and the
    mismatch is required to provide fault-tolerance by isolating the memory
    used by external services from the Erlang VM memory).
  </p>
  <p class="paragraph">
    When the number of requests sent to a service name exceeds the number
    of service processes, the services will begin to queue new requests while
    handling older requests (roughly, the distribution of requests to processes
    is random, so it may queue slightly early).  A priority parameter can be
    used if there is differing importance for various service requests
    (priority is normally used when there is a data dependency that needs to
    be solved).  The priority parameter is 0 by default, but -128 is the
    highest priority and 127 is the lowest priority, so that provides much
    room for representing asynchronous data dependencies (synchronous data
    dependencies would use a pipe pattern) or simply processing time priority.
  </p>
  <div class="top"><a href="#5_contents">Top</a></div>

  <a name="5_Scalability"></a>
  <h3>5.2 - Scalability Considerations</h3>
  <p class="paragraph">
    CloudI uses distributed Erlang for communicating between CloudI
    nodes (i.e., machines).  Distributed Erlang creates a fully-connected
    network topology which makes the cluster size of CloudI nodes limited
    to about 50 to 100 nodes (not yet tested).  The node count limitation
    could easily be surpassed by using ZeroMQ to bridge CloudI clusters.
    However, it was anticipated that with multi-core technology
    advancements, the need for very large CloudI clusters would be
    diminished in the immediate future.  The databases that CloudI uses
    are much more likely to need large node counts to facilitate
    large amounts of data which can be accessed as key/value pairs or
    with Map/Reduce.
  </p>
  <div class="top"><a href="#5_contents">Top</a></div>

  <a name="5_Stability"></a>
  <h3>5.3 - Stability and Fault-Tolerance Considerations</h3>
  <p class="paragraph">
    CloudI requests are not sent in a way that is meant to be persistent
    to simplify error-handling.  Otherwise, fault-tolerant messaging would
    preserve requests that are irrelevant and/or erroneous at a future time.
    Instead, CloudI requests can cause a service to crash which means that
    the request is not handled by another service since it is unclear whether
    the request is erroneous or the service is buggy.  CloudI requests also
    have a certain lifetime defined by the request timeout, so that the
    relevance of the request data is limited by the timeout.  The request
    timeout acts to conserve processing time for the most relevant data and
    the services that require the data.  If data needs to be fault-tolerant,
    the data should be stored within a database.
  </p>
  <p class="paragraph">
    Error-handling should always be local (i.e., internal to the service)
    where the errors are most relevant.  Any invalid or corrupt service data
    can terminate the service and will trigger a restart of the service based
    on its configuration parameters.  A service should never be allowed to
    function in a zombie-state since this would only complicate performance,
    testing, debugging and development.
  </p>
  <p class="paragraph">
    The service must exit whenever an unrecoverable error occurs.  If a
    CloudI request causes an exception, the request will fail but the service
    will not be restarted.  So, services should always have proper exception
    handling, to make sure the context of any errors is explicit
    (otherwise, the service source code will become difficult to maintain
    if any CloudI requests fail).  Without service exception handling,
    the exception will cause exception information to be logged, however, the
    information may be minimal (this depends on the limits of the programming
    language used).
  </p>
  <p class="paragraph">
    The non-Erlang CloudI services receive their own Operating System (OS)
    process, so they are well isolated from the Erlang VM's memory.  However,
    Erlang CloudI services could be written with malevolent intentions which
    would make CloudI unstable or erroneous.  This means that Erlang CloudI
    service code must have a greater amount of implicit trust that the
    programmer is not trying to cause problems.  With non-Erlang CloudI
    services there isn't as much concern about whether there are problems
    within the software, since the errors receive isolation within the
    CloudI framework.
  </p>
  <div class="top"><a href="#5_contents">Top</a></div>

  <a name="5_Integration"></a>
  <h3>5.4 - Integration Considerations</h3>
  <p class="paragraph">
    The stdout and stderr of any non-Erlang CloudI service is captured and
    sent separately to be logged by CloudI with the associated Operating System
    (OS) process id.  The CloudI API makes sure that both the stdout and the
    stderr streams are unbuffered within an external CloudI job, so the output
    will be logged as quickly as possible within the CloudI log as error data
    (for stderr data) or as info data (for stdout data).
  </p>
  <div class="top"><a href="#5_contents">Top</a></div>

  <a name="5_LoadTesting"></a>
  <h3>5.5 - Load Testing</h3>
  <p class="paragraph">
    As part of the 1.0.0 CloudI release, the http_req test was used to do a
    load test of CloudI incoming HTTP requests.  The loadtest shows how the
    results vary when interacting with separate programming languages that
    CloudI supports with the CloudI API.  20 thousand concurrent connections
    were used with a dynamic XML request/response protocol.  All external
    services (i.e., non-Erlang services) were only given a single OS process
    with no thread usage.  All programming languages received the same amount
    of load, so it helps provide a comparison for performance within the
    CloudI framework.  To find out more, look at the raw results in
    <a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http_req/loadtest/results/201206_20k/" target="_blank">src/tests/http_req/loadtest/results/201206_20k/</a>
    or the configuration in 
    <a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http_req/loadtest/setup/" target="_blank">src/tests/http_req/loadtest/setup/</a>.
  </p>
  <div class="top"><a href="#5_contents">Top</a></div>

  <hr \>
  <h2>6 - Services</h2>

  <a name="6_C"></a>
  <h3>6.1 - C/C++ Service Implementation</h3>
  <p class="paragraph">
    There are separate header files that provide both a C CloudI API
    (<a href="https://github.com/okeuday/CloudI/blob/master/src/api/c/cloudi.h" target="_blank">cloudi.h</a>)
    and a C++ CloudI API
    (<a href="https://github.com/okeuday/CloudI/blob/master/src/api/c/cloudi.hpp" target="_blank">cloudi.hpp</a>) which are mutually exclusive.  The header
    files do not bring in external dependencies but both require the standard
    C++ library as a link-time dependency.  Some of the integration
    tests that provide example usage of the C/C++ CloudI API are:
    <ul>
      <li><a href="https://github.com/okeuday/CloudI/blob/master/src/tests/hexpi/cxx_src/main.cpp" target="_blank">src/tests/hexpi (C++ example with threads)</a>
          <a href="https://github.com/okeuday/CloudI/blob/master/src/tests/hexpi/" target="_blank">Hexadecimal PI Test</a></li>
      <li><a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http_req/c_src/main.c" target="_blank">src/tests/http_req (C example without threads)</a>
          <a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http_req/" target="_blank">HTTP Request Test</a></li>
    </ul>
  </p>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <a name="6_Erlang"></a>
  <h3>6.2 - Erlang Service Implementation</h3>
  <p class="paragraph">
    Erlang CloudI services use the cloudi_job behavior to create an "internal"
    service (all non-Erlang CloudI services are "external").  The cloudi_job
    behavior requires that the service implement the following functions:
    <ul>
      <li>cloudi_job_init/3</li>
      <li>cloudi_job_handle_request/11</li>
      <li>cloudi_job_handle_info/3</li>
      <li>cloudi_job_terminate/2</li>
    </ul>
  </p>
  <p class="paragraph">
    Many examples of Erlang CloudI services exist within the CloudI source code
    because the Erlang CloudI services provide integration with external
    systems like the supported databases (CouchDB, PostgreSQL, etc.),
    the supported messaging (HTTP, ZeroMQ, etc.), and the Job API
    functionality.  Some example usage of the Erlang CloudI API includes:
    <ul>
      <li><a href="https://github.com/okeuday/CloudI/blob/master/src/lib/cloudi/src/cloudi_job_filesystem.erl" target="_blank">cloudi_job_filesystem Service for Caching Static File Data</a></li>
      <li><a href="https://github.com/okeuday/CloudI/blob/master/src/lib/cloudi/src/cloudi_job_work_manager.erl" target="_blank">cloudi_job_work_manager Service For Caching Database Updates</a></li>
      <li><a href="https://github.com/okeuday/CloudI/blob/master/src/lib/cloudi/src/cloudi_job_timers.erl" target="_blank">cloudi_job_timers service for Sending Service Messages On Timers</a></li>
      <li><a href="https://github.com/okeuday/CloudI/blob/master/src/tests/hexpi/src/cloudi_job_hexpi.erl" target="_blank">Hexadecimal PI Test Load Balancer</a></li>
    </ul>
  </p>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <a name="6_Java"></a>
  <h3>6.3 - Java Service Implementation</h3>
  <p class="paragraph">
    The Java CloudI API uses synchronous IO on file descriptors for
    an efficient light-weight interface.  Some of the integration tests
    that provide example usage of the Java CloudI API include:
    <ul>
      <li><a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http/service/org/cloudi/tests/http/Task.java" target="_blank">src/tests/http</a>
          <a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http/service/org/cloudi/tests/http/" target="_blank">HTTP Test</a></li>
    </ul>
  </p>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <a name="6_Python"></a>
  <h3>6.4 - Python Service Implementation</h3>
  <p class="paragraph">
    The Python CloudI API provides a simple interface for making Python
    CloudI services.  Some of the integration tests that provide example usage
    of the Python CloudI API include:
    <ul>
      <li><a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http/service/service.py" target="_blank">src/tests/http</a>
          <a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http/" target="_blank">HTTP Test</a></li>
      <li><a href="https://github.com/okeuday/CloudI/blob/master/src/tests/zeromq/run.py" target="_blank">src/tests/zeromq</a>
          ZeroMQ Test</li>
    </ul>
    An example configuration (from the <a href="https://github.com/okeuday/CloudI/blob/master/src/cloudi.conf.in" target="_blank">default CloudI configuration</a>)
    is provided below:
    <pre>
{external,
    "/tests/http/",
    "@PYTHON@",
    "tests/http/service/service.py 4 tcp 16384",
    [],
    none, tcp, 16384,
    5000, 5000, 5000, [api], undefined, 1, 4, 5, 300, []}
    </pre>
  </p>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <a name="6_Ruby"></a>
  <h3>6.5 - Ruby Service Implementation</h3>
  <p class="paragraph">
    The Ruby CloudI API provides a simple interface for making Ruby
    CloudI services.  Some of the integration tests that provide example
    usage of the Ruby CloudI API include:
    <ul>
      <li><a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http/service/service.rb" target="_blank">src/tests/http</a>
          <a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http/" target="_blank">HTTP Test</a></li>
    </ul>
  </p>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <a name="6_HTTP"></a>
  <h3>6.6 - HTTP Integration</h3>
  <p class="paragraph">
    HTTP integration with CloudI services uses service names that have a prefix
    that matches the Uniform Resource Locator (URL) path.  A simple example
    caches static filesystem files recursively so that the file path is
    the service name suffix (with the "/get" HTTP method suffix at the end,
    e.g., "index.html/get").  The example can be found in the <a href="https://github.com/okeuday/CloudI/blob/master/src/cloudi.conf.in" target="_blank">default CloudI configuration</a>
    usage of the <a href="https://github.com/okeuday/CloudI/blob/master/src/lib/cloudi/src/cloudi_job_filesystem.erl" target="_blank">cloudi_job_filesystem</a> which is shown below:
    <pre>
{internal,
    "/tests/http_req/",
    cloudi_job_filesystem,
    [{directory, "tests/http_req/public_html/"}],
    none,
    5000, 5000, 5000, [api], undefined, 1, 5, 300, []}
    </pre>
    When CloudI is running with this service configuration, the files
    in the path tests/http_req/public_html/ are browsable at <a href="http://127.0.0.1:6464/tests/http_req/" target="_blank">http://127.0.0.1:6464/tests/http_req/</a>.
  </p>
  <p class="paragraph">
    The incoming HTTP traffic goes through the cloudi_job_http Erlang
    CloudI service and simply uses the URL path to send a request to
    the subscribing CloudI service, where the prefix of the service name
    was set in the service configuration but the suffix of the service name
    was declared programmatically by calling the CloudI API subscribe function.
  </p>
  <p class="paragraph">
    Quicker access to static files can be provided by nginx or other simple HTTP
    servers, so this is just an internal service example of CloudI HTTP
    integration (CloudI is normally for dynamic requests that require
    both scalability and fault-tolerance).
  </p>
  <p class="paragraph">
    Other simple HTTP integration examples can be found among the integration
    tests:
    <ul>
      <li><a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http/" target="_blank">src/tests/http HTTP Test</a>
          (with <a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http/run.sh" target="_blank">curl file-based test requests</a>
           and <a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http/service/service.py" target="_blank">Python</a>/<a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http/service/service.rb" target="_blank">Ruby</a>/<a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http/service/org/cloudi/tests/http/Task.java" target="_blank">Java</a> services)</li>
      <li><a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http_req/" target="_blank">src/tests/http_req HTTP Request Test</a>
          (with a <a href="https://github.com/okeuday/CloudI/blob/master/src/tests/http_req/c_src/main.c" target="_blank">C service</a>)</li>
    </ul>
  </p>
  <p class="paragraph">
    To prevent HTTP requests from going to internal services, Access Control
    List (ACL) entries can be added that prevent the cloudi_job_http Erlang
    CloudI service from sending to the internal services.  The ACL entries
    would be service name prefixes that include the internal services in a
    list that is referenced directly (i.e., literally as a list of string) or
    indirectly by an atom that represents the list of strings.  The ACL
    entries would be specified for the cloudi_job_http service
    configuration's deny list.  If service names are named consistently so that
    the service name represents a path which is a destination in a tree or
    hierarchy, then there should be no problems when adding or removing
    services dynamically (since the ACL entries will remain valid for the
    consistent service name prefix usage).
  </p>
  <p>
    For more information, please refer to <a href="#4_API_HTTP">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <a name="6_ZeroMQ"></a>
  <h3>6.7 - ZeroMQ Integration</h3>
  <p class="paragraph">
    <a href="http://www.zeromq.org/" target="_blank">ZeroMQ</a>
    integration is provided by the cloudi_job_zeromq Erlang CloudI service.
    The CloudI configuration uses the cloudi_job_zeromq service to create
    service names that represent ZeroMQ messaging endpoints.  There are three
    ZeroMQ configuration examples in the <a href="https://github.com/okeuday/CloudI/blob/master/src/cloudi.conf.in" target="_blank">default CloudI configuration</a>
    which are (partially) shown below:
    <pre>
% Zig-Zag test
{internal,
    "/tests/zeromq/",
    % inbound/outbound message paths much be acyclic
    % (if they are not, you will receive a erlzmq EFSM error
    %  because the ZeroMQ REQ has received 2 zmq_send calls)
    cloudi_job_zeromq,
    % outbound ZeroMQ requests connect a CloudI name to a ZeroMQ endpoint
    [{outbound, {"zigzag_start", ["ipc:///tmp/cloudizigzagstart"]}},
    % inbound ZeroMQ replies connect a ZeroMQ endpoint to a CloudI name
     {inbound, {"zigzag_step1", ["ipc:///tmp/cloudizigzagstart"]}},
     {outbound, {"zigzag_step1", ["inproc://zigzagstep1"]}},
     {inbound, {"zigzag_step2", ["inproc://zigzagstep1"]}},
    % ZeroMQ publish connects a CloudI name to a ZeroMQ (subscribe) name
    % as {CloudI name (suffix), ZeroMQ name for message prefix}
    % for any number of endpoints
     {publish, {[{"zigzag_step2", "/zeromq/step2"}],
                ["inproc://zigzagstep2a",
                 "ipc:///tmp/cloudizigzagstep2b",
                 "inproc://zigzagstep2c",
                 "ipc:///tmp/cloudizigzagstep2d"]}},
    % ZeroMQ subscribe connects a CloudI name to a ZeroMQ (subscribe) name
    % as {CloudI name (suffix), ZeroMQ name for subscribe setsocketopt}
    % for any number of endpoints
     {subscribe, {[{"zigzag_step3a", "/zeromq/step2"},
                   {"zigzag_step3b", "/zeromq/step2"}],
                  ["inproc://zigzagstep2a",
                   "ipc:///tmp/cloudizigzagstep2b",
                   "inproc://zigzagstep2c",
                   "ipc:///tmp/cloudizigzagstep2d"]}},
     {outbound, {"zigzag_step3a", ["inproc://zigzagstep3"]}},
     {inbound, {"zigzag_finish", ["inproc://zigzagstep3"]}}],
    immediate_closest,
    5000, 5000, 5000, [api], undefined, 2, 5, 300, []},
% Chain inproc test (50 endpoints in a sequential call path)
{internal,
    "/tests/zeromq/",
    cloudi_job_zeromq,
    [{outbound, {"chain_inproc_start", ["inproc://chainstep1"]}},
     {inbound, {"chain_inproc_step1", ["inproc://chainstep1"]}},
     {outbound, {"chain_inproc_step1", ["inproc://chainstep2"]}},
     {inbound, {"chain_inproc_step2", ["inproc://chainstep2"]}},
...
     {outbound, {"chain_inproc_step48", ["inproc://chainstep49"]}},
     {inbound, {"chain_inproc_step49", ["inproc://chainstep49"]}},
     {outbound, {"chain_inproc_step49", ["inproc://chainstep50"]}},
     {inbound, {"chain_inproc_finish", ["inproc://chainstep50"]}}],
    immediate_closest,
    5000, 5000, 5000, [api], undefined, 2, 5, 300, []},
% Chain ipc test (25 endpoints in a sequential call path)
{internal,
    "/tests/zeromq/",
    cloudi_job_zeromq,
    [{outbound, {"chain_ipc_start", ["ipc:///tmp/cloudichainstep1"]}},
     {inbound, {"chain_ipc_step1", ["ipc:///tmp/cloudichainstep1"]}},
     {outbound, {"chain_ipc_step1", ["ipc:///tmp/cloudichainstep2"]}},
     {inbound, {"chain_ipc_step2", ["ipc:///tmp/cloudichainstep2"]}},
...
     {outbound, {"chain_ipc_step23", ["ipc:///tmp/cloudichainstep24"]}},
     {inbound, {"chain_ipc_step24", ["ipc:///tmp/cloudichainstep24"]}},
     {outbound, {"chain_ipc_step24", ["ipc:///tmp/cloudichainstep25"]}},
     {inbound, {"chain_ipc_finish", ["ipc:///tmp/cloudichainstep25"]}}],
    immediate_closest,
    5000, 5000, 5000, [api], undefined, 2, 5, 300, []}
    </pre>
  </p>
  <p class="paragraph">
  The three cloudi_job_zeromq Erlang CloudI services are used by the
  <a href="https://github.com/okeuday/CloudI/blob/master/src/tests/zeromq/run.py" target="_blank">ZeroMQ integration test</a>
  to test the ZeroMQ messaging when the integration test service starts.
  ZeroMQ configuration within CloudI is dynamic through usage of the Job
  API.  For more information, please refer to <a href="#4_API_ZeroMQ">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <hr \>
  <h2>7 - Databases</h2>

  <a name="7_CouchDB"></a>
  <h3>7.1 - CouchDB Integration</h3>
  <p class="paragraph">
    The cloudi_job_db_couchdb internal service accepts requests from other
    CloudI services.  The service expects database commands supplied as
    Erlang tuples or atoms.  When the service receives data from an external
    service the data received is binary and should be a string that contains
    Erlang terms that is the database command.  The command result is
    returned as binary to an external service.  An internal service can
    send the command as Erlang terms and will receive Erlang terms for the
    result.  The service name used to communicate with the database is the
    configured database service name prefix with the database name appended
    (i.e., "/db/couchdb/cloudi_tests" in the example below).
  </p>
  <p class="paragraph">
    An example configuration for a single database that is represented as a
    single service is below:
<pre>
    {internal,
        "/db/couchdb/",
        cloudi_job_db_couchdb,
        [{database, "cloudi_tests"},
         {timeout, 20000}, % ms
         {hostname, "127.0.0.1"},
         {port, 5984}],
        none,
        5000, 5000, 5000, undefined, undefined, 1, 5, 300, []}
</pre>
  </p>
  <div class="top"><a href="#7_contents">Top</a></div>

  <a name="7_memcached"></a>
  <h3>7.2 - memcached Integration</h3>
  <p class="paragraph">
    The cloudi_job_db_memcached internal service accepts requests from other
    CloudI services.  The service expects database commands supplied as
    Erlang tuples or atoms.  When the service receives data from an external
    service the data received is binary and should be a string that contains
    Erlang terms that is the database command.  The command result is
    returned as binary to an external service.  An internal service can
    send the command as Erlang terms and will receive Erlang terms for the
    result.  The service name used to communicate with the database is the
    configured database service name prefix with the database name appended
    (i.e., "/db/memcached/cloudi_tests" in the example below).
  </p>
  <p class="paragraph">
    An example configuration for a single database that is represented as a
    single service is below:
<pre>
    {internal,
        "/db/memcached/",
        cloudi_job_db_memcached,
        [{database, "cloudi_tests",
          [{"127.0.0.1", 11211, 1}]}],
        none,
        5000, 5000, 5000, undefined, undefined, 1, 5, 300, []}
</pre>
    The list of host-port-connection_count tuples is used for providing
    <a href="http://amarok.kde.org/blog/archives/363-libketama-a-consistent-hashing-algo-for-memcache-clients.html" target="_blank">continuum hashing</a>
    of database keys.  Using continuum hashing avoids rehashing all the keys
    (i.e., cached-misses) when a memcached node fails.
  </p>
  <div class="top"><a href="#7_contents">Top</a></div>

  <a name="7_PostgreSQL"></a>
  <h3>7.3 - PostgreSQL Integration</h3>
  <p class="paragraph">
    The cloudi_job_db_pgsql internal service accepts requests from other
    CloudI services.  The service expects SQL input and provides the query
    result either as an Erlang tuple or as binary encoded data based on whether
    the input was binary or a list.  All data coming from external services
    is received as binary and is returned as binary that can be used to
    determine the result of a query.  Internal services are able to send SQL
    as an Erlang list and will then receive a tuple from the database driver
    that is the result of the query.  The service name used to communicate
    with the database is the configured database service name prefix with
    the database name appended (i.e., "/db/pgsql/cloudi_tests" in the example
    below).
  </p>
  <p class="paragraph">
    An example configuration for a single database that is represented as a
    single service is below:
<pre>
    {internal,
        "/db/pgsql/",
        cloudi_job_db_pgsql,
        [{database, "cloudi_tests"},
         {timeout, 20000}, % ms
         {hostname, "127.0.0.1"},
         {username, "cloudi"},
         {password, "XXXXXXXXX"},
         {port, 5432}],
        none,
        5000, 5000, 5000, undefined, undefined, 1, 5, 300, []}
</pre>
  </p>
  <div class="top"><a href="#7_contents">Top</a></div>

  <a name="7_MySQL"></a>
  <h3>7.4 - MySQL Integration</h3>
  <p class="paragraph">
    The cloudi_job_db_mysql internal service accepts requests from other
    CloudI services.  The service expects SQL input and provides the query
    result either as an Erlang tuple or as binary encoded data based on whether
    the input was binary or a list.  All data coming from external services
    is received as binary and is returned as binary that can be used to
    determine the result of a query.  Internal services are able to send SQL
    as an Erlang list and will then receive a tuple from the database driver
    that is the result of the query.  The service name used to communicate
    with the database is the configured database service name prefix with
    the database name appended (i.e., "/db/mysql/cloudi_tests" in the example
    below).
  </p>
  <p class="paragraph">
    An example configuration for a single database that is represented as a
    single service is below:
<pre>
    {internal,
        "/db/mysql/",
        cloudi_job_db_mysql,
        [{database, "cloudi_tests"},
         {timeout, 20000}, % ms
         {encoding, utf8},
         {hostname, "127.0.0.1"},
         {username, "cloudi"},
         {password, "XXXXXXXXX"},
         {port, 3306}],
        none,
        5000, 5000, 5000, undefined, undefined, 1, 5, 300, []}
</pre>
  </p>
  <div class="top"><a href="#7_contents">Top</a></div>

  <a name="7_TokyoTyrant"></a>
  <h3>7.5 - Tokyo Tyrant Integration</h3>
  <p class="paragraph">
    The cloudi_job_db_tokyotyrant internal service accepts requests from other
    CloudI services.  The service expects database commands supplied as
    Erlang tuples or atoms.  When the service receives data from an external
    service the data received is binary and should be a string that contains
    Erlang terms that is the database command.  The command result is
    returned as binary to an external service.  An internal service can
    send the command as Erlang terms and will receive Erlang terms for the
    result.  The service name used to communicate with the database is the
    configured database service name prefix with the database name appended
    (i.e., "/db/tokyotyrant/cloudi_tests" in the example below).
  </p>
  <p class="paragraph">
    An example configuration for a single database that is represented as a
    single service is below:
<pre>
    {internal,
        "/db/tokyotyrant/",
        cloudi_job_db_tokyotyrant,
        [{database, "cloudi_tests"},
         {timeout, 20000}, % ms
         {hostname, "127.0.0.1"},
         {port, 1978}],
        none,
        5000, 5000, 5000, undefined, undefined, 1, 5, 300, []}
</pre>
  </p>
  <div class="top"><a href="#7_contents">Top</a></div>

  <a name="7_Other"></a>
  <h3>7.6 - Other Database Integration</h3>
  <p class="paragraph">
    Other databases can easily be integrated with CloudI.  The best database
    integration uses a database driver implemented completely in Erlang and
    uses a cloudi_job_db_name module to implement CloudI service integration
    with the cloudi_job behavior.  By using a database driver written in Erlang
    the source code is naturally more scalable and fault-tolerant.  If the
    database driver used an Erlang NIF or an Erlang port driver instead,
    the driver would not be isolated from the Erlang VM (though the
    implementation might be more efficient).  The database driver would
    typically communicate with the database by using a socket with TCP.
  </p>
  <p class="paragraph">
    Database integration can be done in other complex ways if required,
    but the integration approach previously mentioned is a typical approach
    used within the CloudI framework.
  </p>
  <div class="top"><a href="#7_contents">Top</a></div>

</div>

<div id="footer">
Copyright &#169; 2009-2012 Michael Truog
</div>

</body>
</html>
