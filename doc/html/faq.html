<html>
<head>
  <title>CloudI: A Cloud at the lowest level - Frequently Asked Questions</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta content="Cloud Framework for fault-tolerant distributed processing with dynamic load balancing" name="description" />
  <meta content="faq, cloud, private cloud, framework, erlang, c++, distributed, fault tolerant, distributed systems, fault-tolerant, embarrassingly parallel, divide and conquer, work pool, cloudi" name="keywords" />
  <meta content="global" name="distribution" />
  <meta content="This document copyright 2009-2013 by Michael Truog" name="copyright" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <link rel="stylesheet" type="text/css" title="print"
        href="print.css" />
  <meta http-equiv="Default-Style" content="print" />
  <link rel="shortcut icon" href="images/cloud.ico" type="image/x-icon" />
</head>
<body>

<div id="header">
<a href="http://cloudi.org/">
Cloud<font style="font-family: serif">I</font><img width=156 height=106 src="images/cloud.png" />
</a>
</div>
<br />
<div id="navigation">
  <ul>
    <li><a href="index.html">QUICKSTART</a></li>
    <li><a href="api.html">API</a></li>
    <li><a href="faq.html" class="active">FAQ</a></li>
    <li><a href="http://sourceforge.net/projects/cloudi/files/latest/download" target="_blank">Download</a></li>
    <li><a href="https://github.com/CloudI/CloudI/tree/master#readme">Source</a></li>
  </ul>
</div>

<div id="content">
  <h1>Frequently Asked Questions</h1>
  <center><h3>version 1.3.1b<br />
              last updated on February 1<sup>st</sup> 2014</h3></center>

  <a name="1_contents"></a>
  <h2>1 - Introduction to CloudI</h2>
  <ul class="faq">
    <li><a href="#1_Name"         >1.1 - Why is it named "Cloud<font style="font-family: serif">I</font>"?</a></li>
    <li><a href="#1_Pronounce"    >1.2 - How is CloudI pronounced?</a></li>
    <li><a href="#1_Clouds"       >1.3 - How does CloudI compare to other "Clouds"?</a></li>
    <li><a href="#1_WhatIs"       >1.4 - What is CloudI?</a></li>
    <li><a href="#1_OS"           >1.5 - On what Operating Systems does CloudI run?</a></li>
    <li><a href="#1_Commercial"   >1.6 - Is Commercial support available for CloudI?</a></li>
    <li><a href="#1_ReallyFree"   >1.7 - Is CloudI really free?</a></li>
    <li><a href="#1_WhoDevelops"  >1.8 - Who develops CloudI?</a></li>
    <li><a href="#1_PrivateCloud" >1.9 - Can I use CloudI as a Private Cloud?</a></li>
    <li><a href="#1_OnlineService">1.10 - Can I use CloudI as an Online Service?</a></li>
    <li><a href="#1_CAP"          >1.11 - What CAP theorem guarantees does CloudI provide?</a></li>
    <li><a href="#1_REST"         >1.12 - Does CloudI support REST?</a></li>
    <li><a href="#1_HowAbout"     >1.13 - Why doesn't CloudI integrate with ProductX?</a></li>
  </ul>
  <a name="2_contents"></a>
  <h2>2 - Learning about CloudI</h2>
  <ul class="faq">
    <li><a href="#2_WebPages"      >2.1 - Web Pages</a></li>
    <li><a href="#2_MailingList"   >2.2 - Mailing List</a></li>
    <li><a href="#2_IRC"           >2.3 - Internet Relay Chat (IRC)</a></li>
    <li><a href="#2_RSS"           >2.4 - RSS Feeds</a></li>
    <li><a href="#2_Twitter"       >2.5 - Twitter</a></li>
    <li><a href="#2_Presentations" >2.6 - Presentations</a></li>
    <li><a href="#2_Articles"      >2.7 - Articles</a></li>
    <li><a href="#2_Reporting Bugs">2.8 - Reporting Bugs</a></li>
  </ul>
  <a name="3_contents"></a>
  <h2>3 - CloudI Installation Guide</h2>
  <ul class="faq">
    <li><a href="#3_Overview"    >3.1 - Overview</a></li>
    <li><a href="#3_Options"     >3.2 - Installation Options</a></li>
    <li><a href="#3_OSX"         >3.3 - OS X Installation</a></li>
    <li><a href="#3_Running"     >3.4 - Running CloudI</a></li>
    <li><a href="#3_Config"      >3.5 - Configuration</a></li>
  </ul>
  <a name="4_contents"></a>
  <h2>4 - General Questions</h2>
  <ul class="faq">
    <li><a href="#4_API"        >4.1 - How do I integrate external software with CloudI?</a></li>
    <li><a href="#4_ServiceAPI" >4.2 - How do I control CloudI dynamically?</a></li>
    <li><a href="#4_PubSub"     >4.3 - How do I use Publisher/Subscriber messaging?</a></li>
    <li><a href="#4_RPC"        >4.4 - How do I use Remote Procedure Calls (RPC)?</a></li>
    <li><a href="#4_WebServices">4.5 - How do I create Web Services?</a></li>
    <li><a href="#4_WebSockets" >4.6 - Does CloudI support WebSockets?</a></li>
    <li><a href="#4_ACLs"       >4.7 - How do I use Access Control Lists (ACLs)?</a></li>
    <li><a href="#4_ServiceFail">4.8 - How do I Migrate a Service from a Failed or Failing Node?</a></li>
    <li><a href="#4_URLregex"   >4.9 - Can I use Regular Expressions with Service Names (URLs)?</a></li>
    <li><a href="#4_NamePattern">4.10 - How do Service Name Patterns work?</a></li>
    <li><a href="#4_ThreadSafe" >4.11 - Is the CloudI API thread-safe?</a></li>
    <li><a href="#4_Speed"      >4.12 - How can CloudI requests take advantage of cache coherency, minimum network latency, and any logical grouping?</a></li>
    <li><a href="#4_Erlang"     >4.13 - Why not just use Erlang directly?</a></li>
  </ul>
  <a name="5_contents"></a>
  <h2>5 - Migrating to CloudI</h2>
  <ul class="faq">
    <li><a href="#5_Performance">5.1 - Performance Considerations</a></li>
    <li><a href="#5_Scalability">5.2 - Scalability Considerations</a></li>
    <li><a href="#5_Stability"  >5.3 - Stability and Fault-Tolerance Considerations</a></li>
    <li><a href="#5_Integration">5.4 - Integration Considerations</a></li>
    <li><a href="#5_LoadTesting">5.5 - Load Testing</a></li>
  </ul>
  <a name="6_contents"></a>
  <h2>6 - Services</h2>
  <ul class="faq">
    <li><a href="#6_C"       >6.1 - C++/C Service Implementation</a></li>
    <li><a href="#6_Erlang"  >6.2 - Erlang Service Implementation</a></li>
    <li><a href="#6_Java"    >6.3 - Java Service Implementation</a></li>
    <li><a href="#6_Python"  >6.4 - Python Service Implementation</a></li>
    <li><a href="#6_Ruby"    >6.5 - Ruby Service Implementation</a></li>
    <li><a href="#6_HTTP"    >6.6 - HTTP Integration</a></li>
    <li><a href="#6_ZeroMQ"  >6.7 - ZeroMQ Integration</a></li>
    <li><a href="#6_FaultTolerance">6.8 - Service Fault-Tolerance</a></li>
  </ul>
  <a name="7_contents"></a>
  <h2>7 - Databases</h2>
  <ul class="faq">
    <li><a href="#7_CouchDB"    >7.1 - CouchDB Integration</a></li>
    <li><a href="#7_memcached"  >7.2 - memcached Integration</a></li>
    <li><a href="#7_MySQL"      >7.3 - MySQL Integration</a></li>
    <li><a href="#7_PostgreSQL" >7.4 - PostgreSQL Integration</a></li>
    <li><a href="#7_TokyoTyrant">7.5 - Tokyo Tyrant Integration</a></li>
    <li><a href="#7_Other"      >7.6 - Other Database Integration</a></li>
  </ul>

  <hr \>
  <h2>1 - Introduction to CloudI</h2>

  <a name="1_Name"></a>
  <h3>1.1 - Why is it named "Cloud<font style="font-family: serif">I</font>"?</h3>
  <p class="paragraph">
    A <strong>Cloud</strong> is more dynamic than a 3 dimensional
    <strong>Grid</strong> and is more ubiquitous than the legend of 
    <strong>Beowulf</strong>, so it is easy to understand why computing Clouds 
    are the next generation distributed systems.  The relevant connotations the 
    word Cloud contains are: dynamic, supervision, intermingle, and points 
    (i.e., point clouds).  Any computing Cloud should offer dynamic
    configuration, should supervise processes in a fault-tolerant way,
    offer easy integration and should support an arbitrarily large number
    of processes (respectively).  This project offers Cloud functionality
    facilitated by the <a href="http://en.wikipedia.org/wiki/Erlang_%28programming_language%29" target="_blank">Erlang programming language</a>
    and its implementation of the <a href="http://en.wikipedia.org/wiki/Actor_model" target="_blank">Actor Model</a>.
  </p>
  <p class="paragraph">
    CloudI has an "<font style="font-family: serif">I</font>" suffix for
    several connotations: cloudy, one, singularity, interface, and
    independence.  CloudI is referred to as "A Cloud as an Interface" because
    a light-weight interface facilitates Cloud functionality.
    The interface supports multiple programming languages and is called the
    <a href="api.html#Service" target="_blank">CloudI API</a>.
    CloudI supports private cloud development and deployment,
    so only one Cloud is necessary for Cloud functionality with implicit
    security.  CloudI is also able to facilitate online services and offers
    extreme connection scalability.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_Pronounce"></a>
  <h3>1.2 - How is CloudI pronounced?</h3>
  <p class="paragraph">
    As "cloud-e" /kla&#650;di/ (think: Cloud <a href="http://en.wikipedia.org/wiki/Erlang_%28programming_language%29" target="_blank">Erlang</a>).
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_Clouds"></a>
  <h3>1.3 - How does CloudI compare to other "Clouds"?</h3>
  <p class="block">
    Currently, "Clouds" generally fall into two categories:
    <table><tr><td>
    &#149;</td><td>Infrastructure as a Service (IaaS)
    </td><td>- Hypervisor "Clouds"
    </td></tr><tr><td>
    &#149;</td><td>Platform as a Service (PaaS)
    </td><td>- Integration "Clouds"
    </td></tr></table>
  </p>
  <h4>Hypervisor "Clouds"</h4>
  <p class="paragraph">
    Hypervisor "Clouds" are the most popular type of Cloud because of the
    amount of revenue they can generate as a service.
    Popular examples include:
    <a href="http://en.wikipedia.org/wiki/Amazon_EC2" target="_blank">Amazon Web Services (AWS)</a>,
    <a href="http://en.wikipedia.org/wiki/OpenStack" target="_blank">OpenStack</a>,
    <a href="http://en.wikipedia.org/wiki/Cloud.com" target="_blank">CloudStack</a>,
    <a href="http://en.wikipedia.org/wiki/Eucalyptus_%28computing%29" target="_blank">Eucalyptus</a>,
    <a href="http://en.wikipedia.org/wiki/OpenNebula" target="_blank">OpenNebula</a>,
    and
    <a href="http://en.wikipedia.org/wiki/Nimbus_%28cloud_computing%29" target="_blank">Nimbus</a>.  The <a href="http://en.wikipedia.org/wiki/Hypervisors" target="_blank">Hypervisor</a>
    has existed since 1965 when software was used on the IBM 360/65 to
    emulate an IBM 7080 with computation time split between the separate modes.
    Modern Hypervisors provide Operating System virtualization to provide
    better security and reliability.  There is meant to be minimal software
    development effort when utilizing a virtualized Operating System, so
    it is an obvious choice for source code that is not actively developed
    (<a href="http://en.wikipedia.org/wiki/Legacy_software" target="_blank">legacy software</a>)
    and lacks reliability/scalability.  Part of the reason Hypervisors
    have not been popular in the past is because virtualization increases
    the hardware requirements for the same amount of processing.  Hardware
    has advanced enough that many software applications are unable to fully
    utilize the hardware capacity that has become commonplace.  For software
    that is often idle, Hypervisors can provide cost savings on both
    hardware and power without software modifications.
  </p>
  <h4>Integration "Clouds"</h4>
  <p class="paragraph">
    Integration "Clouds" provide software developers with a platform for
    simpler integration development.
    Popular examples include:
    <a href="http://en.wikipedia.org/wiki/AppScale" target="_blank">AppScale</a>,
    <a href="http://en.wikipedia.org/wiki/Cloud_Foundry" target="_blank">CloudFoundry</a>,
    <a href="http://en.wikipedia.org/wiki/OpenShift" target="_blank">OpenShift</a>,
    and
    <a href="http://en.wikipedia.org/wiki/Heroku" target="_blank">Heroku</a>.
    Generally, Integration "Clouds" provide software packages for common
    scripting language deployment scenarios (typically Javascript, Ruby or
    Python web frameworks).  Integration "Clouds" (PaaS) normally do not
    provide fault-tolerance or reliability, so they are typically deployed
    with a Hypervisor.
  </p>
  <p class="paragraph">
    CloudI is an Integration Cloud that focuses on flexible integration
    that is efficient, scalable, and fault-tolerant.  CloudI does not
    force a user to use particular software libraries but instead provides
    light-weight interfaces for integration.  Scalability and fault-tolerance
    are both provided by CloudI's usage of the 
    <a href="http://en.wikipedia.org/wiki/Erlang_%28programming_language%29" target="_blank">Erlang programming language</a>.
    This means that no Hypervisor or commercial service is necessary to make
    CloudI's processes reliable, so there can be a performance benefit when
    using CloudI.  Scalability is a natural gain with CloudI's Erlang
    concurrency which reduces the amount of power and hardware necessary to
    facilitate external connections, making CloudI a greener solution!
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_WhatIs"></a>
  <h3>1.4 - What is CloudI?</h3>
  <h4>Short Answer</h4>
  <p class="paragraph">
    An application server that efficiently integrates with many languages,
    many databases, and many messaging buses in a way that is both scalable
    and fault-tolerant.
  </p>
  <h4>Shorter Answer</h4>
  <p class="paragraph">
    A rock-solid transaction processing system for
    flexible software development.
  </p>
  <h4>Shortest Answer</h4>
  <p class="paragraph">
    A Cloud at the lowest level.
  </p>
  <h4>Long Answer</h4>
  <p class="paragraph">
    CloudI is an implementation of <a href="#1_Name">Cloud functionality</a>
    that can be developed and deployed publicly or privately.  CloudI provides
    a simple server back-end that can be used for infrastructure development
    of data processing systems, event processing systems, web services, and
    combinations thereof.  CloudI is a system that enforces <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">RESTful development practices</a>
    and provides a <a href="http://en.wikipedia.org/wiki/Service_oriented_architecture" target="_blank">Service Oriented Architecture (SOA)</a>.
    CloudI services communicate with messaging that can be controlled by simple
    Access Control List (ACL) entries (to provide service communication
    isolation).
  </p>
  <p class="paragraph">
    CloudI was architected to easily integrate with other services, software,
    and frameworks.  The <a href="api.html#Service">CloudI API</a>
    provides a light-weight interface for
    creating services in C++/C, Erlang, Java, Python, and Ruby.  By using
    CloudI, external software can become more scalable and fault-tolerant
    by utilizing CloudI's load balancing of CloudI requests.  CloudI
    messaging enforces realtime constraints using timeouts, so that request
    failures can be handled locally within the service where they are most
    relevant.  ACL entries explicitly allow or deny communication between
    services and are a simple method of isolating critical services from
    potentially volatile services.  All CloudI API usage in languages other
    than Erlang receive the isolation of Operating System processes
    and are called external services.  External services can utilize the
    CloudI API with any threading library to achieve greater scalability and
    reduce internal latency.  The Erlang CloudI API is used to create
    internal services which utilize light-weight Erlang processes.
    <a href="#6_contents">Examples of using the CloudI API</a>
    are provided as integration tests or internal services.
  </p>
  <p class="paragraph">
    The <a href="api.html#CloudI">CloudI Service API</a>
    provides dynamic configuration which is accessible from any
    allowed CloudI service (i.e., allowed based on the ACL entries).  The
    CloudI Service API is accessible remotely by using Erlang terms or JSON-RPC
    over HTTP when using the cloudi_service_api_requests service with the
    cloudi_service_http_cowboy service.
    <a href="https://github.com/CloudI/CloudI/tree/master/src/service_api#readme" target="_blank">Examples of using the CloudI Service API</a>
    are provided as separate integration tests.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_OS"></a>
  <h3>1.5 - On what Operating Systems does CloudI run?</h3>
  <p class="paragraph">
    CloudI runs on UNIX-based operating systems like Linux (<a href="http://www.ubuntu.com/" target="_blank">Ubuntu</a>, etc.)
    and BSDs (<a href="http://www.freebsd.org/" target="_blank">FreeBSD</a>, <a href="http://www.openbsd.org/" target="_blank">OpenBSD</a>, <a href="http://www.netbsd.org/" target="_blank">NetBSD</a>, <a href="http://www.apple.com/macosx/" target="_blank">OSX</a>, etc.).
    CloudI development has primarily taken place on Ubuntu and other
    Operating Systems may not be completely tested yet.  Windows may work
    by using <a href="http://www.cygwin.com/" target="_blank">Cygwin</a>
    for dependencies.
  </p>
  <p class="paragraph">
    <a href="http://www.erlang.org/doc/installation_guide/INSTALL.html" target="_blank">Erlang</a>
    must be able to run on the system for CloudI to function properly.
    So, checking Erlang support would be a good place to start if you are
    experimenting with a different Operating System.  The information here
    will be updated as more Operating Systems are tested.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_Commercial"></a>
  <h3>1.6 - Is Commercial support available for CloudI?</h3>
  <p>
    <ul>
      <li>Integration Development</li>
      <li>Operations Maintenance</li>
    </ul>
    Contact <a href="mailto:mjtruog@gmail.com">Michael Truog</a>
    if you are interested in commercial CloudI support.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_ReallyFree"></a>
  <h3>1.7 - Is CloudI really free?</h3>
  <p class="paragraph">
    CloudI is completely free.  CloudI uses a <a href="LICENSE.txt" target="_blank">BSD license</a>
    which permits reuse for personal or commercial purposes.  Small amounts of
    source code is included that is under the <a href="http://www.erlang.org/EPLICENSE" target="_blank">Erlang Public License</a>
    (e.g., part of the <a href="https://github.com/CloudI/CloudI/tree/master/src/api/java/com" target="_blank">Java CloudI API</a> and <a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cpg/src/cpg.erl" target="_blank">cpg.erl</a>) like <a href="http://www.erlang.org/" target="_blank">Erlang</a>
    itself.  All external source code dependencies are also under a
    BSD license.  Some conditional external source code dependencies
    (not included by default) are under other licenses
    (e.g., <a href="http://www.zeromq.org/" target="_blank">ZeroMQ</a>
    is under the LGPL license).  For a more detailed look at the
    licenses of external dependencies, please check the <a href="https://github.com/CloudI/CloudI/blob/master/src/external/README.markdown#readme" target="_blank">src/external/README</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_WhoDevelops"></a>
  <h3>1.8 - Who develops CloudI?</h3>
  <p class="paragraph">
    <a href="mailto:mjtruog@gmail.com">Michael Truog</a>
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_PrivateCloud" ></a>
  <h3>1.9 - Can I use CloudI as a Private Cloud?</h3>
  <p class="paragraph">
    Yes!  CloudI provides everything for running a Cloud in isolation
    (i.e., without a connection to the Internet).  For more details,
    please refer to <a href="#1_WhatIs">"1.4 - What is CloudI?"</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_OnlineService"></a>
  <h3>1.10 - Can I use CloudI as an Online Service?</h3>
  <p class="paragraph">
    Yes!  CloudI accepts incoming HTTP traffic and can be easily extended
    to handle other incoming protocols.  For more details,
    please refer to <a href="#1_WhatIs">"1.4 - What is CloudI?"</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_CAP"></a>
  <h3>1.11 - What CAP theorem guarantees does CloudI provide?</h3>
  <p class="paragraph">
    CloudI is an <a href="http://en.wikipedia.org/wiki/CAP_theorem" target="_blank">AP-type distributed system</a>
    (guarantees of Availability and Partition tolerance). A Consistency
    guarantee (the guarantee not provided by CloudI) can be provided by
    either a CloudI service interface to a database driver or a
    CloudI service interface to a messaging bus (i.e., to a persistent
    message queue).  In both cases, a request can be sent to the CloudI
    service with the <a href="api.html#Service">CloudI API</a>
    (if a response is returned, the request succeeded).
    To understand consistency, as it relates to CloudI service
    fault-tolerance, please refer to <a href="#6_FaultTolerance">"6.8 - Service Fault-Tolerance"</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_REST"></a>
  <h3>1.12 - Does CloudI support REST?</h3>
  <p class="paragraph">
    Yes!  CloudI is a system that enforces <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">RESTful development practices</a>.
    For more details please refer to <a href="#1_WhatIs">"1.4 - What is CloudI?"</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <a name="1_HowAbout"></a>
  <h3>1.13 - Why doesn't CloudI integrate with ProductX?</h3>
  <p class="paragraph">
    There are many possibilities for CloudI integration.  If you know of a
    public product that you think should be integrated or if you need
    commercial support for a private product, contact
    <a href="mailto:mjtruog@gmail.com">Michael Truog</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <hr \>
  <h2>2 - Learning about CloudI</h2>

  <a name="2_WebPages"></a>
  <h3>2.1 - Web Pages</h3>
  <table><tr><td>
  Main Web Site:
  </td><td>
  <a href="http://cloudi.org">http://cloudi.org</a>
  </td></tr><tr><td>
  Source Code:
  </td><td>
  <a href="https://github.com/CloudI/CloudI#readme" target="_blank">https://github.com/CloudI/CloudI</a>
  </td></tr><tr><td>
  Releases:
  </td><td>
  <a href="http://sourceforge.net/projects/cloudi/files/" target="_blank">http://sourceforge.net/projects/cloudi/files/</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <a name="2_MailingList"></a>
  <h3>2.2 - Mailing List</h3>
  <table><tr><td>
  Email Address:
  </td><td>
  <a href="mailto:cloudi-questions@googlegroups.com" target="_blank">cloudi-questions@googlegroups.com</a>
  </td></tr><tr><td>
  Subscribe:
  </td><td>
  <a href="http://groups.google.com/group/cloudi-questions/subscribe" target="_blank">http://groups.google.com/group/cloudi-questions/subscribe</a>
  </td></tr><tr><td>
  Archive:
  </td><td>
  <a href="http://groups.google.com/group/cloudi-questions" target="_blank">http://groups.google.com/group/cloudi-questions</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <a name="2_IRC"></a>
  <h3>2.3 - Internet Relay Chat (IRC)</h3>
  <table><tr><td>
  IRC Server:
  </td><td>
  <a href="http://freenode.net/irc_servers.shtml" target="_blank">irc.freenode.net</a>
  </td></tr><tr><td>
  Chat Room:
  </td><td>
  <a href="http://webchat.freenode.net?randomnick=1&channels=cloudi" target="_blank">#cloudi (#erlang can offer additional help, if necessary)</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <a name="2_RSS"></a>
  <h3>2.4 - RSS Feeds</h3>
  <table><tr><td>
  Development:
  </td><td>
  <a href="https://github.com/CloudI/CloudI/commits/develop.atom" target="_blank">https://github.com/CloudI/CloudI/commits/develop.atom</a>
  </td></tr><tr><td>
  Releases:
  </td><td>
  <a href="http://sourceforge.net/api/file/index/project-id/281423/mtime/desc/limit/20/rss" target="_blank">http://sourceforge.net/api/file/index/project-id/281423/mtime/desc/limit/20/rss</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <a name="2_Twitter"></a>
  <h3>2.5 - Twitter</h3>
  <table><tr><td>
  Development:
  </td><td>
  <a href="https://twitter.com/cloudi_org" target="_blank">@cloudi_org</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <a name="2_Presentations"></a>
  <h3>2.6 - Presentations</h3>
  <table><tr><td>
  Version 1.2.5
  </td><td>
  <a href="docs/cloudi_hackntell_seattle2013.pdf" target="_blank">2013 Hack and Tell Seattle (slides)</a>
  </td></tr><tr><td>
  Version 1.0.0
  </td><td>
  2012 Open Source Bridge Unconference
  </td></tr><tr><td>
  Version 0.1.6
  </td><td>
  <a href="docs/cloudi_erlounge_vancouver2011.pdf" target="_blank">2011 ErLounge Meetup Vancouver BC (slides)</a>
  </td></tr><tr><td>
  Version 0.1.5
  </td><td>
  <a href="docs/cloudi_erlounge_sfbay2011.pdf" target="_blank">2011 ErLounge Meetup SF Bay Area (slides)</a>
  </td></tr><tr><td>
  Version 0.0.9
  </td><td>
  <a href="docs/cloudi_ef_sfbay2010.pdf" target="_blank">2010 Erlang Factory SF Bay Area (slides)</a> <a href="docs/cloudi_ef_sfbay2010.txt" target="_blank">(demo text)</a>
  </td></tr><tr><td>
  Version 0.0.8
  </td><td>
  <a href="http://vimeo.com/8192137" target="_blank">2009 Erlang User Conference (video)</a> <a href="docs/cloudi_euc2009.pdf" target="_blank">(slides)</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <a name="2_Articles"></a>
  <h3>2.7 - Articles</h3>
  <table><tr><td>
  <a href="http://www.toptal.com/erlang/a-cloud-at-the-lowest-level-built-in-erlang" target="_blank">Bringing Erlang's Fault-Tolerance to Polyglot Development</a>
  </td><td>
  @Toptal Engineering Blog
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <a name="2_Reporting Bugs"></a>
  <h3>2.8 - Reporting Bugs</h3>
  <table><tr><td>
  Bug Reports:
  </td><td>
  <a href="https://github.com/CloudI/CloudI/issues/new" target="_blank">https://github.com/CloudI/CloudI/issues/new</a>
  </td></tr><tr><td>
  <a href="#2_MailingList">Mailing List:</a>
  </td><td>
  <a href="mailto:cloudi-questions@googlegroups.com" target="_blank">cloudi-questions@googlegroups.com</a>
  </td></tr></table>
  <p class="paragraph">
    If you are unsure whether you have found a bug, please send an email to the
    mailing list or utilize the <a href="http://webchat.freenode.net?randomnick=1&channels=cloudi" target="_blank">IRC chat room</a>.
    Otherwise, you can easily enter a bug report for the problem by using the
    <a href="https://github.com/CloudI/CloudI/issues/new" target="_blank">online form</a>.
  </p>
  <div class="top"><a href="#2_contents">Top</a></div>

  <hr \>
  <h2>3 - CloudI Installation Guide</h2>

  <a name="3_Overview"></a>
  <h3>3.1 - Overview</h3>
  <p>
    Installation of CloudI from source (within the archive's "src" directory)
    uses the typical open source command sequence of:
    <ol style="font-family: monospace">
      <li>./configure</li>
      <li>make</li>
      <li>sudo make install</li>
    </ol>
  </p>
  <p class="paragraph">
    All the supported languages
    are currently required for the configuration, so that the generated
    configuration uses valid paths and the integration tests can be run.
    So, that means that the configuration will expect a C compiler,
    a C++ compiler, Java Development Kit (JDK), Python (&ge; 2.7),
    Ruby (&ge; 1.9), and Erlang (&ge; <a href="http://www.erlang.org/download.html" target="_blank">R16</a>).
    CloudI is tested on each release of Erlang (currently R16B03).
    Dependencies as they are packaged for different operating systems are
    listed below:
    <table><tr><th>
    Operating System
    </th><th>
    Packages
    </th></tr><tr><td>
    Ubuntu 12.04<br />(apt-get install &lt;package(s)&gt;)
    </td><td>
    <ul>
      <li>erlang</li>
      <li>g++</li>
      <li>libboost-thread-dev</li>
      <li>libboost-dev</li>
      <li>default-jdk</li>
      <li>python</li>
      <li>python-dev</li>
      <li>ruby1.9.1</li>
      <li>libgmp3-dev</li>
      <li>uuid-dev</li>
    </ul>
    </td></tr><tr><td>
    OSX w/macports<br />(port install &lt;package(s)&gt;)
    </td><td>
    <ul>
      <li>erlang</li>
      <li>libstdcxx</li>
      <li>boost</li>
      <li>python27</li>
      <li>ruby19</li>
      <li>gmp</li>
    </ul>
    </td></tr></table>
  </p>
  <div class="top"><a href="#3_contents">Top</a></div>

  <a name="3_Options"></a>
  <h3>3.2 - Installation Options</h3>
  <p>
    Common CloudI installation configuration options
    ("./configure" command line arguments) are:
    <table><tr><td>
    --prefix="/path/to/install/"
    </td><td>
    Specify an Installation Path (default="/usr/local/")
    </td></tr><tr><td>
    --with-zeromq
    </td><td>
    Include <a href="http://www.zeromq.org/" target="_blank">ZeroMQ</a> support
    </td></tr><tr><td>
    --with-zeromq-version=[2|3]
    </td><td>
    ZeroMQ major version (3 is the default)
    </td></tr></table>
  </p>
  <p class="paragraph">
    For more installation configuration option details, please execute
    "./configure --help" (otherwise, you can refer to
    <a href="https://github.com/CloudI/CloudI/blob/master/src/INSTALL" target="_blank">src/INSTALL</a>
    for basic configuration information).
  </p>
  <div class="top"><a href="#3_contents">Top</a></div>

  <a name="3_OSX"></a>
  <h3>3.3 - OS X Installation</h3>
  <p class="paragraph">
    To install CloudI dependencies on OSX you either need <a href="http://www.macports.org/" target="_blank">macports</a> or
    <a href="https://mxcl.github.com/homebrew/" target="_blank">homebrew</a>.
    All configuration and build steps are the same as Linux.
  </p>
  <div class="top"><a href="#3_contents">Top</a></div>

  <a name="3_Running"></a>
  <h3>3.4 - Running CloudI</h3>
  <p>
    To start CloudI, execute:
<pre>
sudo cloudi start
</pre>
    To stop the running CloudI node, execute:
<pre>
sudo cloudi stop
</pre>
  </p>
  <p class="paragraph">
    When CloudI is running, CloudI logging output will be appended to
    <a href="#3_Options">PREFIX</a>/var/logs/cloudi/cloudi.log.
  </p>
  <div class="top"><a href="#3_contents">Top</a></div>

  <a name="3_Config"></a>
  <h3>3.5 - Configuration</h3>
  <p class="paragraph">
    The CloudI configuration provides all the initial parameters for startup.
    It is also possible to do the same configuration with the CloudI Service
    API (so, the configuration can also be done dynamically as described in
    <a href="#4_ServiceAPI">"4.2 - How do I control CloudI dynamically?"</a>).
  </p>
  <p class="paragraph">
    The configuration is organized into sections for the ACLs, Services, Nodes,
    and Logging.  The ACLs provide a name which can be referenced by a Service
    to either explicitly allow or deny communication between services
    (based on service name prefixes, see 
    <a href="#4_ACLs">"4.7 - How do I use Access Control Lists (ACLs)?"</a>
    for more information).
  </p>
  <p class="paragraph">
    The Services configuration specifies both the services that are ran
    and the order in which the services should be started.  The "internal"
    Services are Erlang modules that use the cloudi_service behavior.  The
    "external" Services are all non-Erlang languages that use the
    <a href="api.html#Service">CloudI API</a>.
    There is more information about service integration in
    <a href="#6_C">"6 - Services"</a> and
    <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <p class="paragraph">
    The Nodes configuration lists all CloudI nodes that should be connected.
    This allows the CloudI node connections to reconnect after network failures.
  </p>
  <p class="paragraph">
    The Logging configuration specifies the logging level and whether the
    logging output should be directed to a different CloudI node
    (which is present in the Nodes section).  If the logging is redirected to
    a different CloudI node, it is possible to lose logging data when a network
    outage occurs.  However, if the node has failed, the logging output will
    be stored locally until the node reconnects (i.e., the logging output is
    redirected to the CloudI node automatically, when it is connected).
  </p>
  <p>
    Below is a summary of the layout of the CloudI
    <a href="api.html#CloudI">configuration</a> file.  The
    ()s have been used to specify the configuration parameters that are
    supplied.  You can find this file in
    <a href="https://github.com/CloudI/CloudI/blob/master/src/cloudi.conf.in" target="_blank">src/cloudi.conf.in</a>
    within the source code repository (in its state before it gets modified
    by the local operating system configuration parameters) or
    PREFIX/etc/cloudi/cloudi.conf after the installation.
<pre>
{acl, <a href="api.html#2_acl_add">[
    {(AliasName), [(ServiceNamePrefix) or (AliasName), ...]}
    ...
]</a>}.
{services, [
    {internal, <a href="api.html#2_services_add">
     (ServiceNamePrefix),
     (ErlangModuleName),
     (ModuleInitializationList),
     (DestinationRefreshMethod),
     (InitializationTimeout),
     (DefaultAsynchronousTimeout),
     (DefaultSynchronousTimeout),
     (DestinationDenyACL),
     (DestinationAllowACL),
     (ProcessCount),
     (MaxR),
     (MaxT),</a><a href="api.html#2_services_add_config_opts">
     (ServiceOptionsPropList)</a>},
    {external, <a href="api.html#2_services_add">
     (ServiceNamePrefix),
     (ExecutableFilePath),
     (ExecutableCommandLineArguments),
     (ExecutableEnvironmentalVariables),
     (DestinationRefreshMethod),
     (Protocol),
     (ProtocolBufferSize),
     (InitializationTimeout),
     (DefaultAsynchronousTimeout),
     (DefaultSynchronousTimeout),
     (DestinationDenyACL),
     (DestinationAllowACL),
     (ProcessCount),
     (ThreadCount),
     (MaxR),
     (MaxT),</a><a href="api.html#2_services_add_config_opts">
     (ServiceOptionsPropList)</a>},<a href="api.html#2_services_add">
    ...</a>
]}.
{nodes, <a href="api.html#2_nodes_add">[
    'cloudi@hostname1',
    ...
] % or 'automatic' for automatic LAN node configuration </a>
}.
{logging, <a href="api.html#2_loglevel_set">[
    {level, trace}, % levels: off, fatal, error, warn, info, debug, trace
    {redirect, undefined or (Node)}
]</a>}.
</pre>
  </p>
  <p class="paragraph">
    The default configuration runs a variety of integration tests
    which are used to test CloudI:
    <ul>
      <li>hexpi</li>
      <li>http</li>
      <li>http_req</li>
      <li>zeromq</li>
      <li>msg_size</li>
      <li>messaging</li>
    </ul>
    Some of the tests are explained within <a href="#6_C">"6 - Services"</a>.
    All of the tests can be found within the source code repository in
    <a href="https://github.com/CloudI/CloudI/tree/master/src/tests" target="_blank">src/tests</a>.  There is no reason to keep the tests within the
    configuration once you start using CloudI for your own integration.
  </p>
  <div class="top"><a href="#3_contents">Top</a></div>

  <hr \>
  <h2>4 - General Questions</h2>

  <a name="4_API"></a>
  <h3>4.1 - How do I integrate external software with CloudI?</h3>
  <p class="paragraph">
    There are many integration points for external software to become CloudI
    services or utilize CloudI services.  The current integration points are:
    <ul>
      <li>CloudI API</li>
      <li>ZeroMQ</li>
      <li>HTTP</li>
      <li>Supported databases
      <ul>
        <li>CouchDB</li>
        <li>memcached</li>
        <li>MySQL</li>
        <li>PostgreSQL</li>
        <li>Tokyo Tyrant</li>
      </ul>
      </li>
    </ul>
  </p>
  <h4><a href="api.html#Service">CloudI API</a></h4>
  <p class="paragraph">
    The CloudI API provides a light-weight interface for creating services
    in C++/C, Erlang, Java, Python, and Ruby.  Services subscribe to receive
    requests from other services using the CloudI API
    "<a href="api.html#1_subscribe">subscribe</a>" function
    call.  The subscribe function call takes a suffix string that is expected
    to contain a path using a forward slash '/' (e.g., /cloudi/api/json_rpc/).
    However, the service configuration provides the prefix for the subscription
    function call, so "/cloudi/api/" is provided as a configuration prefix
    (for the <a href="api.html#CloudI">CloudI Service API</a> service)
    but the subscribe function call only needs to
    be called with the string "json_rpc/" so that a subscription takes place
    for any services sending requests to "/cloudi/api/json_rpc/",
    which is called a "name".
  </p>
  <p class="paragraph">
    The requests are load balanced across all the services that have subscribed
    to the same name during the lookup to find the request destination.
    There is a service configuration parameter called the "destination refresh"
    that determines how the internal CloudI load balancing occurs when a
    request is sent from that service.  The possible destination refresh
    values are: 
    <ul>
      <li>lazy_closest</li>
      <li>lazy_furthest</li>
      <li>lazy_random</li>
      <li>lazy_local</li>
      <li>lazy_remote</li>
      <li>lazy_newest</li>
      <li>lazy_oldest</li>
      <li>immediate_closest</li>
      <li>immediate_furthest</li>
      <li>immediate_random</li>
      <li>immediate_local</li>
      <li>immediate_remote</li>
      <li>immediate_newest</li>
      <li>immediate_oldest</li>
      <li>none</li>
    </ul>
    The "none" destination refresh is used for services that never send
    requests (i.e., they only receives requests) and creates
    an error that terminates the service if the service does send a request.
    The "lazy" prefix destination refresh methods use an older cached value
    for determining service destinations, so services that communicate
    primarily with long-lived services can use a "lazy" prefix destination
    refresh for more scalable communication.  The "immediate" prefix
    destination refresh methods always use current information for
    determining service destinations, so services that communicate primarily
    with short-lived services can always send to relevant destinations.
    The "closest" suffix destination refresh methods always prefer
    services that exist on the local CloudI node, over remote CloudI nodes.
    The "random" suffix destination refresh methods load balances evenly
    across all services on all CloudI nodes.
  </p>
  <p class="paragraph">
    The following functions exist in the CloudI API for sending a request:
    <ul>
      <li><a href="api.html#1_send_async">send_async</a></li>
      <li><a href="api.html#1_send_sync">send_sync</a></li>
      <li><a href="api.html#1_mcast_async">mcast_async</a></li>
    </ul>
    The "send" prefix functions send a binary message (uninterpreted raw data)
    to a single service name (which is then load balanced among the available
    services).  If the service name does not exist, the request will be retried
    until the request timeout elapses and no binary data will be returned
    (i.e., returning no data is equivalent to a timeout).  
    If a service receives a request while handling an older request, the
    request is queued based on its priority, where -128 is the highest
    priority, 0 is the default priority and 127 is the lowest priority.
    The "mcast" prefix
    function provides publish functionality, so a binary message is published
    to all services that have subscribed to a single service name.  However,
    the "mcast" prefix function is slightly different from other publish
    functionality because it returns all the transaction ids (UUIDs used
    to uniquely identify a request among all CloudI nodes) so that responses
    (if any are returned) may be retrieved.  A service can utilize publish
    behavior that doesn't return data by simply returning no data
    (since returning no data is equivalent to a timeout).  The "async" suffix
    functions (i.e., asynchronous) only return the transaction id of the
    sent request(s) so that the response may be queried with the
    "<a href="api.html#1_recv_async">recv_async</a>" function.
    The "<a href="api.html#1_recv_async">recv_async</a>" function
    can also be used with a
    null UUID to return the oldest response that was received.
    If no services are available for the name of
    the destination, the "async" suffix function will block until the
    destination is found to send the request by retrying the send until
    the timeout elapses (i.e., the asynchronous sends are asynchronous after
    the send takes place).  The "sync" suffix function will block until
    a response is returned or the timeout elapses.  If a response is returned
    with no data, a timeout will be returned instead.  If the request
    destination name is blocked by an Access Control List (ACL) entry, a
    timeout will be returned immediately from the send function.
  </p>
  <p class="paragraph">
    When a service receives a request, it is passed as a parameter to the
    callback function.  The callback function was specified as an argument
    to the "<a href="api.html#1_subscribe">subscribe</a>" function.
    However, in Erlang all requests use the
    same callback function which is cloudi_service_handle_request/11.
    Within the callback function any send or receive operations can take place.
    When the callback function wants to terminate it can either return a result
    or forward the request to another service name by using the "return"
    function or the "<a href="api.html#1_forward">forward</a>" function,
    respectively.  If the service does not
    want to return a response, the service can simply call
    "<a href="api.html#1_return">return</a>" with
    an empty binary response value and it will be interpreted as if the
    request timeout elapsed.  Using the
    "<a href="api.html#1_forward">forward</a>" function will decrease the
    request timeout slightly (by 100ms) to prevent requests from causing
    persistent traffic.
  </p>
  <p class="paragraph">
    The Access Control List (ACL) is simply a list of strings that define
    patterns that must be explicitly allowed or denied when determining if a
    service can send to the service name.
    A pattern uses "*" to represent a ".+" regex (one or more characters) while
    "**" is forbidden, which is the same format used for service subscriptions.
    Previous ACL usage in CloudI used prefixes, which is still valid, but a "*"
    is appended to create a pattern.  This means that only patterns are accepted
    and no exact service names will be valid ACL strings.
  </p>
  <p class="paragraph">
    If an ACL pattern is both allowed and
    denied, the pattern is denied (deny takes precedence).  When defining ACLs,
    it is possible to use Erlang atoms to represent lists of string patterns
    so that logical groupings are created.  The ACL atoms are then able to
    be specified anywhere an ACL string might be present.  So, it is
    best to group ACL string patterns based on context to simplify the
    configuration specification.
  </p>
  <p class="paragraph">
    The CloudI API external service requests are limited to 2GB.
    External service configuration
    can specify the number of threads per process and the number of processes
    which should be spawned, so that each thread receives an instance of the
    CloudI API.  This means that there can be one ioloop per thread per process
    for maximum throughput.
  </p>
  <a name="4_API_ZeroMQ"></a>
  <h4>ZeroMQ</h4>
  <p class="paragraph">
    ZeroMQ integration provides a way of connecting to external <a href="http://www.zeromq.org/" target="_blank">ZeroMQ</a>
    messaging or other CloudI nodes by using ZeroMQ as the messaging bus.
    The cloudi_service_zeromq service is an Erlang service that provides
    ZeroMQ integration by defining a set of mappings between service names
    and the ZeroMQ destinations.  To use ZeroMQ with CloudI, you need to make
    sure and enable ZeroMQ with the configuration script (with
    "./configure --with-zeromq").  The cloudi_service_zeromq configuration
    (in the cloudi.conf file or through the CloudI Service API
     <a href="api.html#2_services_add">services_add/2</a> function)
    allows key/value tuples with the following key atoms: outbound, inbound,
    publish, subscribe, push, and pull, which are the following ZeroMQ
    equivalents: ZMQ_REQ, ZMQ_REP, ZMQ_PUB, ZMQ_SUB, ZMQ_PUSH, and ZMQ_PULL,
    respectively.  The value is a tuple that contains a mapping key/value
    where the key is the service name suffix and the value is the list of
    ZeroMQ endpoints.  However, the publish and subscribe ZeroMQ configuration
    is slightly more complex because instead of a service name, it contains
    a list of key/value ZeroMQ subscription mapping where the key is the
    service name suffix and the value is the ZeroMQ subscription string.
    The example configuration file entry below should illustrate the ZeroMQ
    service configuration:
    <pre>
% an entry in the cloudi.conf configuration file
% that uses the ZeroMQ service
{internal,
    "/tests/zeromq/",
    % inbound/outbound message paths much be acyclic
    % (if they are not, you will receive a erlzmq EFSM error
    %  because the ZeroMQ REQ has received 2 zmq_send calls)
    cloudi_service_zeromq,
    % outbound ZeroMQ requests connect a CloudI name to a ZeroMQ endpoint
    [{outbound, {"zigzag_start", ["ipc:///tmp/cloudizigzagstart"]}},
    % inbound ZeroMQ replies connect a ZeroMQ endpoint to a CloudI name
     {inbound, {"zigzag_step1", ["ipc:///tmp/cloudizigzagstart"]}},
     {outbound, {"zigzag_step1", ["inproc://zigzagstep1"]}},
     {inbound, {"zigzag_step2", ["inproc://zigzagstep1"]}},
    % ZeroMQ publish connects a CloudI name to a ZeroMQ (subscribe) name
    % as {CloudI name (suffix), ZeroMQ name for message prefix}
    % for any number of endpoints
     {publish, {[{"zigzag_step2", "/zeromq/step2"}],
                ["inproc://zigzagstep2a",
                 "ipc:///tmp/cloudizigzagstep2b",
                 "inproc://zigzagstep2c",
                 "ipc:///tmp/cloudizigzagstep2d"]}},
    % ZeroMQ subscribe connects a CloudI name to a ZeroMQ (subscribe) name
    % as {CloudI name (suffix), ZeroMQ name for subscribe setsocketopt}
    % for any number of endpoints
     {subscribe, {[{"zigzag_step3a", "/zeromq/step2"},
                   {"zigzag_step3b", "/zeromq/step2"}],
                  ["inproc://zigzagstep2a",
                   "ipc:///tmp/cloudizigzagstep2b",
                   "inproc://zigzagstep2c",
                   "ipc:///tmp/cloudizigzagstep2d"]}},
     {outbound, {"zigzag_step3a", ["inproc://zigzagstep3"]}},
     {inbound, {"zigzag_finish", ["inproc://zigzagstep3"]}}],
    immediate_closest,
    5000, 5000, 5000, [api], undefined, 2, 5, 300, []}
    </pre>
  </p>
  <a name="4_API_HTTP"></a>
  <h4>HTTP</h4>
  <p class="paragraph">
    The Erlang service cloudi_service_http_cowboy
    (or cloudi_service_http_elli) accepts HTTP traffic and
    makes the HTTP requests CloudI requests where the HTTP path in the URL
    is used as the service name.
    By default, the HTTP method is specified as a suffix on the HTTP path
    (e.g., "/index.html/get") but this can be disabled with the
    "use_method_suffix" configuration parameter.
    When a HTTP request is received
    the corresponding service name will be called with the request contents
    (uncompressed, if the request was compressed).  The headers are passed
    within the "request info" as key-value pairs that is request meta-data.
    The content type of the
    response is either forced by the configuration (with "content_type") or
    it is determined by the file extension on the service name.
  </p>
  <h4>Supported Databases</h4>
  <p class="paragraph">
    All the supported databases can be accessed by CloudI services.
    The CloudI Erlang service that provides database support
    (e.g., cloudi_service_db_pgsql, cloudi_service_db_mysql, etc.) uses
    the database name as the service name suffix.  Services can send requests
    to the database service name in the appropriate format to
    interact with the database.  The format to send is either SQL for an
    SQL database or a command tuple if it is a NoSQL database
    (e.g., {'set', "key", "value"}).
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_ServiceAPI"></a>
  <h3>4.2 - How do I control CloudI dynamically?</h3>
  <p class="paragraph">
    CloudI's configuration can be changed dynamically while it is running
    by using the <a href="api.html#CloudI">CloudI Service API</a>.
    The CloudI Service API can be used by any CloudI
    services with service requests to the configured
    cloudi_service_api_requests service or as Erlang function calls to the
    cloudi_service_api module.  However, typical usage of the
    CloudI Service API would use raw HTTP requests or JSON-RPC over HTTP, using
    both a configured cloudi_service_http_cowboy service and a configured
    cloudi_service_api_requests service.  A complex example of using the
    CloudI Service API through JSON-RPC over HTTP with python code can be found in <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/service_api/run.py" target="_blank">src/tests/service_api/run.py</a>.
    Some simpler examples of using the CloudI Service API can be found at
    <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/service_api/path.py" target="_blank">src/tests/service_api/path.py</a>,
    <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/service_api/logging_off.py" target="_blank">src/tests/service_api/logging_off.py</a> and
    <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/service_api/logging_on.py" target="_blank">src/tests/service_api/logging_on.py</a>.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_PubSub"></a>
  <h3>4.3 - How do I use Publisher/Subscriber messaging?</h3>
  <p class="paragraph">
    The simplest way to use publisher/subscriber functionality is to use the
    CloudI API functions "<a href="api.html#1_mcast_async">mcast_async</a>"
    for publishing and "<a href="api.html#1_subscribe">subscribe</a>" for
    subscribing.  For more details please refer to the <a href="#4_API">CloudI API documentation</a>.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_RPC"></a>
  <h3>4.4 - How do I use Remote Procedure Calls (RPC)?</h3>
  <p class="paragraph">
    Remote procedure calls can easily be used within CloudI services with a
    CloudI API "<a href="api.html#1_send_sync">send_sync</a>" function call.
    The RPC procedure name is used
    as a service name suffix and the RPC parameters are stored in the
    request body.  The request body is simply uninterpreted
    binary data, so no format is imposed on the user of the CloudI API.
    Any request meta-data should be specified as key-value pairs within the
    "request info" parameter.  The "response info" parameter can be used
    for response meta-data in the same way.
    For more details please refer to the <a href="#4_API">CloudI API documentation</a>.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_WebServices"></a>
  <h3>4.5 - How do I create Web Services?</h3>
  <p class="paragraph">
    Web Services are simply CloudI services that accept incoming HTTP traffic
    coming from the cloudi_service_http_cowboy service.  The request body is
    either the body of the uncompressed PUT or POST request, or it is the
    GET query string.
    For more details please refer to the
    <a href="#6_HTTP">HTTP Integration</a> documentation.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_WebSockets"></a>
  <h3>4.6 - Does CloudI support WebSockets?</h3>
  <p class="paragraph">
    CloudI supports WebSocket connections with the cloudi_service_http_cowboy
    service, when it is configured with "{use_websockets, true}".  Incoming
    HTTP requests become CloudI service requests which return the service
    response as a HTTP response, with the HTTP headers passed in the
    RequestInfo and ResponseInfo as key-value data
    (<a href="#6_HTTP">HTTP Integration</a>).  Incoming WebSocket requests
    add a "/get" suffix on the URL to create the service name used for the
    service request (when configured with "{use_method_suffix, true}",
    the default).
  </p>
  <p class="paragraph">
    Outgoing WebSocket CloudI service requests are also possible if the
    WebSocket connection URL matches the cloudi_service_http_cowboy
    service prefix in its service configuration.  The outgoing CloudI service
    requests can be sent to the WebSocket URL with a "/websocket" suffix added.
    All outgoing CloudI service requests expect a response from the WebSocket
    client within the service request timeout period.  An <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/public_html/websockets.html" target="_blank">example</a>
    (using an <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/websockets/websockets.py" target="_blank">example service</a>)
    of the WebSocket functionality exists at <a href="http://127.0.0.1:6464/tests/http_req/websockets.html" target="_blank">http://127.0.0.1:6464/tests/http_req/websockets.html</a>
    when CloudI is running with the default configuration.  It is important
    to enforce the request/response order within the WebSocket client to avoid
    erroneous service request responses (the example demonstrates this when
    the "Request" link is rapidly clicked repeatedly).
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_ACLs"></a>
  <h3>4.7 - How do I use Access Control Lists (ACLs)?</h3>
  <p class="paragraph">
    Access Control Lists (ACLs) are used to explicitly allow or deny requests
    from being sent to service name patterns.
    A pattern uses "*" to represent a ".+" regex (one or more characters) while
    "**" is forbidden, which is the same format used for service subscriptions.
    Two separate ACL parameters are
    specified for each service configuration to allow or deny destinations.
    If an ACL is not provided, the atom 'undefined' is used instead.  An ACL is
    provided as a list of strings that are service name patterns.  Instead of a
    string, an atom alias may be provided that was defined in the 'acl'
    configuration so that the service configuration is simpler and more
    consistent (i.e., without strings that are replicated among the service
    configuration entries).  A fake sample from a configuration file can
    illustrate how this works:
<pre>
{acl, [
    {alias1, ["/service/name/prefix1", "/service/name/prefix2*", alias2]},
    {alias2, ["/subsystem1/prefix1*", "/subsystem2/prefix1"]}
]}.
{services, [
    {internal,
     (ServiceNamePrefix),
     (ErlangModuleName),
     (ModuleInitializationList),
     (DestinationRefreshMethod),
     (InitializationTimeout),
     (DefaultAsynchronousTimeout),
     (DefaultSynchronousTimeout),

     % ACL DENY LIST
     % (e.g, valid values could be: undefined or [alias1] or [alias2] or etc.)
     (DestinationDenyList),
     
     % ACL ALLOW LIST
     % (e.g, valid values could be: undefined or [alias1] or [alias2] or etc.)
     (DestinationAllowList),

     (ProcessCount),
     (MaxR),
     (MaxT),
     (ServiceOptionsPropList)},
    {external,
     (ServiceNamePrefix),
     (ExecutableFilePath),
     (ExecutableCommandLineArguments),
     (ExecutableEnvironmentalVariables),
     (DestinationRefreshMethod),
     (Protocol),
     (ProtocolBufferSize),
     (InitializationTimeout),
     (DefaultAsynchronousTimeout),
     (DefaultSynchronousTimeout),

     % ACL DENY LIST
     % (e.g, valid values could be: undefined or [alias1] or [alias2] or etc.)
     (DestinationDenyList),

     % ACL ALLOW LIST
     % (e.g, valid values could be: undefined or [alias1] or [alias2] or etc.)
     (DestinationAllowList),

     (ProcessCount),
     (ThreadCount),
     (MaxR),
     (MaxT),
     (ServiceOptionsPropList)},
]}.
...
</pre>
  </p>
  <p class="paragraph">
    The <a href="api.html#2_services_add">CloudI Service API</a>
    supports dynamically starting services by supplying a
    'services' list in the same format as the configuration file.
    The CloudI Service API also supports defining multiple 'acl' aliases that
    may be referenced from dynamically configured services.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_ServiceFail"></a>
  <h3>4.8 - How do I Migrate a Service from a Failed or Failing Node?</h3>
  <p class="paragraph">
    A migration would imply that there is unavoidable latency during a
    switchover from a failed node to a healthy node.  To avoid failover latency
    and improve scalability, services are replicated on all nodes.  Proper
    service implementation dictates that services will only cache data.
    All dynamic state a service uses should be accessed and/or stored by a
    database.  To communicate with a database, a service should use the
    <a href="api.html#Service">CloudI API</a>
    to send requests to a configured CloudI database integration
    service.  The implementation of services that avoids state-keeping within
    the service's data structures is required to make sure a service is
    scalable, fault-tolerant and can recover from a failure without losing
    a significant amount of data.
  </p>
  <p class="paragraph">
    So, a service should not need to be migrated from a node.  If a node has
    failed there are many possible courses of action:
    <ul>
      <li>Shutdown CloudI on the Failed Node</li>
      <li>Stop the Service on the Failed Node by using the <a href="api.html#CloudI">CloudI Service API</a></li>
      <li>Disconnect the Failed Node from the Network to Diagnose in Isolation</li>
    </ul>
    Since services are replicated on other nodes the system is fault-tolerant
    and can operate without a failed node.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_URLregex"></a>
  <h3>4.9 - Can I use Regular Expressions with Service Names (URLs)?</h3>
  <p class="paragraph">
    A simpler substitute for regular expressions is provided for matching
    CloudI service names.  The "*" character (a wildcard character) is
    used to match 1 or more character within a service name
    (i.e., a regex of '.+').  However, the sequence "**" is invalid and
    will cause the operation to fail.  Any number of wildcard characters can
    be used with the <a href="api.html#1_subscribe">subscribe</a>
    and <a href="api.html#1_unsubscribe">unsubscribe</a> CloudI API functions
    to create service names that match many patterns.  While this approach
    may seem unusual, it helps keep service name lookups both efficient
    and parallel (i.e., within the Erlang code, without any need to call an
    external regex integration library).  For more details refer to
    <a href="#4_NamePattern">"4.10 - How do Service Name Patterns work?"</a>.
  </p>
  <p class="paragraph">
    Another possibility is just using explicit service names, even when the
    service name contains a dynamic parameter.  Using all possible service
    names is bounded by the memory available.  To give an idea of the memory
    consumption, on a 64-bit machine using service names that contain a
    single dynamic integer, 1 million integers used within 1 million
    subscribe CloudI API calls will consume roughly 100 MB of RAM when the
    CloudI service is ran (i.e., the service that performs the subscribe
    CloudI API calls).  All other CloudI services that use a "lazy"
    destination refresh method will replicate the service name data
    structure, so that will increase the node's memory consumption.
    So, depending on your needs and your memory limitations, you may want to
    use explicit service names or service names with wildcard characters.
    Using the wildcard character is normally a more efficient choice due
    to the memory consumption and its impact on caching but it puts the burden
    of validation on the source code handling the service request.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_NamePattern"></a>
  <h3>4.10 - How do Service Name Patterns work?</h3>
  <p class="paragraph">
    Service name patterns are service names that contain any number of "*"
    character (while "**" is invalid).  The "*" character (a wildcard character)
    matches 1 or more character within a service name used within a service
    request.  A CloudI API
    <a href="api.html#1_subscribe">subscribe</a>
    function call can take a service name
    pattern which then matches an exact (non-pattern) service name provided
    to a CloudI API <a href="api.html#1_send_async">send_async</a>,
    <a href="api.html#1_send_sync">send_sync</a>, or
    <a href="api.html#1_mcast_async">mcast_async</a> function.
  </p>
  <p class="paragraph">
    When a service name pattern exists that overlaps an exact service name,
    the most exact service name match is preferred, e.g.:
    <ul>
      <li>Service A subscribes to "/accounting/balances/*"</li>
      <li>Service B subscribes to "/accounting/balances/fred"</li>
    </ul>
    Service B will receive a service request sent to
    "/accounting/balances/fred" but Service A will receive all other service
    requests that match the prefix "/accounting/balances/".
  </p>
  <p class="paragraph">
    When several wildcard characters are used, the most exact service name
    match is preferred, where left-most characters are given more
    significance, e.g.:
    <ul>
      <li>Service A subscribes to "/permissions/*/accounts/*"</li>
      <li>Service B subscribes to "/permissions/fred/accounts/*"</li>
      <li>Service C subscribes to "/permissions/*/accounts/add"</li>
      <li>Service D subscribes to "/permissions/fred/accounts/remove"</li>
    </ul>
    Service B will receive a service request sent to
    "/permissions/fred/accounts/add", instead of Service C, because
    the left-most characters provide a more exact match.  Service name
    prefixes within the service configuration provide a scope for the service
    name subscriptions and the prefix shows the significance of the left-most
    characters being used.  The service name subscriptions can be checked by
    using the <a href="api.html#2_services_search">services_search</a>
    CloudI Service API function.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_ThreadSafe"></a>
  <h3>4.11 - Is the CloudI API thread-safe?</h3>
  <p class="paragraph">
    The <a href="api.html#Service">CloudI API</a> is not thread-safe
    (i.e., it is not reentrant)
    because it is meant to be used by individual threads that are configured
    within the CloudI service configuration (e.g., using the CloudI
    configuration file or the
    <a href="api.html#2_services_add_config">CloudI Service API</a>).
    This approach avoids any lock contention issues outside of the Erlang VM.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_Speed"></a>
  <h3>4.12 - How can CloudI requests take advantage of cache coherency, minimum network latency, and any logical grouping?</h3>
  <p class="paragraph">
    To provide better computing node grouping, service names should uniquely
    describe the context of the node.  If the context is provided, then there
    is a natural grouping for CloudI requests with any
    <a href="api.html#Service">CloudI API</a>
    usage that uses the associated service name(s).
    <a href="#4_NamePattern">Service name patterns</a>
    can provide extra flexibility for grouping service functionality.
    The destination refresh method can minimize network latency by preferring
    local services before using remote services (i.e., a "closest"
    <a href="api.html#1_Intro_dest">destination refresh method</a>).
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <a name="4_Erlang"></a>
  <h3>4.13 - Why not just use Erlang directly?</h3>
  <p class="block">
    Erlang does naturally support integration in the following ways:
    <ul>
      <li>NIF (Native Interface Function)</li>
      <li>port drivers</li>
      <li>port</li>
      <li>cnode</li>
    </ul>
  </p>
  <p class="paragraph">
    NIFs and port drivers can integrate with external source code
    (normally only C or C++) as a dynamic library that is loaded by the
    Erlang VM.  This approach is the most efficient and the most
    error-prone (any memory corruption impacts the Erlang VM to create new
    and exciting system crashes, sabotaging the fault-tolerance the Erlang VM
    provides).  A port is an external executable ran as a separate OS
    process linked to the Erlang VM, communicating over pipes.  A cnode is
    a separate executable communicating as an Erlang node with the
    distributed Erlang protocol.
  </p>
  <p class="paragraph">
    CloudI's external service execution is most similar to Erlang port
    integration.  However, CloudI provides many additional features for
    external services that are normally not present:
    <ul>
      <li>A service container abstraction for simpler <a href="http://en.wikipedia.org/wiki/Service_oriented_architecture" target="_blank">Service Oriented Architecture (SOA)</a> development.</li>
      <li>Protocol agnostic transactional communication with a small consistent API (i.e., the <a href="api.html#Service" target="_blank">CloudI API</a>).</li>
      <li>Each external service thread uses its own <a href="api.html#Service" target="_blank">CloudI API</a> object with a separate connection to the Erlang VM; Erlang's Actor model is extended into the external languages to eliminate contention that is normally seen with Erlang ports, Erlang cnodes and Erlang jinterface usage.</li>
      <li>All external services are managed with fault-tolerance constraints, in the same way as Erlang/OTP supervisors.</li>
      <li>A service can use service configuration options to easily adjust efficiency and memory consumption (e.g., <a href="api.html#2_services_add_config_opts" target="_blank">queue_limit, hibernate, request_pid_options, etc.</a>).</li>
      <li>Erlang source code within a service can automatically handle more throughput than Erlang/OTP behaviors with <a href="api.html#2_services_add_config_opts" target="_blank">duo_mode</a> set within the service configuration options.</li>
      <li>Every service request receives a unique UUID (Universally Unique IDentifier).</li>
      <li>A service request timeout is decreased by any queuing or processing delays to provide better soft-realtime timeout enforcement than what Erlang/OTP provides.</li>
      <li>Service name grouping with <a href="#4_URLregex">pattern matching</a>.</li>
      <li>Every service request can utilize 255 possible request priorities</li>
      <li>TCP sockets are used instead of pipes to maximize atomic send throughput (the localhost MTU is 16436 on Linux, but pipes are typically 4096 on Linux (PIPE_BUF)).</li>
      <li>stdout and stderr output is logged automatically to the single CloudI log.</li>
      <li>A service does not require a node connection (like a cnode does), so it doesn't have service-count scalability problems (due to a distributed Erlang node being a member of a fully connected network topology).</li>
      <li>UNIX domain socket integration is provided for external CloudI services with the "local" protocol (the default) service configuration option despite the fact Core Erlang/OTP does not provide UNIX domain socket integration.</a>
      <li>A long-running CloudI service can be contrary to the Erlang VM scheduling and garbage collection, when under heavy load, if implemented without CloudI.  This is especially true when attempting to integrate with C or C++ which can cause the schedulers to lock-up if a NIF or port driver is used for longer operations (&ge; 1 ms), causing poor Erlang VM performance.</li>
      <li>Core Erlang/OTP source code does not handle node-splits (global name registration, global transactions and mnesia are common examples), but CloudI provides master-less fault-tolerance for a cluster of any number of CloudI nodes on an unreliable network.</li>
    </ul>
  </p>
  <p class="paragraph">
    The <a href="api.html#Service" target="_blank">CloudI API</a> is
    consistent for all the supported programming languages,
    which makes it easier to move service functionality inbetween programming
    languages or inbetween services.  All external CloudI services communicate
    in the same way and all service requests are processed in the same way,
    to create a consistent integration framework.  Using CloudI naturally
    reduces the complexity of integration source code so that errors are more
    specific to the business logic being developed, because CloudI is
    continuously tested to ensure it provides both a stable and dependable
    integration framework.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <hr \>
  <h2>5 - Migrating to CloudI</h2>

  <a name="5_Performance"></a>
  <h3>5.1 - Performance Considerations</h3>
  <p class="paragraph">
    There is a latency penalty for communicating with a non-Erlang CloudI
    service because of the extra binary encoding and decoding when using
    the socket that connects the CloudI Erlang VM to the non-Erlang CloudI
    service Operating System (OS) process' thread.  The preemption of
    an Erlang VM scheduler thread by a CloudI service OS thread may
    degrade Erlang VM performance because of a mismatch between the
    kernel scheduler and the Erlang VM scheduler.  The kernel scheduler only
    knows when data is available to a process while the Erlang VM is able to
    schedule based on message queue size.  So, the Erlang VM scheduling
    is able to intelligently schedule CloudI services more so than the
    kernel scheduling.  However, the problem is unavoidable with current OSes
    and can be minimized by having a sufficiently large number of non-Erlang
    CloudI service threads and/or processes created to handle the throughput.
    The mismatch between the kernel scheduler and the Erlang VM scheduler is
    minimized by CloudI's management of CloudI requests, since an external
    service thread is only provided a single request at a time (and the
    mismatch is required to provide fault-tolerance by isolating the memory
    used by external services from the Erlang VM memory).
  </p>
  <p class="paragraph">
    When the number of requests sent to a service name exceeds the number
    of service processes, the services will begin to queue new requests while
    handling older requests (roughly, the distribution of requests to processes
    is random, so it may queue slightly early).  A priority parameter can be
    used if there is differing importance for various service requests
    (priority is normally used when there is a data dependency that needs to
    be solved).  The priority parameter is 0 by default, but -128 is the
    highest priority and 127 is the lowest priority, so that provides much
    room for representing asynchronous data dependencies (synchronous data
    dependencies would use a pipe pattern) or simply processing time priority.
  </p>
  <div class="top"><a href="#5_contents">Top</a></div>

  <a name="5_Scalability"></a>
  <h3>5.2 - Scalability Considerations</h3>
  <p class="paragraph">
    CloudI uses distributed Erlang for communicating between CloudI
    nodes (i.e., machines).  Distributed Erlang creates a fully-connected
    network topology which makes the cluster size of CloudI nodes limited
    to about 50 to 100 nodes (not yet tested).  The node count limitation
    could easily be surpassed by using ZeroMQ to bridge CloudI clusters.
    However, it was anticipated that with multi-core technology
    advancements, the need for very large CloudI clusters would be
    diminished in the immediate future.  The databases that CloudI uses
    are much more likely to need large node counts to facilitate
    large amounts of data which can be accessed as key/value pairs or
    with Map/Reduce.
  </p>
  <div class="top"><a href="#5_contents">Top</a></div>

  <a name="5_Stability"></a>
  <h3>5.3 - Stability and Fault-Tolerance Considerations</h3>
  <p class="paragraph">
    CloudI software release and versioning utilizes
    <a href="http://semver.org/" target="_blank">semantic versioning</a>
    to make any upgrade considerations more explicit.  Any other stability
    concerns are related to CloudI integration.
  </p>
  <p class="paragraph">
    CloudI requests are not sent in a way that is meant to be persistent
    to simplify error-handling.  Otherwise, fault-tolerant messaging would
    preserve requests that are irrelevant and/or erroneous at a future time.
    Instead, CloudI requests can cause a service to crash which means that
    the request is not handled by another service since it is unclear whether
    the request is erroneous or the service is buggy.  CloudI requests also
    have a certain lifetime defined by the request timeout, so that the
    relevance of the request data is limited by the timeout.  The request
    timeout acts to conserve processing time for the most relevant data and
    the services that require the data.  If data needs to be fault-tolerant,
    the data should be stored within a database.
  </p>
  <p class="paragraph">
    Error-handling should always be local (i.e., internal to the service)
    where the errors are most relevant.  Any invalid or corrupt service data
    can terminate the service and will trigger a restart of the service based
    on its configuration parameters.  A service should never be allowed to
    function in a zombie-state since this would only complicate performance,
    testing, debugging and development.
  </p>
  <p class="paragraph">
    The service must exit whenever an unrecoverable error occurs.  If a
    CloudI request causes an exception, the request will fail but the service
    will not be restarted.  So, services should always have proper exception
    handling, to make sure the context of any errors is explicit
    (otherwise, the service source code will become difficult to maintain
    if any CloudI requests fail).  Without service exception handling,
    the exception will cause exception information to be logged, however, the
    information may be minimal (this depends on the limits of the programming
    language used).
  </p>
  <p class="paragraph">
    The non-Erlang CloudI services receive their own Operating System (OS)
    process, so they are well isolated from the Erlang VM's memory.  However,
    Erlang CloudI services could be written with malevolent intentions which
    would make CloudI unstable or erroneous.  This means that Erlang CloudI
    service code must have a greater amount of implicit trust that the
    programmer is not trying to cause problems.  With non-Erlang CloudI
    services there isn't as much concern about whether there are problems
    within the software, since the errors receive isolation within the
    CloudI framework.
  </p>
  <div class="top"><a href="#5_contents">Top</a></div>

  <a name="5_Integration"></a>
  <h3>5.4 - Integration Considerations</h3>
  <p class="paragraph">
    The stdout and stderr of any non-Erlang CloudI service is captured and
    sent separately to be logged by CloudI with the associated Operating System
    (OS) process id.  The <a href="api.html#Service">CloudI API</a>
    makes sure that both the stdout and the
    stderr streams are unbuffered within an external CloudI service, so the
    output will be logged as quickly as possible within the CloudI log as
    error data (for stderr data) or as info data (for stdout data).
  </p>
  <p class="paragraph">
    Any Erlang CloudI services can utilize CloudI's logging
    (ideally for information related to service problems or failures)
    for asynchronous logging (logging that does not carry a performance
    penalty).
  </p>
  <div class="top"><a href="#5_contents">Top</a></div>

  <a name="5_LoadTesting"></a>
  <h3>5.5 - Load Testing</h3>
  <p class="paragraph">
    Since the 1.0.0 CloudI release, the http_req test has been used for
    executing various loadtests which have guided development and configuration
    decisions.  The main goal has been to reduce the latency due to
    external service integration, but it has also helped to minimize internal
    service latency.  The http_req test is a simple HTTP GET request query
    parameter that creates an XML response with the parsed integer.
    Typically, the loadtests have used 20 thousand concurrent connections
    with each connection performing 10 thousand requests per second.
    To keep the loadtesting fair, each http_req test was given a single
    OS process (and/or a single Erlang process) with no threads usage.
    All programming languages received the same amount of load, so that the
    loadtesting results can be compared when making CloudI integration
    decisions.  Below are summaries specific to past releases:
    <ul>
      <li><a href="https://github.com/CloudI/CloudI/raw/master/src/tests/http_req/loadtest/results_v1_2_2/201306_summary.pdf" target="_blank">1.2.2 summary</a></li>
      <li><a href="https://github.com/CloudI/CloudI/raw/master/src/tests/http_req/loadtest/results_v1_2_1/201303_summary.pdf" target="_blank">1.2.1 summary</a></li>
      <li><a href="https://github.com/CloudI/CloudI/raw/master/src/tests/http_req/loadtest/results_v1_1_0/201210_summary.pdf" target="_blank">1.1.0 summary</a></li>
    </ul>
  </p>
  <p>
    The latency graphs below show service request performance during the
    1.2.2 loadtests of 20k connections at 10k req/s
    (with cowboy, Erlang R16B, and Ubuntu 12.04.2):
    <ul>
      <li>
        <a href="https://github.com/CloudI/CloudI/tree/master/src/tests/http_req/loadtest/results_v1_2_2/201306_20k_10kreqs_local/c.tar.gz" target="_blank">
        C++/C
        <img src="images/201306_graphes-Transactions-mean_c.png" /><br />
        <img src="images/201306_graphes-Transactions-min_sample_c.png" width="280" /><img src="images/201306_graphes-Transactions-max_sample_c.png" width="280" />
        </a><br /><br />
      </li>
      <li>
        <a href="https://github.com/CloudI/CloudI/tree/master/src/tests/http_req/loadtest/results_v1_2_2/201306_20k_10kreqs_local/erlang.tar.gz" target="_blank">
        Erlang
        <img src="images/201306_graphes-Transactions-mean_erlang.png" /><br />
        <img src="images/201306_graphes-Transactions-min_sample_erlang.png" width="280" /><img src="images/201306_graphes-Transactions-max_sample_erlang.png" width="280" />
        </a><br /><br />
      </li>
      <li>
        <a href="https://github.com/CloudI/CloudI/tree/master/src/tests/http_req/loadtest/results_v1_2_2/201306_20k_10kreqs_local/java.tar.gz" target="_blank">
        Java
        <img src="images/201306_graphes-Transactions-mean_java.png" /><br />
        <img src="images/201306_graphes-Transactions-min_sample_java.png" width="280" /><img src="images/201306_graphes-Transactions-max_sample_java.png" width="280" />
        </a><br /><br />
      </li>
      <li>
        <a href="https://github.com/CloudI/CloudI/tree/master/src/tests/http_req/loadtest/results_v1_2_2/201306_20k_10kreqs_local/python_c.tar.gz" target="_blank">
        Python
        <img src="images/201306_graphes-Transactions-mean_python_c.png" />
        (with C integration)
        <br />
        <img src="images/201306_graphes-Transactions-min_sample_python_c.png" width="280" /><img src="images/201306_graphes-Transactions-max_sample_python_c.png" width="280" />
        </a><br /><br />
      </li>
      <li>
        <a href="https://github.com/CloudI/CloudI/tree/master/src/tests/http_req/loadtest/results_v1_2_2/201306_20k_10kreqs_local/python.tar.gz" target="_blank">
        Python
        <img src="images/201306_graphes-Transactions-mean_python.png" /><br />
        <img src="images/201306_graphes-Transactions-min_sample_python.png" width="280" /><img src="images/201306_graphes-Transactions-max_sample_python.png" width="280" />
        </a><br /><br />
      </li>
      <li>
        <a href="https://github.com/CloudI/CloudI/tree/master/src/tests/http_req/loadtest/results_v1_2_2/201306_20k_10kreqs_local/ruby.tar.gz" target="_blank">
        Ruby
        <img src="images/201306_graphes-Transactions-mean_ruby.png" /><br />
        <img src="images/201306_graphes-Transactions-min_sample_ruby.png" width="280" /><img src="images/201306_graphes-Transactions-max_sample_ruby.png" width="280" />
        </a><br /><br />
      </li>
    </ul>
  </p>
  <div class="top"><a href="#5_contents">Top</a></div>

  <hr \>
  <h2>6 - Services</h2>

  <a name="6_C"></a>
  <h3>6.1 - C++/C Service Implementation</h3>
  <p class="paragraph">
    There are separate header files that provide both a C CloudI API
    (<a href="https://github.com/CloudI/CloudI/blob/master/src/api/c/cloudi.h" target="_blank">cloudi.h</a>)
    and a C++ CloudI API
    (<a href="https://github.com/CloudI/CloudI/blob/master/src/api/c/cloudi.hpp" target="_blank">cloudi.hpp</a>) which are mutually exclusive.  The header
    files do not bring in external dependencies but both require the standard
    C++ library as a link-time dependency.  Some of the integration
    tests that provide example usage of the C++/C
    <a href="api.html#Service">CloudI API</a> are:
    <ul>
      <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/hexpi/cxx_src/main.cpp" target="_blank">src/tests/hexpi (C++ example with threads)</a>
          <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/hexpi/" target="_blank">Hexadecimal PI Test</a></li>
      <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/c_src/main.c" target="_blank">src/tests/http_req (C example without threads)</a>
          <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/" target="_blank">HTTP Request Test</a></li>
    </ul>
  </p>
  <p class="paragraph">
    If you need to run your service with valgrind, use valgrind as the
    executable in the service configuration and use the valgrind command line
    argument "--track-fds=yes" with the service command line after it.
    The valgrind output will appear within the cloudi.log output.  If you plan
    on using vgdb while valgrind is running, make sure {"USER", "${USER}"} is
    specified in the list of environment variables provided for valgrind
    (running as a CloudI service) so valgrind can properly create its
    vgdb file names.
  </p>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <a name="6_Erlang"></a>
  <h3>6.2 - Erlang Service Implementation</h3>
  <p class="paragraph">
    Erlang CloudI services use the cloudi_service behavior to create an
    "internal" service (all non-Erlang CloudI services are "external").
    The cloudi_service behavior requires that the service implement the
    following functions:
    <ul>
      <li>cloudi_service_init/3</li>
      <li>cloudi_service_handle_request/11</li>
      <li>cloudi_service_handle_info/3</li>
      <li>cloudi_service_terminate/2</li>
    </ul>
  </p>
  <p class="paragraph">
    Many examples of Erlang CloudI services exist within the CloudI source code
    because the Erlang CloudI services provide integration with external
    systems like the supported databases (CouchDB, PostgreSQL, etc.),
    the supported messaging (HTTP, ZeroMQ, etc.), and the CloudI Service API
    functionality.  Some example usage of the Erlang
    <a href="api.html#Service">CloudI API</a> includes:
    <ul>
      <li><a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_filesystem/src/cloudi_service_filesystem.erl" target="_blank">cloudi_service_filesystem Service for Caching Static File Data</a></li>
      <li><a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_work_manager/src/cloudi_service_work_manager.erl" target="_blank">cloudi_service_work_manager Service For Caching Database Updates</a></li>
      <li><a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_timers/src/cloudi_service_timers.erl" target="_blank">cloudi_service_timers service for Sending Service Messages On Timers</a></li>
      <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/hexpi/src/cloudi_service_hexpi.erl" target="_blank">Hexadecimal PI Test Load Balancer</a></li>
    </ul>
  </p>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <a name="6_Java"></a>
  <h3>6.3 - Java Service Implementation</h3>
  <p class="paragraph">
    The Java CloudI API uses synchronous IO on file descriptors for
    an efficient light-weight interface.  Some of the integration tests
    that provide example usage of the Java
    <a href="api.html#Service">CloudI API</a> include:
    <ul>
      <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http/service/org/cloudi/tests/http/Task.java" target="_blank">src/tests/http</a>
          <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http/service/org/cloudi/tests/http/" target="_blank">HTTP Test</a></li>
    </ul>
  </p>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <a name="6_Python"></a>
  <h3>6.4 - Python Service Implementation</h3>
  <p class="paragraph">
    The Python CloudI API provides a simple interface for making Python
    CloudI services.  Some of the integration tests that provide example usage
    of the Python
    <a href="api.html#Service">CloudI API</a> include:
    <ul>
      <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http/service/service.py" target="_blank">src/tests/http</a>
          <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http/" target="_blank">HTTP Test</a></li>
      <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/zeromq/run.py" target="_blank">src/tests/zeromq</a>
          ZeroMQ Test</li>
    </ul>
    An example configuration (from the <a href="https://github.com/CloudI/CloudI/blob/master/src/cloudi.conf.in" target="_blank">default CloudI configuration</a>)
    is provided below:
    <pre>
{external,
    "/tests/http/",
    "@PYTHON@",
    "tests/http/service/service.py",
    [],
    none, default, default,
    5000, 5000, 5000, [api], undefined, 1, 4, 5, 300, []}
    </pre>
  </p>
  <p>
    There are two implementations of the Python CloudI API: a pure-Python
    CloudI API (module "cloudi") and a Python/C CloudI API (module "cloudi_c").
    Just specify the Python library by the module imported, since the same
    interface is provided within both choices.  The "cloudi_c" module has
    been shown to provide a <a href="https://github.com/CloudI/CloudI/raw/master/src/tests/http_req/loadtest/results_v1_1_0/201210_summary.pdf" target="_blank">speedup greater than 400%</a>
    when compared with the "cloudi" module, with both under a load of 10,000
    requests/second.  For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <a name="6_Ruby"></a>
  <h3>6.5 - Ruby Service Implementation</h3>
  <p class="paragraph">
    The Ruby CloudI API provides a simple interface for making Ruby
    CloudI services.  Some of the integration tests that provide example
    usage of the Ruby <a href="api.html#Service">CloudI API</a> include:
    <ul>
      <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http/service/service.rb" target="_blank">src/tests/http</a>
          <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http/" target="_blank">HTTP Test</a></li>
    </ul>
  </p>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <a name="6_HTTP"></a>
  <h3>6.6 - HTTP Integration</h3>
  <p class="paragraph">
    HTTP integration with CloudI services uses service names that have a prefix
    that matches the Uniform Resource Locator (URL) path.  A simple example
    caches static filesystem files recursively so that the file path is
    the service name suffix (with the "/get" HTTP method suffix at the end,
    e.g., "index.html/get").  The example can be found in the <a href="https://github.com/CloudI/CloudI/blob/master/src/cloudi.conf.in" target="_blank">default CloudI configuration</a>
    usage of the <a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_filesystem/src/cloudi_service_filesystem.erl" target="_blank">cloudi_service_filesystem</a> which is shown below:
    <pre>
{internal,
    "/tests/http_req/",
    cloudi_service_filesystem,
    [{directory, "tests/http_req/public_html/"}],
    none,
    5000, 5000, 5000, [api], undefined, 1, 5, 300, []}
    </pre>
    When CloudI is running with this service configuration, the files
    in the path tests/http_req/public_html/ are browsable at <a href="http://127.0.0.1:6464/tests/http_req/" target="_blank">http://127.0.0.1:6464/tests/http_req/</a>.
  </p>
  <p class="paragraph">
    The incoming HTTP traffic goes through the <a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_http_cowboy/src/cloudi_service_http_cowboy.erl" target="_blank">cloudi_service_http_cowboy</a>
    Erlang CloudI service (or <a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_http_elli/src/cloudi_service_http_elli.erl" target="_blank">cloudi_service_http_elli</a>)
    and simply uses the URL path
    to send a request to the subscribing CloudI service, where the prefix of
    the service name was set in the service configuration but the suffix of
    the service name was declared programmatically by calling the CloudI API
    <a href="api.html#1_subscribe">subscribe</a> function.
    cloudi_service_http_cowboy adds the "/get" suffix
    (when configured with "{use_method_suffix, true}", the default)
    on the URL to make the service name for the CloudI service request
    which contains the HTTP request headers in the RequestInfo value of the
    service request (RequestInfo is normally used for key-value service
    request meta-data).
  </p>
  <p class="paragraph">
    Quicker access to static files can be provided by nginx or other simple HTTP
    servers, so this is just an internal service example of CloudI HTTP
    integration (CloudI is normally for dynamic requests that require
    both scalability and fault-tolerance).
  </p>
  <p class="paragraph">
    Other simple HTTP integration examples can be found among the integration
    tests:
    <ul>
      <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http/" target="_blank">src/tests/http HTTP Test</a>
          (with <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http/run.sh" target="_blank">curl file-based test requests</a>
           and <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http/service/service.py" target="_blank">Python</a>/<a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http/service/service.rb" target="_blank">Ruby</a>/<a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http/service/org/cloudi/tests/http/Task.java" target="_blank">Java</a> services)</li>
      <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/" target="_blank">src/tests/http_req HTTP Request Test</a>
          (with a <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/c_src/main.c" target="_blank">C service</a>)</li>
      <li><a href="#4_WebSockets" target="_blank">WebSocket Integration</a></li>
    </ul>
  </p>
  <p class="paragraph">
    To prevent HTTP requests from going to internal services, Access Control
    List (ACL) entries can be added that prevent the cloudi_service_http_cowboy
    Erlang
    CloudI service from sending to the internal services.  The ACL entries
    would be service name patterns that include the internal services in a
    list that is referenced directly (i.e., literally as a list of string) or
    indirectly by an atom that represents the list of strings.  The ACL
    entries would be specified for the cloudi_service_http service
    configuration's deny list.  If service names are named consistently so that
    the service name represents a path which is a destination in a tree or
    hierarchy, then there should be no problems when adding or removing
    services dynamically (since the ACL entries will remain valid for the
    consistent service name pattern usage).  URLs can be matched dynamically
    using <a href="#4_URLregex">service name patterns</a>.
  </p>
  <p class="paragraph">
    The cloudi_service_http_cowboy configuration allows you to specify various
    output formats for the incoming HTTP requests with the "output"
    configuration value.  The possible values are:
  </p>
  <table><tr><td>
    external<br />
    (default)
  </td><td>
    All service request data is Erlang binaries
    (can be sent to either internal or external services) but service
    response data can have ResponseInfo as an Erlang list of two element
    tuples (list({binary(),&nbsp;binary()), convenient within internal services)
  </td></tr><tr><td>
    internal
  </td><td>
    RequestInfo is sent in service requests as an Erlang list of two
    element tuples (list({binary(),&nbsp;binary()), can only be sent to
    internal services)
  </td></tr><tr><td>
    binary
  </td><td>
    All service request and response data are Erlang binaries
    (can be sent to either internal or external services)
  </td></tr><tr><td>
    lists
  </td><td>
    All service request and response data are Erlang lists
    (can only be sent to internal services)
  </td></tr></table>
  <p>
    For more information, please refer to <a href="#4_API_HTTP">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <a name="6_ZeroMQ"></a>
  <h3>6.7 - ZeroMQ Integration</h3>
  <p class="paragraph">
    <a href="http://www.zeromq.org/" target="_blank">ZeroMQ</a>
    integration is provided by the cloudi_service_zeromq Erlang CloudI service.
    The CloudI configuration uses the cloudi_service_zeromq service to create
    service names that represent ZeroMQ messaging endpoints.  There are three
    ZeroMQ configuration examples in the <a href="https://github.com/CloudI/CloudI/blob/master/src/cloudi.conf.in" target="_blank">default CloudI configuration</a>
    which are (partially) shown below:
    <pre>
% Zig-Zag test
{internal,
    "/tests/zeromq/",
    % inbound/outbound message paths much be acyclic
    % (if they are not, you will receive a erlzmq EFSM error
    %  because the ZeroMQ REQ has received 2 zmq_send calls)
    cloudi_service_zeromq,
    % outbound ZeroMQ requests connect a CloudI name to a ZeroMQ endpoint
    [{outbound, {"zigzag_start", ["ipc:///tmp/cloudizigzagstart"]}},
    % inbound ZeroMQ replies connect a ZeroMQ endpoint to a CloudI name
     {inbound, {"zigzag_step1", ["ipc:///tmp/cloudizigzagstart"]}},
     {outbound, {"zigzag_step1", ["inproc://zigzagstep1"]}},
     {inbound, {"zigzag_step2", ["inproc://zigzagstep1"]}},
    % ZeroMQ publish connects a CloudI name to a ZeroMQ (subscribe) name
    % as {CloudI name (suffix), ZeroMQ name for message prefix}
    % for any number of endpoints
     {publish, {[{"zigzag_step2", "/zeromq/step2"}],
                ["inproc://zigzagstep2a",
                 "ipc:///tmp/cloudizigzagstep2b",
                 "inproc://zigzagstep2c",
                 "ipc:///tmp/cloudizigzagstep2d"]}},
    % ZeroMQ subscribe connects a CloudI name to a ZeroMQ (subscribe) name
    % as {CloudI name (suffix), ZeroMQ name for subscribe setsocketopt}
    % for any number of endpoints
     {subscribe, {[{"zigzag_step3a", "/zeromq/step2"},
                   {"zigzag_step3b", "/zeromq/step2"}],
                  ["inproc://zigzagstep2a",
                   "ipc:///tmp/cloudizigzagstep2b",
                   "inproc://zigzagstep2c",
                   "ipc:///tmp/cloudizigzagstep2d"]}},
     {outbound, {"zigzag_step3a", ["inproc://zigzagstep3"]}},
     {inbound, {"zigzag_finish", ["inproc://zigzagstep3"]}}],
    immediate_closest,
    5000, 5000, 5000, [api], undefined, 2, 5, 300, []},
% Chain inproc test (50 endpoints in a sequential call path)
{internal,
    "/tests/zeromq/",
    cloudi_service_zeromq,
    [{outbound, {"chain_inproc_start", ["inproc://chainstep1"]}},
     {inbound, {"chain_inproc_step1", ["inproc://chainstep1"]}},
     {outbound, {"chain_inproc_step1", ["inproc://chainstep2"]}},
     {inbound, {"chain_inproc_step2", ["inproc://chainstep2"]}},
...
     {outbound, {"chain_inproc_step48", ["inproc://chainstep49"]}},
     {inbound, {"chain_inproc_step49", ["inproc://chainstep49"]}},
     {outbound, {"chain_inproc_step49", ["inproc://chainstep50"]}},
     {inbound, {"chain_inproc_finish", ["inproc://chainstep50"]}}],
    immediate_closest,
    5000, 5000, 5000, [api], undefined, 2, 5, 300, []},
% Chain ipc test (25 endpoints in a sequential call path)
{internal,
    "/tests/zeromq/",
    cloudi_service_zeromq,
    [{outbound, {"chain_ipc_start", ["ipc:///tmp/cloudichainstep1"]}},
     {inbound, {"chain_ipc_step1", ["ipc:///tmp/cloudichainstep1"]}},
     {outbound, {"chain_ipc_step1", ["ipc:///tmp/cloudichainstep2"]}},
     {inbound, {"chain_ipc_step2", ["ipc:///tmp/cloudichainstep2"]}},
...
     {outbound, {"chain_ipc_step23", ["ipc:///tmp/cloudichainstep24"]}},
     {inbound, {"chain_ipc_step24", ["ipc:///tmp/cloudichainstep24"]}},
     {outbound, {"chain_ipc_step24", ["ipc:///tmp/cloudichainstep25"]}},
     {inbound, {"chain_ipc_finish", ["ipc:///tmp/cloudichainstep25"]}}],
    immediate_closest,
    5000, 5000, 5000, [api], undefined, 2, 5, 300, []}
    </pre>
  </p>
  <p class="paragraph">
  The three cloudi_service_zeromq Erlang CloudI services are used by the
  <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/zeromq/run.py" target="_blank">ZeroMQ integration test</a>
  to test the ZeroMQ messaging when the integration test service starts.
  ZeroMQ configuration within CloudI is dynamic through usage of the Service
  API.  For more information, please refer to <a href="#4_API_ZeroMQ">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <a name="6_FaultTolerance"></a>
  <h3>6.8 - Service Fault-Tolerance</h3>
  <p class="paragraph">
    General fault-tolerance considerations within the CloudI framework are
    described in <a href="#5_Stability">"5.3 - Stability and Fault-Tolerance Considerations"</a>.
    State migration is not necessary for fault-tolerance within the
    CloudI framework, as explained in <a href="#4_ServiceFail">"4.8 - How do I Migrate a Service from a Failed or Failing Node?"</a>.
    Instead, multiple service instances are used to ensure redundancy
    provides system fault-tolerance.
  </p>
  <p class="paragraph">
    An example of <a href="http://en.wikipedia.org/wiki/Byzantine_fault_tolerance" target="_blank">Byzantine fault-tolerance</a>
    which can be used with any CloudI service requests is provided as <a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_quorum/src/cloudi_service_quorum.erl" target="_blank">cloudi_service_quorum</a>.
    The cloudi_service_quorum uses its configured service name prefix it
    was started with to match any incoming service requests
    (i.e., any service names that match the prefix) which it proxies with
    mcast_async_active to all available service name destinations, using
    the suffix that was matched.  So, if cloudi_service_quorum was started
    with the prefix "/byzantine", like the example found in the <a href="https://github.com/CloudI/CloudI/blob/master/src/cloudi.conf.in" target="_blank">default CloudI configuration</a>:
    <pre>
    {internal,
        "/byzantine",
        cloudi_service_quorum,
        [{quorum, byzantine}],
        immediate_closest,
        5000, 5000, 5000, undefined, undefined, 1, 5, 300, []}
    </pre>
    then all service requests that match the "/byzantine*" service name pattern
    will be sent with mcast_async_active to the suffix matched by "*".
    When the quorum configuration is set to 'byzantine', it makes sure that
    less than 1/3rd of the responses are erroneous (or timeouts) before
    responding to the original cloudi_service_quorum service request.
    However, the 'byzantine' setting (the default) requires that at least
    4 destination service processes exist, otherwise the original
    cloudi_service_quorum service request will timeout.  The quorum can also
    be configured as a percentage of the total available destination service
    processes or as an absolute integer count of required destination service
    processes.
  </p>
  <p class="paragraph">
    For system fault-tolerance testing, the system configuration
    options <a href="api.html#2_services_add_config_opts_monkey_latency">monkey_latency</a>
    and <a href="api.html#2_services_add_config_opts_monkey_chaos">monkey_chaos</a>
    can be used to simulate failures.  The simulated failures can then be used
    with higher-level processing to make sure the system remains robust
    during the internal failures (i.e., to prove system fault-tolerance
    during higher-level system testing).
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <hr \>
  <h2>7 - Databases</h2>

  <a name="7_CouchDB"></a>
  <h3>7.1 - CouchDB Integration</h3>
  <p class="paragraph">
    The cloudi_service_db_couchdb internal service accepts requests from other
    CloudI services.  The service expects database commands supplied as
    Erlang tuples or atoms.  When the service receives data from an external
    service the data received is binary and should be a string that contains
    Erlang terms that is the database command.  The command result is
    returned as binary to an external service.  An internal service can
    send the command as Erlang terms and will receive Erlang terms for the
    result.  The service name used to communicate with the database is the
    configured database service name prefix with the database name appended
    (i.e., "/db/couchdb/cloudi_tests" in the example below).
  </p>
  <p class="paragraph">
    An example configuration for a single database that is represented as a
    single service is below:
<pre>
    {internal,
        "/db/couchdb/",
        cloudi_service_db_couchdb,
        [{database, "cloudi_tests"},
         {timeout, 20000}, % ms
         {hostname, "127.0.0.1"},
         {port, 5984}],
        none,
        5000, 5000, 5000, undefined, undefined, 1, 5, 300, []}
</pre>
  </p>
  <div class="top"><a href="#7_contents">Top</a></div>

  <a name="7_memcached"></a>
  <h3>7.2 - memcached Integration</h3>
  <p class="paragraph">
    The cloudi_service_db_memcached internal service accepts requests from other
    CloudI services.  The service expects database commands supplied as
    Erlang tuples or atoms.  When the service receives data from an external
    service the data received is binary and should be a string that contains
    Erlang terms that is the database command.  The command result is
    returned as binary to an external service.  An internal service can
    send the command as Erlang terms and will receive Erlang terms for the
    result.  The service name used to communicate with the database is the
    configured database service name prefix with the database name appended
    (i.e., "/db/memcached/cloudi_tests" in the example below).
  </p>
  <p class="paragraph">
    An example configuration for a single database that is represented as a
    single service is below:
<pre>
    {internal,
        "/db/memcached/",
        cloudi_service_db_memcached,
        [{database, "cloudi_tests",
          [{"127.0.0.1", 11211, 1}]}],
        none,
        5000, 5000, 5000, undefined, undefined, 1, 5, 300, []}
</pre>
    The list of host-port-connection_count tuples is used for providing
    <a href="http://amarok.kde.org/blog/archives/363-libketama-a-consistent-hashing-algo-for-memcache-clients.html" target="_blank">continuum hashing</a>
    of database keys.  Using continuum hashing avoids rehashing all the keys
    (i.e., cached-misses) when a memcached node fails.
  </p>
  <div class="top"><a href="#7_contents">Top</a></div>

  <a name="7_MySQL"></a>
  <h3>7.3 - MySQL Integration</h3>
  <p class="paragraph">
    The cloudi_service_db_mysql internal service accepts requests from other
    CloudI services.  The service expects SQL input and provides the query
    result either as an Erlang tuple or as binary encoded data based on whether
    the input was binary or a list.  All data coming from external services
    is received as binary and is returned as binary that can be used to
    determine the result of a query.  Internal services are able to send SQL
    as an Erlang list and will then receive a tuple from the database driver
    that is the result of the query.  The service name used to communicate
    with the database is the configured database service name prefix with
    the database name appended (i.e., "/db/mysql/cloudi_tests" in the example
    below).
  </p>
  <p class="paragraph">
    An example configuration for a single database that is represented as a
    single service is below:
<pre>
    {internal,
        "/db/mysql/",
        cloudi_service_db_mysql,
        [{database, "cloudi_tests"},
         {timeout, 20000}, % ms
         {encoding, utf8},
         {hostname, "127.0.0.1"},
         {username, "cloudi"},
         {password, "XXXXXXXXX"},
         {port, 3306}],
        none,
        5000, 5000, 5000, undefined, undefined, 1, 5, 300, []}
</pre>
  </p>
  <div class="top"><a href="#7_contents">Top</a></div>

  <a name="7_PostgreSQL"></a>
  <h3>7.4 - PostgreSQL Integration</h3>
  <p class="paragraph">
    The cloudi_service_db_pgsql internal service accepts requests from other
    CloudI services.  The service expects SQL input and provides the query
    result either as an Erlang tuple or as binary encoded data based on whether
    the input was binary or a list.  All data coming from external services
    is received as binary and is returned as binary that can be used to
    determine the result of a query.  Internal services are able to send SQL
    as an Erlang list and will then receive a tuple from the database driver
    that is the result of the query.  The service name used to communicate
    with the database is the configured database service name prefix with
    the database name appended (i.e., "/db/pgsql/cloudi_tests" in the example
    below).
  </p>
  <p class="paragraph">
    An example configuration for a single database that is represented as a
    single service is below:
<pre>
    {internal,
        "/db/pgsql/",
        cloudi_service_db_pgsql,
        [{database, "cloudi_tests"},
         {timeout, 20000}, % ms
         {hostname, "127.0.0.1"},
         {username, "cloudi"},
         {password, "XXXXXXXXX"},
         {port, 5432}],
        none,
        5000, 5000, 5000, undefined, undefined, 1, 5, 300, []}
</pre>
  </p>
  <div class="top"><a href="#7_contents">Top</a></div>

  <a name="7_TokyoTyrant"></a>
  <h3>7.5 - Tokyo Tyrant Integration</h3>
  <p class="paragraph">
    The cloudi_service_db_tokyotyrant internal service accepts requests from
    other CloudI services.  The service expects database commands supplied as
    Erlang tuples or atoms.  When the service receives data from an external
    service the data received is binary and should be a string that contains
    Erlang terms that is the database command.  The command result is
    returned as binary to an external service.  An internal service can
    send the command as Erlang terms and will receive Erlang terms for the
    result.  The service name used to communicate with the database is the
    configured database service name prefix with the database name appended
    (i.e., "/db/tokyotyrant/cloudi_tests" in the example below).
  </p>
  <p class="paragraph">
    An example configuration for a single database that is represented as a
    single service is below:
<pre>
    {internal,
        "/db/tokyotyrant/",
        cloudi_service_db_tokyotyrant,
        [{database, "cloudi_tests"},
         {timeout, 20000}, % ms
         {hostname, "127.0.0.1"},
         {port, 1978}],
        none,
        5000, 5000, 5000, undefined, undefined, 1, 5, 300, []}
</pre>
  </p>
  <div class="top"><a href="#7_contents">Top</a></div>

  <a name="7_Other"></a>
  <h3>7.6 - Other Database Integration</h3>
  <p class="paragraph">
    Other databases can easily be integrated with CloudI.  The best database
    integration uses a database driver implemented completely in Erlang and
    uses a cloudi_service_db_name module to implement CloudI service integration
    with the cloudi_service behavior.  By using a database driver written in
    Erlang the source code is naturally more scalable and fault-tolerant.  If
    the database driver used an Erlang NIF or an Erlang port driver instead,
    the driver would not be isolated from the Erlang VM (though the
    implementation might be more efficient).  The database driver would
    typically communicate with the database by using a socket with TCP.
  </p>
  <p class="paragraph">
    Database integration can be done in other complex ways if required,
    but the integration approach previously mentioned is a typical approach
    used within the CloudI framework.
  </p>
  <div class="top"><a href="#7_contents">Top</a></div>

</div>

</body>
</html>
