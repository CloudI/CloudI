<!DOCTYPE html>
<html lang="en">
<head>
  <title>CloudI: A Cloud at the lowest level - Frequently Asked Questions</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta content="Cloud Framework for fault-tolerant distributed processing with dynamic load balancing" name="description" />
  <meta content="faq, cloud, private cloud, framework, erlang, fault tolerant, distributed systems, embarrassingly parallel, divide and conquer, cloudi" name="keywords" />
  <meta content="global" name="distribution" />
  <script src="style.js"></script>
  <link rel="stylesheet" type="text/css" href="style.css" />
  <link rel="shortcut icon" href="images/cloud.ico" type="image/x-icon" />
  <!-- Open Graph Protocol (OGP) with LinkedIn requirements -->
  <meta property="og:title" content="CloudI: A Cloud at the lowest level - Frequently Asked Questions" />
  <meta property="og:description" content="CloudI is an open-source private cloud computing framework for efficient, secure, and internal data processing. CloudI provides scaling for previously unscalable source code with efficient fault-tolerant execution of ATS, C/C++, Erlang/Elixir, Go, Haskell, Java, JavaScript/node.js, OCaml, Perl, PHP, Python, Ruby, or Rust services.

The bare essentials for efficient fault-tolerant processing on a cloud!" />
  <meta property="og:image" content="https://cloudi.org/images/cloud_ogp.png" />
  <meta property="og:url" content="https://cloudi.org/faq.html" />
  <meta property="og:type" content="website" />
</head>
<body>

<div id="header">
<a href="https://cloudi.org/">
Cloud<span style="font-family:serif">I</span><img alt="Active Cloud" width="156" height="106" src="images/cloud.png" />
</a>
</div>
<br />
<div id="navigation">
  <ul>
    <li><a href="index.html">QUICKSTART</a></li>
    <li><a href="api.html">API</a></li>
    <li><a href="faq.html" class="active">FAQ</a></li>
    <li><a href="tutorials.html">Tutorials</a>
        (<a href="tutorial_java.html">Java</a>)</li>
    <li><a href="https://osdn.net/dl/cloudi/cloudi-2.0.6.tar.gz" rel="noopener" target="_blank">Download</a></li>
    <li><a href="https://github.com/CloudI/CloudI/tree/develop#readme">Source</a></li>
    <li><a href="support.html">Support</a></li>
  </ul>
</div>

<div id="content">
  <h1>Frequently Asked Questions</h1>
  <h3 style="text-align:center">version 2.0.6<br />
  last updated on June 21<sup>st</sup> 2023</h3>

  <h2 id="1_contents">1 - Introduction to CloudI</h2>
  <ul class="faq">
    <li><a href="#1_Name"         >1.1 - Why is it named "Cloud<span style="font-family:serif">I</span>"?</a></li>
    <li><a href="#1_Pronounce"    >1.2 - How is CloudI pronounced?</a></li>
    <li><a href="#1_Clouds"       >1.3 - How does CloudI compare to other "Clouds"?</a></li>
    <li><a href="#1_Messaging"    >1.4 - How does CloudI compare to other open source messaging?</a></li>
    <li><a href="#1_WhatIs"       >1.5 - What is CloudI?</a></li>
    <li><a href="#1_OS"           >1.6 - On what Operating Systems does CloudI run?</a></li>
    <li><a href="#1_Commercial"   >1.7 - Is Commercial support available for CloudI?</a></li>
    <li><a href="#1_ReallyFree"   >1.8 - Is CloudI really free?</a></li>
    <li><a href="#1_WhoDevelops"  >1.9 - Who develops CloudI?</a></li>
    <li><a href="#1_PrivateCloud" >1.10 - Can I use CloudI as a Private Cloud?</a></li>
    <li><a href="#1_OnlineService">1.11 - Can I use CloudI as an Online Service?</a></li>
    <li><a href="#1_CAP"          >1.12 - What CAP theorem guarantees does CloudI provide?</a></li>
    <li><a href="#1_Actor"        >1.13 - Does CloudI provide an implementation of the Actor Model?</a></li>
    <li><a href="#1_REST"         >1.14 - Does CloudI support REST?</a></li>
    <li><a href="#1_SOA"          >1.15 - Does CloudI provide a Service-Oriented Architecture (SOA)</a></li>
    <li><a href="#1_Microservices">1.16 - Does CloudI provide a Microservice Architecture?</a></li>
    <li><a href="#1_Reactive"     >1.17 - Is CloudI Reactive?</a></li>
    <li><a href="#1_Sagas"        >1.18 - Does CloudI support Sagas?</a></li>
    <li><a href="#1_HowAbout"     >1.19 - Why doesn't CloudI integrate with ProductX?</a></li>
  </ul>
  <h2 id="2_contents">2 - Learning about CloudI</h2>
  <ul class="faq">
    <li><a href="#2_WebPages"      >2.1 - Web Pages</a></li>
    <li><a href="#2_MailingList"   >2.2 - Mailing List</a></li>
    <li><a href="#2_IRC"           >2.3 - Internet Relay Chat (IRC)</a></li>
    <li><a href="#2_RSS"           >2.4 - RSS Feeds</a></li>
    <li><a href="#2_Twitter"       >2.5 - Twitter</a></li>
    <li><a href="#2_Presentations" >2.6 - Presentations</a></li>
    <li><a href="#2_Articles"      >2.7 - Articles</a></li>
    <li><a href="#2_ReportingBugs" >2.8 - Reporting Bugs</a></li>
    <li><a href="#2_CodeOfConduct" >2.9 - Code of Conduct</a></li>
  </ul>
  <h2 id="3_contents">3 - CloudI Installation Guide</h2>
  <ul class="faq">
    <li><a href="#3_Overview"    >3.1 - Overview</a></li>
    <li><a href="#3_Options"     >3.2 - Installation Options</a></li>
    <li><a href="#3_OSX"         >3.3 - OS X Installation</a></li>
    <li><a href="#3_Running"     >3.4 - Running CloudI</a></li>
    <li><a href="#3_Config"      >3.5 - Configuration</a></li>
  </ul>
  <h2 id="4_contents">4 - General Questions</h2>
  <ul class="faq">
    <li><a href="#4_API"        >4.1 - How do I integrate external software with CloudI?</a></li>
    <li><a href="#4_ServiceAPI" >4.2 - How do I control CloudI dynamically?</a></li>
    <li><a href="#4_PubSub"     >4.3 - How do I use Publisher/Subscriber messaging?</a></li>
    <li><a href="#4_RPC"        >4.4 - How do I use Remote Procedure Calls (RPC)?</a></li>
    <li><a href="#4_WebServices">4.5 - How do I create Web Services?</a></li>
    <li><a href="#4_WebSockets" >4.6 - Does CloudI support WebSockets?</a></li>
    <li><a href="#4_ACLs"       >4.7 - How do I use Access Control Lists (ACLs)?</a></li>
    <li><a href="#4_ServiceFail">4.8 - How do I Migrate a Service from a Failed or Failing Node?</a></li>
    <li><a href="#4_URLregex"   >4.9 - Can I use Regular Expressions with Service Names (URLs)?</a></li>
    <li><a href="#4_NamePattern">4.10 - How do Service Name Patterns work?</a></li>
    <li><a href="#4_ThreadSafe" >4.11 - Is the CloudI API thread-safe?</a></li>
    <li><a href="#4_Speed"      >4.12 - How can CloudI requests take advantage of cache coherency, minimum network latency, and any logical grouping?</a></li>
    <li><a href="#4_Erlang"     >4.13 - Why not just use Erlang directly?</a></li>
    <li><a href="#4_Null"       >4.14 - What is a null response (How do timeouts occur)?</a></li>
  </ul>
  <h2 id="5_contents">5 - Migrating to CloudI</h2>
  <ul class="faq">
    <li><a href="#5_Performance">5.1 - Performance Considerations</a></li>
    <li><a href="#5_Scalability">5.2 - Scalability Considerations</a></li>
    <li><a href="#5_Stability"  >5.3 - Stability and Fault Tolerance Considerations</a></li>
    <li><a href="#5_Integration">5.4 - Integration Considerations</a></li>
    <li><a href="#5_LoadTesting">5.5 - Load Testing</a></li>
  </ul>
  <h2 id="6_contents">6 - Services</h2>
  <ul class="faq">
    <li><a href="#6_ATS"        >6.1 - ATS Service Implementation</a></li>
    <li><a href="#6_C"          >6.2 - C/C++ Service Implementation</a></li>
    <li><a href="#6_Erlang"     >6.3 - Erlang Service Implementation</a></li>
    <li><a href="#6_Go"         >6.4 - Go Service Implementation</a></li>
    <li><a href="#6_Haskell"    >6.5 - Haskell Service Implementation</a></li>
    <li><a href="#6_Java"       >6.6 - Java Service Implementation</a></li>
    <li><a href="#6_JavaScript" >6.7 - JavaScript/node.js Service Implementation</a></li>
    <li><a href="#6_OCaml"      >6.8 - OCaml Service Implementation</a></li>
    <li><a href="#6_Perl"       >6.9 - Perl Service Implementation</a></li>
    <li><a href="#6_PHP"        >6.10 - PHP Service Implementation</a></li>
    <li><a href="#6_Python"     >6.11 - Python Service Implementation</a></li>
    <li><a href="#6_Ruby"       >6.12 - Ruby Service Implementation</a></li>
    <li><a href="#6_Rust"       >6.13 - Rust Service Implementation</a></li>
    <li><a href="#6_HTTP"       >6.14 - HTTP Integration</a></li>
    <li><a href="#6_FaultTolerance">6.15 - Service Fault Tolerance</a></li>
    <li><a href="#6_Monitoring" >6.16 - Service Monitoring</a></li>
  </ul>
  <h2 id="7_contents">7 - Troubleshooting</h2>
  <ul class="faq">
    <li><a href="#7_start"      >7.1 - Why does CloudI stop shortly after being started?</a></li>
    <li><a href="#7_slow"       >7.2 - Why is CloudI making my Linux machine slow?</a></li>
    <li><a href="#7_install"    >7.3 - Why does my container or guest VM installation of CloudI have problems?</a></li>
    <li><a href="#7_cpu"        >7.4 - How can I control the CPU utilization of CloudI?</a></li>
  </ul>

  <hr>
  <h2>1 - Introduction to CloudI</h2>

  <h3 id="1_Name">1.1 - Why is it named "Cloud<span style="font-family:serif">I</span>"?</h3>
  <p class="paragraph">
    A <strong>Cloud</strong> is more dynamic than a 3 dimensional
    <strong>Grid</strong> and is more ubiquitous than the legend of 
    <strong>Beowulf</strong>, so it is easy to understand why computing Clouds 
    are the next generation distributed systems.  The relevant connotations the 
    word Cloud contains are: dynamic, supervision, intermingle, and points 
    (i.e., point clouds).  Any computing Cloud should offer dynamic
    configuration, should supervise processes in a fault-tolerant way,
    offer easy integration and should support an arbitrarily large number
    of processes (respectively).  This project offers Cloud functionality
    facilitated by <a href="https://en.wikipedia.org/wiki/Erlang_%28programming_language%29" rel="noreferrer" target="_blank">Erlang</a>.
  </p>
  <p class="paragraph">
    CloudI has an "<span style="font-family:serif">I</span>" suffix for
    several connotations: cloudy, one, interface, and independence.
    CloudI is referred to as "A Cloud as an Interface" because
    a light-weight interface facilitates Cloud functionality.
    The interface supports multiple programming languages and is called the
    <a href="api.html#Service" target="_blank">CloudI API</a>.
    CloudI supports private cloud development and deployment,
    so only one Cloud is necessary for Cloud functionality with implicit
    security.  CloudI is also able to facilitate online services and offers
    extreme connection scalability.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_Pronounce">1.2 - How is CloudI pronounced?</h3>
  <p class="paragraph">
    As "cloud-e" /kla&#650;di/ (think: Cloud <a href="https://en.wikipedia.org/wiki/Erlang_%28programming_language%29" rel="noreferrer" target="_blank">Erlang</a>).
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_Clouds">1.3 - How does CloudI compare to other "Clouds"?</h3>

  <h4>Hypervisor "Clouds"</h4>
  <p class="paragraph">
    Hypervisor "Clouds" are the most popular type of Cloud because any
    <a href="https://en.wikipedia.org/wiki/Legacy_software" rel="noreferrer" target="_blank">legacy</a>
    source code can be put into an image (or container)
    to reduce the resources required.
    The <a href="https://en.wikipedia.org/wiki/Hypervisors" rel="noreferrer" target="_blank">Hypervisor</a>
    has existed since 1965 when software was used on the IBM 360/65 to
    emulate an IBM 7080 with computation time split between the separate modes.
    Modern Hypervisors provide Operating System virtualization to more
    fully utilize hardware resources.  Using virtualization can provide
    easier management of a <a href="https://en.wikipedia.org/wiki/Monolithic_system" rel="noreferrer" target="_blank">Monolithic Architecture</a>
    so the source code's limitations can be managed without software
    development and are instead an <a href="https://en.wikipedia.org/wiki/Information_management#Operationalising_Information_Management" rel="noreferrer" target="_blank">operations</a> concern.
  </p>

  <h4>CloudI as a “Programming Model for Cloud Computing”</h4>
  <p class="paragraph">
    CloudI was classified as a "Programming Model for Cloud Computing" in the
    book: <a href="https://www.amazon.com/Essentials-Cloud-Computing-K-Chandrasekaran/dp/1482205432" rel="noreferrer" target="_blank">Chandrasekaran, K. "Essentials of Cloud Computing". Chapman and Hall/CRC, 2014. ISBN 978-1-4822-0543-5 (p198-199)</a>.
    While the book does have various errors, it is a significant effort to
    classify all the forms of Cloud Computing.  CloudI use does require
    software development for using the CloudI API which allows CloudI to
    function as an application server and messaging bus with the
    developed source code isolated within a service.  However, CloudI
    usage can exist with or without virtualization, offering both
    development and deployment flexibility.
  </p>
  <p class="paragraph">
    CloudI does not require using a particular online service and can be
    deployed without an Internet connection on an <a href="https://en.wikipedia.org/wiki/Air_gap_%28networking%29" rel="noreferrer" target="_blank">airgap network</a>
    if security is required.  Scalability and fault tolerance are both
    provided by CloudI's usage of the <a href="https://en.wikipedia.org/wiki/Erlang_%28programming_language%29" rel="noreferrer" target="_blank">Erlang programming language</a>.
    Scalability is a natural gain with CloudI's Erlang
    concurrency which reduces the amount of power and hardware necessary
    for concurrent processing.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_Messaging">1.4 - How does CloudI compare to other open source messaging?</h3>
  <table><tr><td>
  </td><td>
  CloudI (core)
  </td><td>
  <a href="https://zeromq.org/" rel="noreferrer" target="_blank">ZeroMQ</a>
  </td><td>
  <a href="https://zookeeper.apache.org/" rel="noreferrer" target="_blank">Apache Zookeeper</a>
  </td><td>
  <a href="https://kafka.apache.org/" rel="noreferrer" target="_blank">Apache Kafka</a>
  </td><td>
  <a href="https://rabbitmq.com/" rel="noreferrer" target="_blank">RabbitMQ</a>
  </td></tr><tr><td>
  <a href="https://en.wikipedia.org/wiki/CAP_theorem" rel="noreferrer" target="_blank">CAP Theorem</a>
  </td><td>
  AP
  </td><td>
  AP
  </td><td>
  CP
  </td><td>
  CA
  </td><td>
  CA
  </td></tr><tr><td>
  Netsplits do not cause data loss
  </td><td>
  X
  </td><td>
  X
  </td><td>
  X
  </td><td>

  </td><td>

  </td></tr><tr><td>
  In&#8209;memory transactions for minimum latency and maximum concurrency
  </td><td>
  X
  </td><td>

  </td><td>

  </td><td>

  </td><td>

  </td></tr><tr><td>
  Uniquely identifies transactions
  </td><td>
  X
  </td><td>

  </td><td>
  X
  </td><td>
  X
  </td><td>
  X
  </td></tr><tr><td>
  Brokerless communication for minimum latency
  </td><td>
  X
  </td><td>
  X
  </td><td>
  
  </td><td>
  
  </td><td>

  </td></tr><tr><td>
  Publish/Subscribe/RPC
  </td><td>
  X
  </td><td>
  X
  </td><td>
  
  </td><td>
  X
  </td><td>
  X
  </td></tr><tr><td>
  <a href="#1_SOA">Protocol agnostic</a>
  </td><td>
  X
  </td><td>

  </td><td>
  
  </td><td>

  </td><td>

  </td></tr><tr><td>
  Complete transaction fault&#8209;tolerance is provided within an application server
  </td><td>
  X
  </td><td>

  </td><td>
  
  </td><td>

  </td><td>

  </td></tr><tr><td>
  Execution thread fault&#8209;tolerance granularity
  </td><td>
  X
  </td><td>

  </td><td>
  
  </td><td>

  </td><td>

  </td></tr><tr><td>
  Open Source license
  </td><td>
  MIT
  </td><td>
  LGPL
  </td><td>
  Apache
  </td><td>
  Apache
  </td><td>
  Mozilla Public
  </td></tr></table>
  <p class="paragraph">
    CloudI is for <a href="https://en.wikipedia.org/wiki/Online_transaction_processing" rel="noreferrer" target="_blank">Online Transaction Processing (OLTP)</a>
    where a transaction may not require database storage
    (transient or cached data may allow the transaction to complete).
    The processing of in-memory transactions is important for keeping
    processing fault-tolerant so that errors are not persisted.
    To pursue <a href="https://en.wikipedia.org/wiki/Fail-fast" rel="noreferrer" target="_blank">fail-fast</a>
    design of fault-tolerant systems, a transaction's data would only be
    persisted if it has passed all validation and business logic successfully.
  </p>
  <p class="paragraph">
    CloudI provides fault tolerance on logic before a transaction is sent
    for extreme reliability.  Other messaging methods are only able to
    timeout before the transaction is created without a way to escalate the
    failure using fault tolerance constraints.
  </p>
  <p>
    The fault tolerance constraints that CloudI provides are:
  </p>
  <table><tr><td>
    initialization timeout
  </td><td>
    for startup validation
  </td></tr><tr><td>
    transaction timeouts
  </td><td>
    for individual transactions
  </td></tr><tr><td>
    termination timeout
  </td><td>
    for deterministic shutdowns
  </td></tr><tr><td>
    MaxR/MaxT
  </td><td>
    maximum restarts within a time period for any crashes within a
    service instance process<br />
    (a user-level or kernel-level thread)
  </td></tr></table>
  <p class="paragraph">
    To make CloudI service requests durable (stored on the filesystem
    during the lifetime of the transaction), the service requests can
    be sent through
    <a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_queue/src/cloudi_service_queue.erl" rel="noopener" target="_blank">cloudi_service_queue</a>
    to handle either a destination failure or both a source failure and
    destination failure (based on the 'fault_isolation' configuration
    argument being either 'destination' or 'both').
  </p>
  <p class="paragraph">
    To make CloudI service requests consistent across multiple
    service instances, the service requests can be sent through
    <a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_quorum/src/cloudi_service_quorum.erl" rel="noopener" target="_blank">cloudi_service_quorum</a>.
    The service request responses will be checked to ensure the responses
    pass the initialized quorum requirement and the service request will
    fail (providing a <a href="faq.html#4_Null">null response</a>)
    if quorum is not obtained during the service request timeout period.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_WhatIs">1.5 - What is CloudI?</h3>
  <h4>Short Answer</h4>
  <p class="paragraph">
    A distributed application server that provides efficient messaging
    for many programming languages within a single service abstraction
    that is both scalable and fault-tolerant.
  </p>
  <h4>Shorter Answer</h4>
  <p class="paragraph">
    A rock-solid transaction processing system for
    flexible software development.
  </p>
  <h4>Shortest Answer</h4>
  <p class="paragraph">
    A Cloud at the lowest level.
  </p>
  <h4>Long Answer</h4>
  <p class="paragraph">
    CloudI is an implementation of <a href="#1_Name">Cloud functionality</a>
    that can be developed and deployed publicly or privately.  CloudI provides
    a simple server back-end that can be used for infrastructure development
    of data processing systems, event processing systems, web services, and
    combinations thereof.  CloudI is a system that enforces <a href="https://en.wikipedia.org/wiki/Representational_State_Transfer" rel="noreferrer" target="_blank">RESTful development practices</a>
    and provides a <a href="https://en.wikipedia.org/wiki/Service_oriented_architecture" rel="noreferrer" target="_blank">Service Oriented Architecture (SOA)</a>.
    CloudI services communicate with messaging that can be controlled by simple
    Access Control List (ACL) entries (to provide service communication
    isolation).
  </p>
  <p class="paragraph">
    CloudI was architected to easily integrate with other services, software,
    and frameworks.  The <a href="api.html#Service">CloudI API</a>
    provides a light-weight interface for
    creating services in ATS, C++/C, Elixir, Erlang, Go, Haskell, Java,
    JavaScript, OCaml, Perl, PHP, Python, Ruby, and Rust.  By using
    CloudI, external software can become more scalable and fault-tolerant
    by utilizing CloudI's load balancing of CloudI requests.  CloudI
    messaging enforces realtime constraints using timeouts, so that request
    failures can be handled locally within the service where they are most
    relevant.  ACL entries explicitly allow or deny communication between
    services and are a simple method of isolating critical services from
    potentially volatile services.  All CloudI API usage in languages other
    than Erlang receive the isolation of Operating System processes
    and are called external services.  External services can utilize the
    CloudI API with any threading library to achieve greater scalability and
    reduce internal latency.  The Erlang/Elixir CloudI API is used to create
    internal services which utilize light-weight Erlang processes.
    <a href="#6_contents">Examples of using the CloudI API</a>
    are provided as integration tests or internal services.
  </p>
  <p class="paragraph">
    The <a href="api.html#CloudI">CloudI Service API</a>
    provides dynamic configuration which is accessible from any
    allowed CloudI service (i.e., allowed based on the ACL entries).  The
    CloudI Service API is accessible remotely by using Erlang terms or JSON-RPC
    over HTTP when using the cloudi_service_api_requests service with the
    cloudi_service_http_cowboy service.
    <a href="https://github.com/CloudI/CloudI/tree/master/src/service_api#readme" rel="noopener" target="_blank">Examples of using the CloudI Service API</a>
    are provided as separate integration tests.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_OS">1.6 - On what Operating Systems does CloudI run?</h3>
  <p class="paragraph">
    CloudI runs on UNIX-based operating systems like Linux (<a href="https://ubuntu.com/" rel="noreferrer" target="_blank">Ubuntu</a>, etc.)
    and BSDs (<a href="https://www.freebsd.org/" rel="noreferrer" target="_blank">FreeBSD</a>, <a href="https://www.openbsd.org/" rel="noreferrer" target="_blank">OpenBSD</a>, <a href="https://netbsd.org/" rel="noreferrer" target="_blank">NetBSD</a>, <a href="https://en.wikipedia.org/wiki/MacOS" rel="noreferrer" target="_blank">macOS</a>, etc.).
    CloudI development has primarily taken place on Ubuntu and other
    Operating Systems may not be completely tested yet.
  </p>
  <p class="paragraph">
    <a href="https://www.erlang.org/doc/installation_guide/install" rel="noreferrer" target="_blank">Erlang</a>
    must be able to run on the system for CloudI to function properly.
    So, checking Erlang support would be a good place to start if you are
    experimenting with a different Operating System.  The information here
    will be updated as more Operating Systems are tested.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_Commercial">1.7 - Is Commercial support available for CloudI?</h3>
  <ul>
    <li>Integration Development</li>
    <li>Operations Maintenance</li>
  </ul>
  <p>
    Contact <a href="mailto:mjtruog(at)protonmail;dot;com">Michael Truog</a>
    if you are interested in commercial CloudI support.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_ReallyFree">1.8 - Is CloudI really free?</h3>
  <p class="paragraph">
    CloudI is completely free.  CloudI uses a <a href="LICENSE.txt" target="_blank">MIT license</a>
    which permits reuse for personal or commercial purposes.
    All external source code dependencies are also under a
    commercial-friendly license
    (<a href="https://en.wikipedia.org/wiki/MIT_License" rel="noreferrer" target="_blank">MIT</a>,
     <a href="https://en.wikipedia.org/wiki/Apache_License" rel="noreferrer" target="_blank">Apache</a>).
    Some dependencies used for building and testing use the GPL license
    (autoconf/automake/libtool, autoconf macros, and
     <a href="http://proper.softlab.ntua.gr/" rel="noreferrer" target="_blank">PropEr</a>).
    For a more detailed look at the licenses of external dependencies,
    please check the <a href="https://github.com/CloudI/CloudI/blob/master/src/external/README.markdown#readme" rel="noopener" target="_blank">src/external/README</a>
    dependency list or the <a href="https://github.com/CloudI/CloudI/blob/master/src/NOTICE" rel="noopener" target="_blank">src/NOTICE</a> license list.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_WhoDevelops">1.9 - Who develops CloudI?</h3>
  <p class="paragraph">
    <a href="mailto:mjtruog(at)protonmail;dot;com">Michael Truog</a>
    <a href="https://github.com/CloudI/CloudI/blob/master/src/AUTHORS" rel="noopener" target="_blank">and others</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_PrivateCloud">1.10 - Can I use CloudI as a Private Cloud?</h3>
  <p class="paragraph">
    Yes!  CloudI provides everything for running a Cloud in isolation
    (i.e., without a connection to the Internet).  For more details,
    please refer to <a href="#1_WhatIs">"1.5 - What is CloudI?"</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_OnlineService">1.11 - Can I use CloudI as an Online Service?</h3>
  <p class="paragraph">
    Yes!  CloudI accepts incoming HTTP traffic and can be easily extended
    to handle other incoming protocols.  For more details,
    please refer to <a href="#1_WhatIs">"1.5 - What is CloudI?"</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_CAP">1.12 - What CAP theorem guarantees does CloudI provide?</h3>
  <p class="paragraph">
    CloudI is an <a href="https://en.wikipedia.org/wiki/CAP_theorem" rel="noreferrer" target="_blank">AP-type distributed system</a>
    (guarantees of Availability and Partition tolerance). A Consistency
    guarantee (the guarantee not provided by CloudI) can be provided
    by a database that is used within a CloudI service.  All CloudI
    <a href="api.html#Service">service requests</a> are transactional
    and a service request response may be used to confirm any state change.
    To understand consistency, as it relates to CloudI service
    fault tolerance, please refer to <a href="#6_FaultTolerance">"6.15 - Service Fault Tolerance"</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_Actor">1.13 - Does CloudI provide an implementation of the Actor Model?</h3>
  <p class="paragraph">
    At a high-level, both the Erlang VM and CloudI implement the Actor Model
    when the term "Actor Model" is used loosely and the actors are allowed to
    queue the messages they receive, before the messages are processed.
  </p>
  <p class="paragraph">
    The Erlang VM has been referred to as implementing the
    <a href="https://en.wikipedia.org/wiki/Actor_model" rel="noreferrer" target="_blank">Actor Model</a>
    despite the <a href="https://erlang.org/pipermail/erlang-questions/2014-June/079794.html" rel="noreferrer" target="_blank">authors of Erlang being unaware of the Actor Model while implementing Erlang</a> (e.g., the paper by <a href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.226.5767" rel="noreferrer" target="_blank">Rajesh K. Karmani, Gul Agha, "Actors"</a>).
    However, the Erlang VM does not provide the Actor
    Model when working with the original definition of the Actor Model as it was
    provided in <a href="https://ijcai.org/Past%20Proceedings/IJCAI-73/PDF/027B.pdf" rel="noreferrer" target="_blank">Carl Hewitt, Peter Bishop and Richard Steiger. "A Universal Modular Actor Formalism for Artificial Intelligence". IJCAI'73</a>.
    Instead, the Erlang VM provides processes which are most similar to
    "Fog Cutter Actors", based on the paper <a href="https://arxiv.org/abs/1008.1459" rel="noreferrer" target="_blank">by Carl Hewitt, "Actor Model of Computation: Scalable Robust Information Systems"</a>.
    Unfortunately, no better term currently exists to refer to the design of
    Erlang processes, aside from a comparison to a "Fog Cutter Actor".
  </p>
  <p class="paragraph">
    CloudI services are similar to Erlang processes and Erlang processes are
    used within the implementation of CloudI services.  However, CloudI
    services are more dynamic:
  </p>
  <ul>
    <li>CloudI services use service names which match service name patterns. Service name patterns represent any number of CloudI service processes and service requests are automatically split between the available service processes, based on the sending service's destination refresh method.  Erlang/OTP provides naming for Erlang processes, but the names must be unique, so only a one-to-one mapping is allowed.</li>
    <li>CloudI services can be used transparently within non-Erlang programming languages, but Erlang processes are limited to the Erlang VM.</li>
    <li>An asynchronous send within a CloudI service initialization can provide a response, which is not the case when using an Erlang process with an Erlang/OTP behaviour.</li>
    <li>Erlang process creation is statically defined as part of a release creation process which provides a single boot file used during the lifetime of the Erlang VM. CloudI services are always dynamically added (or removed) based on the CloudI configuration and the <a href="api.html#CloudI">CloudI Service API</a> usage.</li>
    <li><a href="#4_Erlang">etc.</a></li>
  </ul>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_REST">1.14 - Does CloudI support REST?</h3>
  <p class="paragraph">
    Yes!  CloudI is a system that enforces <a href="https://en.wikipedia.org/wiki/Representational_State_Transfer" rel="noreferrer" target="_blank">RESTful development practices</a>.
    A common misconception is that REST requires HTTP usage
    (see <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" rel="noreferrer" target="_blank">Roy Fielding's thesis to understand why this is not the case</a>, <a href="https://www.ics.uci.edu/~taylor/documents/2002-REST-TOIT.pdf" rel="noreferrer" target="_blank">Fielding, Roy T.; Taylor, Richard N. (May 2002), "Principled Design of the Modern Web Architecture" (PDF), ACM Transactions on Internet Technology (TOIT) (New York: Association for Computing Machinery) 2 (2): 115–150, doi:10.1145/514183.514185, ISSN 1533-5399</a>).
    In CloudI, service requests operate with <a href="https://en.wikipedia.org/wiki/Representational_state_transfer#Architectural_constraints" rel="noreferrer" target="_blank">REST architectural constraints</a> for better reliability and scalability than
    an ad-hoc brittle server would provide.
    For more details please refer to <a href="#1_WhatIs">"1.5 - What is CloudI?"</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_SOA">1.15 - Does CloudI provide a Service Oriented Architecture (SOA)?</h3>
  <p class="paragraph">
    Yes!  CloudI provides a <a href="https://en.wikipedia.org/wiki/Service_oriented_architecture" rel="noreferrer" target="_blank">Service Oriented Architecture (SOA)</a>
    for flexible development, deployment, and maintenance of
    <a href="https://en.wikipedia.org/wiki/Enterprise_software" rel="noreferrer" target="_blank">Enterprise Software Applications (ESA)</a>.
    CloudI provides an <a href="https://en.wikipedia.org/wiki/Enterprise_service_bus" rel="noreferrer" target="_blank">Enterprise Service Bus (ESB)</a>
    which avoids latency overhead by avoiding serialization and conversions
    of protocols like
    <a href="https://kentonv.github.io/capnproto/" rel="noreferrer" target="_blank">Cap'n Proto</a>,
    <a href="https://en.wikipedia.org/wiki/Protocol_Buffers" rel="noreferrer" target="_blank">Google Protocol Buffers</a>
    (<a href="https://en.wikipedia.org/wiki/Asn.1" rel="noreferrer" target="_blank">ASN.1</a>
     or <a href="https://en.wikipedia.org/wiki/DFDL" rel="noreferrer" target="_blank">DFDL</a>),
    <a href="https://en.wikipedia.org/wiki/Representational_State_Transfer#Applied_to_Web_Services" rel="noreferrer" target="_blank">HTTP REST</a>
    (with <a href="https://www.json.org/" rel="noreferrer" target="_blank">JSON</a>
     or <a href="https://www.w3.org/TR/xml/" rel="noreferrer" target="_blank">XML</a>),
    <a href="https://msgpack.org/" rel="noreferrer" target="_blank">MessagePack</a>,
    <a href="https://bsonspec.org/" rel="noreferrer" target="_blank">BSON</a>,
    <a href="https://en.wikipedia.org/wiki/SOAP" rel="noreferrer" target="_blank">SOAP</a>,
    <a href="https://en.wikipedia.org/wiki/JSON_RPC" rel="noreferrer" target="_blank">JSON-RPC</a>,
    <a href="https://en.wikipedia.org/wiki/Xmlrpc" rel="noreferrer" target="_blank">XML-RPC</a>,
    <a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol" rel="noreferrer" target="_blank">STOMP</a>,
    <a href="https://en.wikipedia.org/wiki/Corba" rel="noreferrer" target="_blank">CORBA</a>,
    <a href="https://en.wikipedia.org/wiki/SunRPC" rel="noreferrer" target="_blank">Sun RPC</a>,
    etc. and instead relies on the exchange of binary data between
    heterogeneous services with the CloudI API.
  </p>
  <p class="paragraph">
    CloudI service requests provide
    <a href="https://en.wikipedia.org/wiki/Request-response" rel="noreferrer" target="_blank">Request/Reply</a>
    (<a href="https://en.wikipedia.org/wiki/Remote_procedure_call" rel="noreferrer" target="_blank">RPC</a>),
    <a href="https://en.wikipedia.org/wiki/Publish/subscribe" rel="noreferrer" target="_blank">Publish/Subscribe</a> and
    <a href="https://en.wikipedia.org/wiki/Flow-based_programming" rel="noreferrer" target="_blank">Pipeline messaging (i.e., Flow-Based Programming (FBP))</a>.
    CloudI supports both broker and broker-less
    service requests with a distributed fault-tolerant service directory
    (using "service names" and "service patterns")
    that can be locally cached (when using a "lazy" destination refresh method,
    instead of "immediate").
    For more details please refer to <a href="#1_WhatIs">"1.5 - What is CloudI?"</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_Microservices">1.16 - Does CloudI provide a Microservice Architecture?</h3>
  <p class="paragraph">
    Yes!  CloudI provides <a href="https://martinfowler.com/articles/microservices.html" rel="noreferrer" target="_blank">Microservices</a>
    using light-weight messaging to facilitate CloudI
    <a href="#1_SOA">service requests</a> with the CloudI API.
    HTTP integration is provided by
    <a href="#6_HTTP">cloudi_service_http_cowboy</a>
    (with other protocol integration relying on other CloudI services).
    The service memory footprint is kept small by relying on Erlang processes
    for their light-weight messaging (Erlang processes have been referred to
    elsewhere as "Nanoservices").
  </p>
  <p class="paragraph">
    The main requirements of a <a href="https://en.wikipedia.org/wiki/Microservices" rel="noreferrer" target="_blank">Microservices Architecture (MSA)</a> are:
  </p>
  <ul>
    <li>Services must be <a href="api.html#2_services_update">easy to replace</a></li>
    <li>Services are organized based on capabilities</li>
    <li>Services can be implemented with heterogeneous technology transparently</li>
    <li>All Service entities are equal rather than hierarchical (a property enforced by Inversion of Control (IoC) in a microservices framework)</li>
  </ul>
  <p class="paragraph">
    CloudI services satisfy these requirements and are more fine-grained than
    monolithic SOA services (many CloudI services can be used within a
    single application rather than requiring an application be a service).
  </p>
  <p class="paragraph">
    Using Erlang processes to provide a service abstraction allows all
    service requests to be exchanged in a common way with external programming
    language integration requiring only a thin interface
    (an implementation of the CloudI API).  The CloudI API imposes
    <a href="#4_Erlang">no contention</a> on the extreme concurrency the
    Erlang VM provides with CloudI's Erlang process integration.
    For more details please refer to <a href="#1_WhatIs">"1.5 - What is CloudI?"</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_Reactive">1.17 - Is CloudI Reactive?</h3>
  <p class="paragraph">
    Yes!  CloudI is <a href="https://www.reactivemanifesto.org/" rel="noreferrer" target="_blank">Reactive</a>
    due to the scalability and fault tolerance provided by Erlang combined
    with the <a href="#1_REST">REST</a>
    requirement of <a href="https://en.wikipedia.org/wiki/Representational_state_transfer#Stateless" rel="noreferrer" target="_blank">being stateless</a>
    for service requests to provide event-driven, scalable, resilient and
    responsive CloudI services.
  </p>
  <p class="paragraph">
    To be specific, CloudI is an example of <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" rel="noreferrer" target="_blank">Functional Reactive Programming (FRP)</a>,
    with CloudI service requests referred to as "signals" and each
    service request handling function execution referred to as "events".
    CloudI service request sends occur with a FRP "push-based" system
    implementation.
  </p>
  <p class="paragraph">
    To keep functional semantics in any programming language
    that utilizes the CloudI API, separate function arguments are used
    for each datum within the data of a service request when the
    service request handling function is called
    (with the function arity as 9 in Java, Perl, PHP, Ruby, 10 in Python,
     11 in ATS, Erlang/Elixir, Go, Haskell, OCaml, Rust, 13 in C++ and 14 in C,
     where arities higher than 9 are due to data handling details specific
     to the programming languages).
    Using a relatively high arity count does initially make developers
    feel uncomfortable due to common Object-Oriented design considering it
    a bad code-smell
    (e.g., "Refactoring: Improving the Design of Existing Code"
     by Martin Fowler et al. (Reading, MA: Addison-Wesley, 1999. Print)
     mentions long parameter lists on page 78-79) though it does
    help the developer naturally avoid side-effects as is commonly done
    in functional programming with immutable data.
    The use of a high arity count for CloudI service requests is
    part of a consistent interface that the CloudI API provides in each
    programming language (functions are common to all well-utilized
    programming languages while objects are not).
  </p>
  <p class="paragraph">
    When a <a href="api.html#1_subscribe">subscribe</a>d
    callback function is called with the CloudI service request data,
    the individual values are the most recent values.  For example, the
    timeout parameter in the service request is automatically decremented
    based on the time that has elapsed before getting to the function
    call.  There are 3 constant parameters: the request type
    (asynchronous or synchronous), the transaction id used to
    identify the service request, and the source process identifier that
    may receive the service request response, though all other parameters
    can be changed with a call to
    <a href="api.html#1_forward">forward</a> the service
    request to a new callback function execution.  For example,
    the service name pattern may automatically change with a new
    callback function execution even if the same service name is used for
    the forward, due to the dynamic nature of service name pattern
    subscriptions.  The execution time spent within the callback function
    is automatically decremented from the timeout value used for the
    <a href="api.html#1_return">return</a>
    or <a href="api.html#1_forward">forward</a>
    if the <a href="api.html#2_services_add_config_opts">'request_timeout_adjustment' service configuration option</a>
    is set to true (and the timeout value is not manually modified).
  </p>
  <p class="paragraph">
    For more details please refer to <a href="#1_WhatIs">"1.5 - What is CloudI?"</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_Sagas">1.18 - Does CloudI support Sagas?</h3>
  <p class="paragraph">
    Yes! Sagas are easy to develop using CloudI.  Sagas were first
    described in the paper <a href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf" rel="noreferrer" target="_blank">Hector Garcia-Molina and Kenneth Salem. "Sagas". SIGMOD'87</a>.
    Sagas have become a more prominent concept as microservice development
    has become more popular due to the need to manage the complexity of
    long-lived microservice transactions.
  </p>
  <p class="paragraph">
    Typically, two approaches to Sagas is described:
  </p>
  <ul>
    <li>Events/Choreography</li>
    <li>Command/Orchestration</li>
  </ul>
  <p class="paragraph">
    Either approach is possible in a CloudI service, though Sagas development
    prefers the Command/Orchestration approach to avoid abstract complexity
    that leads to implementation and maintenance difficulties that are
    common with the Events/Choreography approach.
  </p>
  <p class="paragraph">
    An Events/Choreography CloudI service implementation would rely on
    <a href="api.html#1_subscribe">subscribe</a> use in each service,
    for each event that needs to be received
    (it would be best with a unique event for each receive to track
     the transaction logic and decouple the receive from the concurrency of
     each service).
    The service would use <a href="api.html#1_forward">forward</a>
    to transfer the control of a transaction to a different service and
    any additional transactions may be sent using
    <a href="api.html#1_send_async">send_async</a>
    or <a href="api.html#1_send_sync">send_sync</a>
    until the final transaction in the Saga
    <a href="api.html#1_return">return</a>s a response.
  </p>
  <p class="paragraph">
    A Command/Orchestration CloudI service implementation would centralize
    the core Saga logic in a single CloudI service that uses
    <a href="api.html#1_send_async">send_async</a>
    or <a href="api.html#1_send_sync">send_sync</a>
    to use any services necessary with separate transactions in the Saga.
    Transactions in these other services could be joined together
    by using <a href="api.html#1_forward">forward</a>
    to transfer control of the transaction to the next service.
    The core Saga logic would be based on the responses to the separate
    transactions and would end the Saga by
    <a href="api.html#1_return">return</a>ing a response.
  </p>
  <p class="paragraph">
    With CloudI services providing transactions as a core feature
    while managing the fault-tolerance and scalability of each
    service independently, the resulting CloudI service business logic
    is kept simple and easy to maintain.  CloudI services are able to
    avoid "boilerplate" source code that is required without CloudI
    when handling timeouts and the propagation of timeout failures,
    service failures or exceptions, service concurrency and other
    common <a href="api.html#1_Intro">development</a> concerns.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <h3 id="1_HowAbout">1.19 - Why doesn't CloudI integrate with ProductX?</h3>
  <p class="paragraph">
    There are many possibilities for CloudI integration.  If you know of a
    public product that you think should be integrated or if you need
    commercial support for a private product, contact
    <a href="mailto:mjtruog(at)protonmail;dot;com">Michael Truog</a>.
  </p>
  <div class="top"><a href="#1_contents">Top</a></div>

  <hr>
  <h2>2 - Learning about CloudI</h2>

  <h3 id="2_WebPages">2.1 - Web Pages</h3>
  <table><tr><td>
  Main Web Site:
  </td><td>
  <a href="https://cloudi.org">https://cloudi.org</a>
  </td></tr><tr><td>
  Source Code:
  </td><td>
  <a href="https://github.com/CloudI/CloudI#readme" rel="noopener" target="_blank">https://github.com/CloudI/CloudI</a>
  </td></tr><tr><td>
  Releases:
  </td><td>
  <a href="https://osdn.net/pkg/cloudi/cloudi" rel="noopener" target="_blank">https://osdn.net/pkg/cloudi/cloudi</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <h3 id="2_MailingList">2.2 - Mailing List</h3>
  <table><tr><td>
  Email Address:
  </td><td>
  <a href="mailto:cloudi-questions@lists.osdn.me" target="_blank">cloudi-questions@lists.osdn.me</a>
  </td></tr><tr><td>
  Subscribe:
  </td><td>
  <a href="https://lists.osdn.me/mailman/listinfo/cloudi-questions" rel="noopener" target="_blank">https://lists.osdn.me/mailman/listinfo/cloudi-questions</a>
  </td></tr><tr><td>
  Archive:
  </td><td>
  <a href="https://lists.osdn.me/mailman/archives/cloudi-questions" rel="noopener" target="_blank">https://lists.osdn.me/mailman/archives/cloudi-questions</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <h3 id="2_IRC">2.3 - Internet Relay Chat (IRC)</h3>
  <table><tr><td>
  IRC Server:
  </td><td>
  <a href="https://www.oftc.net/" rel="noreferrer" target="_blank">oftc.net</a>
  </td></tr><tr><td>
  Chat Room:
  </td><td>
  <a href="https://webchat.oftc.net/?randomnick=1&channels=cloudi" rel="noreferrer" target="_blank">#cloudi</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <h3 id="2_RSS">2.4 - RSS Feeds</h3>
  <table><tr><td>
  Development:
  </td><td>
  <a href="https://github.com/CloudI/CloudI/commits/develop.atom" rel="noopener" target="_blank">https://github.com/CloudI/CloudI/commits/develop.atom</a>
  </td></tr><tr><td>
  Releases:
  </td><td>
  <a href="https://osdn.net/projects/cloudi/releases/rss" rel="noopener" target="_blank">https://osdn.net/projects/cloudi/releases/rss</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <h3 id="2_Twitter">2.5 - Twitter</h3>
  <table><tr><td>
  Development:
  </td><td>
  <a href="https://twitter.com/cloudi_org" rel="noreferrer" target="_blank">@cloudi_org</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <h3 id="2_Presentations">2.6 - Presentations</h3>
  <table>
  <tr><td>
  Version 1.5.0
  </td><td>
  <a href="docs/cloudi_meetup_chicago2015.pdf" target="_blank">2015 Chicago Erlang User Group (slides)</a>
  </td></tr><tr><td>
  Version 1.3.2b
  </td><td>
  <a href="docs/cloudi_meetup_seattle2014.pdf" target="_blank">2014 Erlang/Elixir Meetup Seattle (slides)</a>
  </td></tr><tr><td>
  Version 1.2.5b
  </td><td>
  <a href="docs/cloudi_hackntell_seattle2013.pdf" target="_blank">2013 Hack and Tell Seattle (slides)</a>
  </td></tr><tr><td>
  Version 1.0.0b
  </td><td>
  2012 Open Source Bridge Unconference
  </td></tr><tr><td>
  Version 0.1.6a
  </td><td>
  <a href="docs/cloudi_erlounge_vancouver2011.pdf" target="_blank">2011 ErLounge Meetup Vancouver BC (slides)</a>
  </td></tr><tr><td>
  Version 0.1.5a
  </td><td>
  <a href="docs/cloudi_erlounge_sfbay2011.pdf" target="_blank">2011 ErLounge Meetup SF Bay Area (slides)</a>
  </td></tr><tr><td>
  Version 0.0.9a
  </td><td>
  <a href="docs/cloudi_ef_sfbay2010.pdf" target="_blank">2010 Erlang Factory SF Bay Area (slides)</a> <a href="docs/cloudi_ef_sfbay2010.txt" target="_blank">(demo text)</a>
  </td></tr><tr><td>
  Version 0.0.8a
  </td><td>
  <a href="https://vimeo.com/8192137" rel="noreferrer" target="_blank">2009 Erlang User Conference (video)</a> <a href="docs/cloudi_euc2009.pdf" target="_blank">(slides)</a>
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <h3 id="2_Articles">2.7 - Articles</h3>
  <table><tr><td>
  <a href="https://www.toptal.com/erlang/a-cloud-at-the-lowest-level-built-in-erlang" rel="noreferrer" target="_blank">Bringing Erlang's Fault Tolerance to Polyglot Development</a>
  </td><td>
  @Toptal Engineering Blog
  </td></tr><tr><td>
  <a href="https://www.toptal.com/erlang/modernizing-legacy-software-an-example-using-erlang-and-cloudi" rel="noreferrer" target="_blank">Modernizing Legacy Software: A Case Study Using Erlang and CloudI</a> (<a href="https://github.com/okeuday/sillymud#readme" rel="noopener" target="_blank">integration source code</a>)
  </td><td>
  @Toptal Engineering Blog
  </td></tr></table>
  <div class="top"><a href="#2_contents">Top</a></div>

  <h3 id="2_ReportingBugs">2.8 - Reporting Bugs</h3>
  <table><tr><td>
  Bug Reports:
  </td><td>
  <a href="https://github.com/CloudI/CloudI/issues/new" rel="noopener" target="_blank">https://github.com/CloudI/CloudI/issues/new</a>
  </td></tr><tr><td>
  <a href="#2_MailingList">Mailing List:</a>
  </td><td>
  <a href="mailto:cloudi-questions@lists.osdn.me" target="_blank">cloudi-questions@lists.osdn.me</a>
  </td></tr></table>
  <p class="paragraph">
    If you are unsure whether you have found a bug, please send an email to the
    mailing list or utilize the <a href="https://webchat.oftc.net/?randomnick=1&channels=cloudi" rel="noreferrer" target="_blank">IRC chat room</a>.
    Otherwise, you can easily enter a bug report for the problem by using the
    <a href="https://github.com/CloudI/CloudI/issues/new" rel="noopener" target="_blank">online form</a>.
    If you are unable to provide information about the problem publicly,
    specify the information is private in an email to
    <a href="mailto:mjtruog(at)protonmail;dot;com">Michael Truog</a>.
  </p>
  <div class="top"><a href="#2_contents">Top</a></div>

  <h3 id="2_CodeOfConduct">2.9 - Code of Conduct</h3>
  <p class="paragraph">
    To ensure there are no barriers to CloudI development for any developers
    who want to get involved, a Code of Conduct was adopted:
  </p>
  <h4>Contributor Covenant Code of Conduct</h4>
  <h5>Our Pledge</h5>
  <p>
    In the interest of fostering an open and welcoming environment, we as
    contributors and maintainers pledge to making participation in our project
    and our community a harassment-free experience for everyone, regardless of
    age, body size, disability, ethnicity, gender identity and expression,
    level of experience, nationality, personal appearance, race, religion,
    or sexual identity and orientation.
  </p>
  <h5>Our Standards</h5>
  <p>
    Examples of behavior that contributes to creating a positive environment
    include:
  </p>
  <ul>
    <li>Using welcoming and inclusive language</li>
    <li>Being respectful of differing viewpoints and experiences</li>
    <li>Gracefully accepting constructive criticism</li>
    <li>Focusing on what is best for the community</li>
    <li>Showing empathy towards other community members</li>
  </ul>
  <p>
    Examples of unacceptable behavior by participants include:
  </p>
  <ul>
    <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li>
    <li>Trolling, insulting/derogatory comments, and personal or political attacks</li>
    <li>Public or private harassment</li>
    <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li>
    <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li>
  </ul>
  <h5>Our Responsibilities</h5>
  <p>
    Project maintainers are responsible for clarifying the standards of
    acceptable behavior and are expected to take appropriate and fair
    corrective action in response to any instances of unacceptable behavior.
  </p>
  <p>
    Project maintainers have the right and responsibility to remove, edit, or
    reject comments, commits, code, wiki edits, issues, and other contributions
    that are not aligned to this Code of Conduct, or to ban temporarily or
    permanently any contributor for other behaviors that they deem
    inappropriate, threatening, offensive, or harmful.
  </p>
  <h5>Scope</h5>
  <p>
    This Code of Conduct applies both within project spaces and in public
    spaces when an individual is representing the project or its community.
    Examples of representing a project or community include using an official
    project e-mail address, posting via an official social media account,
    or acting as an appointed representative at an online or offline event.
    Representation of a project may be further defined and clarified by
    project maintainers.
  </p>
  <h5>Enforcement</h5>
  <p>
    Instances of abusive, harassing, or otherwise unacceptable behavior may be
    reported by
    <a href="https://github.com/CloudI/CloudI/issues/new" rel="noopener" target="_blank">opening an issue</a>
    or contacting
    <a href="mailto:mjtruog(at)protonmail;dot;com">the project creator</a>. All
    complaints will be reviewed and investigated and will result in a
    response that is deemed necessary and appropriate to the circumstances.
    The project team is obligated to maintain confidentiality with regard to
    the reporter of an incident.  Further details of specific enforcement
    policies may be posted separately.
  </p>
  <p>
    Project maintainers who do not follow or enforce the Code of Conduct in
    good faith may face temporary or permanent repercussions as determined by
    other members of the project's leadership.
  </p>
  <h5>Attribution</h5>
  <p>
    This Code of Conduct is adapted from the
    <a href="https://contributor-covenant.org/" rel="noreferrer" target="_blank">Contributor Covenant</a>, version 1.4,
    available at <a href="https://contributor-covenant.org/version/1/4/" rel="noreferrer" target="_blank">https://contributor-covenant.org/version/1/4/</a>
  </p>
  <div class="top"><a href="#2_contents">Top</a></div>

  <hr>
  <h2>3 - CloudI Installation Guide</h2>

  <h3 id="3_Overview">3.1 - Overview</h3>
  <p>
    For CloudI on a Live CD ISO image use the<br />
    <a href="https://github.com/CloudI/live_cd#readme" rel="noopener" target="_blank">https://github.com/CloudI/live_cd</a> repository.
  </p>
  <p>
    For CloudI in a container (e.g., Docker) use the<br />
    <a href="https://github.com/CloudI/containers#readme" rel="noopener" target="_blank">https://github.com/CloudI/containers</a> repository.
  </p>
  <p>
    Installation of CloudI from source (in the
    <a href="https://github.com/CloudI/CloudI#readme" rel="noopener" target="_blank">main repository</a>
    or CloudI release "src" directory) uses the typical open source
    command sequence of:
  </p>
  <ol style="font-family: monospace">
    <li>./configure</li>
    <li>make</li>
    <li>sudo make install</li>
  </ol>
  <p>
    If the ./configure script doesn't exist, use ./autogen.sh to generate it.
  </p>
  <p class="paragraph">
    The most common programming languages CloudI supports are expected to be
    present by the configure script and are required when executing the
    integration tests (with the provided cloudi_tests.conf containing the
    integration tests service configurations).  For information about
    the configure script arguments to enable or disable programming language
    support, refer to the
    <a href="#3_Options">Installation Options</a>.
  </p>
  <p class="paragraph">
    Dependencies as they are packaged for different operating systems are
    listed below:
  </p>
  <table><tr><th>
  Operating System
  </th><th>
  Packages
  </th></tr><tr><td>
  Ubuntu<br />(apt-get install &lt;package(s)&gt;)
  </td><td>
  <ul>
    <li>erlang</li>
    <li>g++</li>
    <li>libboost-system-dev</li>
    <li>libboost-dev</li>
    <li>libdw-dev (optional)</li>
    <li>libseccomp-dev (optional)</li>
    <li>golang (optional)</li>
    <li>ghc cabal-install (optional)</li>
    <li>default-jdk (optional)</li>
    <li>nodejs (optional)</li>
    <li>perl (optional)</li>
    <li>php (optional)</li>
    <li>python3 (optional)</li>
    <li>python3-dev (optional)</li>
    <li>ruby (optional)</li>
    <li>libgmp3-dev libboost-thread-dev (optional)</li>
    <li>autoconf automake libtool<br />(to compile from repository)</li>
  </ul>
  </td></tr><tr><td>
  Fedora<br />(yum install &lt;package(s)&gt;)
  </td><td>
  <ul>
    <li>erlang</li>
    <li>gcc-c++</li>
    <li>boost-devel</li>
    <li>java-devel (optional)</li>
    <li>nodejs-devel (optional)</li>
    <li>php-devel (optional)</li>
    <li>python-devel (optional)</li>
    <li>ruby-devel (optional)</li>
    <li>gmp-devel (optional)</li>
    <li>autoconf automake libtool<br />(to compile from repository)</li>
  </ul>
  </td></tr><tr><td>
  Red Hat Enterprise Linux<br />(yum install &lt;package(s)&gt;)
  </td><td>
  <ul>
    <li>gcc-c++</li>
    <li>boost-devel</li>
    <li>java-devel (optional)</li>
    <li>perl-Compress-Zlib (optional)</li>
    <li>php-devel (optional)</li>
    <li>python-devel (optional)</li>
    <li>ruby-devel rubygem-minitest (optional)</li>
    <li>gmp-devel (optional)</li>
    <li>autoconf automake libtool<br />(to compile from repository)</li>
  </ul>
  </td></tr><tr><td>
  OSX w/macports<br />(port install &lt;package(s)&gt;)
  </td><td>
  <ul>
    <li>erlang</li>
    <li>libstdcxx</li>
    <li>boost</li>
    <li>python27 (optional)</li>
    <li>ruby19 (optional)</li>
    <li>gmp (optional)</li>
  </ul>
  </td></tr></table>
  <div class="top"><a href="#3_contents">Top</a></div>

  <h3 id="3_Options">3.2 - Installation Options</h3>
  <p>
    Common CloudI installation configuration options
    ("./configure" command line arguments) are:
  </p>
  <table><tr><td style="white-space:nowrap">
  --prefix="/path/to/install/"
  </td><td>
  Specify an Installation Path<br />(default="/usr/local/")
  </td></tr><tr><td style="white-space:nowrap">
  --without-cxx-backtrace
  </td><td>
  Provide a C++ backtrace in the CloudI C++ API
  with the function CloudI::API::backtrace()<br />(default="no")
  </td></tr><tr><td style="white-space:nowrap">
  --with-python-version=[2|3]
  </td><td>
  Specify the version of python to use<br />(default="3")
  </td></tr><tr><td style="white-space:nowrap">
  --with-python-debug
  </td><td>
  Use the debug python executable instead of the normal python
  executable<br />(default="no")
  </td></tr><tr><td style="white-space:nowrap">
  --with-integration-tests
  </td><td>
  Build and install the integration tests<br />(default="yes")
  </td></tr><tr><td style="white-space:nowrap">
  --with-integration-tests-ran
  </td><td>
  Install the integration tests configuration
  to run the tests at startup<br />(default="no")
  </td></tr><tr><td style="white-space:nowrap">
  --enable-ats2-support
  </td><td>
  Enable the ATS CloudI API,<br />
  requires ATS2/Postiats&nbsp;&ge;&nbsp;0.3.13<br />(default="no")
  </td></tr><tr><td style="white-space:nowrap">
  --enable-go-support
  </td><td>
  Enable the Go CloudI API,<br />
  requires Go&nbsp;&ge;&nbsp;1.6<br />(default="no")
  </td></tr><tr><td style="white-space:nowrap">
  --enable-haskell-support
  </td><td>
  Enable the Haskell CloudI API,<br />
  requires GHC&nbsp;&ge;&nbsp;7.10.3 and
  cabal&#8209;install&nbsp;&ge;&nbsp;1.22<br />(default="no")
  </td></tr><tr><td style="white-space:nowrap">
  --disable-java-support
  </td><td>
  Disable the Java CloudI API,<br />
  requires Java&nbsp;&ge;&nbsp;1.5 JDK<br />(default="no")
  </td></tr><tr><td style="white-space:nowrap">
  --disable-javascript-support
  </td><td>
  Disable the Javascript CloudI API,<br />
  requires node.js&nbsp;&ge;&nbsp;0.12.18<br />(default="no")
  </td></tr><tr><td style="white-space:nowrap">
  --enable-ocaml-support
  </td><td>
  Enable the OCaml CloudI API,<br />
  requires OCaml&nbsp;&ge;&nbsp;4.03.0<br />(default="no")
  </td></tr><tr><td style="white-space:nowrap">
  --disable-perl-support
  </td><td>
  Disable the Perl CloudI API,<br />
  requires Perl&nbsp;&ge;&nbsp;5.10 and Compress::Zlib<br />(default="no")
  </td></tr><tr><td style="white-space:nowrap">
  --disable-php-support
  </td><td>
  Disable the PHP CloudI API,<br />
  requires PHP&nbsp;&ge;&nbsp;5.3.6<br />(default="no")
  </td></tr><tr><td style="white-space:nowrap">
  --disable-python-support
  </td><td>
  Disable the Python CloudI API,<br />
  requires Python&nbsp;&ge;&nbsp;2.7.0<br />(default="no")
  </td></tr><tr><td style="white-space:nowrap">
  --disable-python-c-support
  </td><td>
  Disable the Python/C CloudI API,<br />
  requires Python&nbsp;&ge;&nbsp;2.7.0<br />(default="no")
  </td></tr><tr><td style="white-space:nowrap">
  --disable-ruby-support
  </td><td>
  Disable the Ruby CloudI API,<br />
  requires Ruby&nbsp;&ge;&nbsp;1.9.0<br />(default="no")
  </td></tr><tr><td style="white-space:nowrap">
  --enable-rust-support
  </td><td>
  Enable the Rust CloudI API,<br />
  requires Rust&nbsp;&ge;&nbsp;1.66.1<br />(default="no")
  </td></tr></table>
  <p class="paragraph">
    For more installation configuration option details, please execute
    "./configure&nbsp;--help" (otherwise, you can refer to
    <a href="https://github.com/CloudI/CloudI/blob/master/src/INSTALL" rel="noopener" target="_blank">src/INSTALL</a>
    for basic configuration information).
  </p>
  <div class="top"><a href="#3_contents">Top</a></div>

  <h3 id="3_OSX">3.3 - OS X Installation</h3>
  <p class="paragraph">
    To install CloudI dependencies on macOS you either need <a href="https://www.macports.org/" rel="noreferrer" target="_blank">macports</a> or
    <a href="https://brew.sh/" rel="noreferrer" target="_blank">homebrew</a>.
    All configuration and build steps are the same as Linux.
  </p>
  <div class="top"><a href="#3_contents">Top</a></div>

  <h3 id="3_Running">3.4 - Running CloudI</h3>
  <p>
    To start CloudI, execute:
  </p>
<pre class="code">
sudo cloudi start
</pre>
  <p>
    To stop the running CloudI node, execute:
  </p>
<pre class="code">
sudo cloudi stop
</pre>
  <p class="paragraph">
    When CloudI is running, CloudI logging output will be appended to
    <a href="#3_Options">PREFIX</a>/var/log/cloudi/cloudi.log.
  </p>
  <div class="top"><a href="#3_contents">Top</a></div>

  <h3 id="3_Config">3.5 - Configuration</h3>
  <p class="paragraph">
    The CloudI configuration provides all the initial parameters for startup.
    It is also possible to do the same configuration with the CloudI Service
    API (so, the configuration can also be done dynamically as described in
    <a href="#4_ServiceAPI">"4.2 - How do I control CloudI dynamically?"</a>).
  </p>
  <p class="paragraph">
    The configuration is organized into sections for the ACLs, Services, Nodes,
    and Logging.  The ACLs provide a name which can be referenced by a Service
    to either explicitly allow or deny communication between services
    (based on service name patterns, see 
    <a href="#4_ACLs">"4.7 - How do I use Access Control Lists (ACLs)?"</a>
    for more information).
  </p>
  <p class="paragraph">
    The Services configuration specifies both the services that are ran
    and the order in which the services should be started.  The "internal"
    Services are Erlang modules that use the cloudi_service behavior.  The
    "external" Services are all non-Erlang languages that use the
    <a href="api.html#Service">CloudI API</a>.
    There is more information about service integration in
    <a href="#6_C">"6 - Services"</a> and
    <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <p class="paragraph">
    The Nodes configuration lists all CloudI nodes that should be connected.
    This allows the CloudI node connections to reconnect after network failures.
  </p>
  <p class="paragraph">
    The Logging configuration specifies the logging level and whether the
    logging output should be directed to a different CloudI node
    (which is present in the Nodes section).  If the logging is redirected to
    a different CloudI node, it is possible to lose logging data when a network
    outage occurs.  However, if the node has failed, the logging output will
    be stored locally until the node reconnects (i.e., the logging output is
    redirected to the CloudI node automatically, when it is connected).
  </p>
  <p>
    Below is a summary of the layout of the CloudI
    <a href="api.html#CloudI">configuration</a> file.  The
    ()s have been used to specify the configuration parameters that are
    supplied.  You can find the integration tests configuration file in
    <a href="https://github.com/CloudI/CloudI/blob/master/src/cloudi_tests.conf.in" rel="noopener" target="_blank">src/cloudi_tests.conf.in</a>
    (and the default configuration <a href="https://github.com/CloudI/CloudI/blob/master/src/cloudi_minimal.conf.in" rel="noopener" target="_blank">src/cloudi_minimal.conf.in</a>)
    within the source code repository (in its state before it gets modified
    by the local operating system configuration parameters) or
    PREFIX/etc/cloudi/cloudi.conf after the installation.
  </p>
<pre>
{acl, <a href="api.html#2_acl_add">[
    {(AliasName), [(ServiceNamePrefix) or (AliasName), ...]}
    ...
]</a>}.
{services, [
    {internal, <a href="api.html#2_services_add">
     (ServiceNamePrefix),
     (ErlangModuleName),
     (ModuleInitializationList),
     (DestinationRefreshMethod),
     (InitializationTimeout),
     (DefaultAsynchronousTimeout),
     (DefaultSynchronousTimeout),
     (DestinationDenyACL),
     (DestinationAllowACL),
     (ProcessCount),
     (MaxR),
     (MaxT),</a><a href="api.html#2_services_add_config_opts">
     (ServiceOptionsPropList)</a>},
    {external, <a href="api.html#2_services_add">
     (ServiceNamePrefix),
     (ExecutableFilePath),
     (ExecutableCommandLineArguments),
     (ExecutableEnvironmentalVariables),
     (DestinationRefreshMethod),
     (Protocol),
     (ProtocolBufferSize),
     (InitializationTimeout),
     (DefaultAsynchronousTimeout),
     (DefaultSynchronousTimeout),
     (DestinationDenyACL),
     (DestinationAllowACL),
     (ProcessCount),
     (ThreadCount),
     (MaxR),
     (MaxT),</a><a href="api.html#2_services_add_config_opts">
     (ServiceOptionsPropList)</a>},<a href="api.html#2_services_add">
    ...</a>
]}.
{nodes, <a href="api.html#2_nodes_set">[
    'cloudi@hostname1',
    ...
] % or 'automatic' for multicast (LAN) node discovery </a>
}.
{logging, <a href="api.html#2_logging_set">[
    {level, trace}, % levels: off, fatal, error, warn, info, debug, trace
    {redirect, undefined or (Node)}
]</a>}.
</pre>
  <div class="top"><a href="#3_contents">Top</a></div>

  <hr>
  <h2>4 - General Questions</h2>

  <h3 id="4_API">4.1 - How do I integrate external software with CloudI?</h3>

  <h4><a href="api.html#Service">CloudI API</a></h4>
  <p class="paragraph">
    The CloudI API provides a light-weight interface for creating services
    in ATS, C++/C, Elixir, Erlang, Go, Haskell, Java, Javascript, OCaml, Perl,
    PHP, Python, Ruby, and Rust.  Services subscribe to receive requests from
    other services using the CloudI API
    "<a href="api.html#1_subscribe">subscribe</a>" function
    call.  The subscribe function call takes a suffix string that is expected
    to contain a path using a forward slash '/' (e.g., /cloudi/api/json_rpc/).
    However, the service configuration provides the prefix for the subscription
    function call, so "/cloudi/api/" is provided as a configuration prefix
    (for the <a href="api.html#CloudI">CloudI Service API</a> service)
    but the subscribe function call only needs to
    be called with the string "json_rpc/" so that a subscription takes place
    for any services sending requests to "/cloudi/api/json_rpc/",
    which is called a "name".
  </p>
  <p class="paragraph">
    The requests are load balanced across all the services that have subscribed
    to the same name during the lookup to find the request destination.
    There is a service configuration parameter called the "destination refresh"
    that determines how the internal CloudI load balancing occurs when a
    request is sent from that service.  The possible destination refresh
    values are: 
  </p>
  <ul>
    <li>lazy_closest</li>
    <li>lazy_furthest</li>
    <li>lazy_random</li>
    <li>lazy_local</li>
    <li>lazy_remote</li>
    <li>lazy_newest</li>
    <li>lazy_oldest</li>
    <li>immediate_closest</li>
    <li>immediate_furthest</li>
    <li>immediate_random</li>
    <li>immediate_local</li>
    <li>immediate_remote</li>
    <li>immediate_newest</li>
    <li>immediate_oldest</li>
    <li>none</li>
  </ul>
  <p class="paragraph">
    The "none" destination refresh is used for services that never send
    requests (i.e., they only receives requests) and creates
    an error that terminates the service if the service does send a request.
    The "lazy" prefix destination refresh methods use an older cached value
    for determining service destinations, so services that communicate
    primarily with long-lived services can use a "lazy" prefix destination
    refresh for more scalable communication.  The "immediate" prefix
    destination refresh methods always use current information for
    determining service destinations, so services that communicate primarily
    with short-lived services can always send to relevant destinations.
    The "closest" suffix destination refresh methods always prefer
    services that exist on the local CloudI node, over remote CloudI nodes.
    The "random" suffix destination refresh methods load balances evenly
    across all services on all CloudI nodes.
  </p>
  <p class="paragraph">
    The following functions exist in the CloudI API for sending a request:
  </p>
  <ul>
    <li><a href="api.html#1_send_async">send_async</a></li>
    <li><a href="api.html#1_send_sync">send_sync</a></li>
    <li><a href="api.html#1_mcast_async">mcast_async</a></li>
  </ul>
  <p class="paragraph">
    The "send" prefix functions send a binary message (uninterpreted raw data)
    to a single service name (which is then load balanced among the available
    services).  If the service name does not exist, the request will be retried
    until the request timeout elapses and no binary data will be returned
    (i.e., returning no data is equivalent to a timeout).  
    If a service receives a request while handling an older request, the
    request is queued based on its priority, where -128 is the highest
    priority, 0 is the default priority and 127 is the lowest priority.
    The "mcast" prefix
    function provides publish functionality, so a binary message is published
    to all services that have subscribed to a single service name.  However,
    the "mcast" prefix function is slightly different from other publish
    functionality because it returns all the transaction ids (UUIDs used
    to uniquely identify a request among all CloudI nodes) so that responses
    (if any are returned) may be retrieved.  A service can utilize publish
    behavior that doesn't return data by simply returning no data
    (since returning no data is equivalent to a timeout).  The "async" suffix
    functions (i.e., asynchronous) only return the transaction id of the
    sent request(s) so that the response may be queried with the
    "<a href="api.html#1_recv_async">recv_async</a>" function.
    The "<a href="api.html#1_recv_async">recv_async</a>" function
    can also be used with a
    null UUID to return the oldest response that was received.
    If no services are available for the name of
    the destination, the "async" suffix function will block until the
    destination is found to send the request by retrying the send until
    the timeout elapses (i.e., the asynchronous sends are asynchronous after
    the send takes place).  The "sync" suffix function will block until
    a response is returned or the timeout elapses.  If a response is returned
    with no data, a timeout will be returned instead.  If the request
    destination name is blocked by an Access Control List (ACL) entry, a
    timeout will be returned immediately from the send function.
  </p>
  <p class="paragraph">
    When a service receives a request, it is passed as a parameter to the
    callback function.  The callback function was specified as an argument
    to the "<a href="api.html#1_subscribe">subscribe</a>" function.
    However, in Erlang all requests use the
    same callback function which is cloudi_service_handle_request/11.
    Within the callback function any send or receive operations can take place.
    When the callback function wants to terminate it can either return a result
    or forward the request to another service name by using the "return"
    function or the "<a href="api.html#1_forward">forward</a>" function,
    respectively.  If the service does not
    want to return a response, the service can simply call
    "<a href="api.html#1_return">return</a>" with
    an empty binary response value and it will be interpreted as if the
    request timeout elapsed.  Using the
    "<a href="api.html#1_forward">forward</a>" function will decrease the
    request timeout slightly (by 100ms) to prevent requests from causing
    persistent traffic.
  </p>
  <p class="paragraph">
    The Access Control List (ACL) is simply a list of strings that define
    patterns that must be explicitly allowed or denied when determining if a
    service can send to the service name.
    An ACL string uses the wildcard characters "*" and "?" to match one or more
    characters (in the same way service name patterns are matched).
  </p>
  <p class="paragraph">
    If an ACL pattern is both allowed and
    denied, the pattern is denied (deny takes precedence).  When defining ACLs,
    it is possible to use Erlang atoms to represent lists of string patterns
    so that logical groupings are created.  The ACL atoms are then able to
    be specified anywhere an ACL string might be present.  So, it is
    best to group ACL string patterns based on context to simplify the
    configuration specification.
  </p>
  <p class="paragraph">
    The CloudI API external service requests are limited to 2GB.
    External service configuration
    can specify the number of threads per process and the number of processes
    which should be spawned, so that each thread receives an instance of the
    CloudI API.  This means that there can be one ioloop per thread per process
    for maximum throughput.
  </p>
  <h4 id="4_API_HTTP"><a href="#6_HTTP">HTTP</a></h4>
  <p class="paragraph">
    The Erlang service cloudi_service_http_cowboy
    (or cloudi_service_http_elli) accepts HTTP traffic and
    makes the HTTP requests CloudI requests where the HTTP path in the URL
    is used as the service name.
    By default, the HTTP method is specified as a suffix on the HTTP path
    (e.g., "/index.html/get") but this can be disabled with the
    "use_method_suffix" configuration parameter.
    When a HTTP request is received
    the corresponding service name will be called with the request contents
    (uncompressed, if the request was compressed).  The headers are passed
    within the "request info" as key-value pairs that is request meta-data.
    The content type of the
    response is either forced by the configuration (with "content_type") or
    it is determined by the file extension on the service name.
  </p>
  <h4>Supported Databases</h4>
  <p class="paragraph">
    While various database CloudI services have been created and used,
    it is much better to focus on using your native database client
    within the business logic of a CloudI service.  Otherwise, it would be
    difficult to manage the fault-tolerance related to database usage
    since many errors in business logic are due to database usage
    unique to the business logic.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <h3 id="4_ServiceAPI">4.2 - How do I control CloudI dynamically?</h3>
  <p class="paragraph">
    CloudI's configuration can be changed dynamically while it is running
    by using the <a href="api.html#CloudI">CloudI Service API</a>.
    The CloudI Service API can be used by any CloudI
    services with service requests to the configured
    cloudi_service_api_requests service or as Erlang function calls to the
    cloudi_service_api module.  However, typical usage of the
    CloudI Service API would use raw HTTP requests or JSON-RPC over HTTP, using
    both a configured cloudi_service_http_cowboy service and a configured
    cloudi_service_api_requests service.  A complex example of using the
    CloudI Service API through JSON-RPC over HTTP with python code can be found in <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/service_api/run.py" rel="noopener" target="_blank">src/tests/service_api/run.py</a>.
    Some simpler examples of using the CloudI Service API can be found at
    <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/service_api/path.py" rel="noopener" target="_blank">src/tests/service_api/path.py</a>,
    <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/service_api/logging_off.py" rel="noopener" target="_blank">src/tests/service_api/logging_off.py</a> and
    <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/service_api/logging_on.py" rel="noopener" target="_blank">src/tests/service_api/logging_on.py</a>.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <h3 id="4_PubSub">4.3 - How do I use Publisher/Subscriber messaging?</h3>
  <p class="paragraph">
    The simplest way to use publisher/subscriber functionality is to use the
    CloudI API functions "<a href="api.html#1_mcast_async">mcast_async</a>"
    for publishing and "<a href="api.html#1_subscribe">subscribe</a>" for
    subscribing.  For more details please refer to the <a href="#4_API">CloudI API documentation</a>.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <h3 id="4_RPC">4.4 - How do I use Remote Procedure Calls (RPC)?</h3>
  <p class="paragraph">
    Remote procedure calls can easily be used within CloudI services with a
    CloudI API "<a href="api.html#1_send_sync">send_sync</a>" function call.
    The RPC procedure name is used
    as a service name suffix and the RPC parameters are stored in the
    request body.  The request body is simply uninterpreted
    binary data, so no format is imposed on the user of the CloudI API.
    Any request meta-data should be specified as key-value pairs within the
    "request info" parameter.  The "response info" parameter can be used
    for response meta-data in the same way.
    For more details please refer to the <a href="#4_API">CloudI API documentation</a>.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <h3 id="4_WebServices">4.5 - How do I create Web Services?</h3>
  <p class="paragraph">
    Web Services are simply CloudI services that accept incoming HTTP traffic
    coming from the cloudi_service_http_cowboy service.  The request body is
    either the body of the uncompressed PUT or POST request, or it is the
    GET query string.
    For more details please refer to the
    <a href="#6_HTTP">HTTP Integration</a> documentation.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <h3 id="4_WebSockets">4.6 - Does CloudI support WebSockets?</h3>
  <p class="paragraph">
    CloudI supports WebSocket connections with the cloudi_service_http_cowboy
    service, when it is configured with "{use_websockets, true}".  Incoming
    HTTP requests become CloudI service requests which return the service
    response as a HTTP response, with the HTTP headers passed in the
    RequestInfo and ResponseInfo as key-value data
    (<a href="#6_HTTP">HTTP Integration</a>).  Incoming WebSocket requests
    add a "/get" suffix on the URL to create the service name used for the
    service request (when configured with "{use_method_suffix, true}",
    the default).
  </p>
  <p class="paragraph">
    Outgoing WebSocket CloudI service requests are also possible if the
    WebSocket connection URL matches the cloudi_service_http_cowboy
    service prefix in its service configuration.  The outgoing CloudI service
    requests can be sent to the WebSocket URL with a "/websocket" suffix added.
    All outgoing CloudI service requests expect a response from the WebSocket
    client within the service request timeout period.  An <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/public_html/websockets.html" rel="noopener" target="_blank">example</a>
    (using an <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/websockets/websockets.py" rel="noopener" target="_blank">example service</a>)
    of the WebSocket functionality exists at <a href="http://127.0.0.1:6464/tests/http_req/websockets.html" target="_blank">http://127.0.0.1:6464/tests/http_req/websockets.html</a>
    when CloudI is running with the default configuration.  It is important
    to enforce the request/response order within the WebSocket client to avoid
    erroneous service request responses (the example demonstrates this when
    the "Request" link is rapidly clicked repeatedly).
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <h3 id="4_ACLs">4.7 - How do I use Access Control Lists (ACLs)?</h3>
  <p class="paragraph">
    Access Control Lists (ACLs) are used to explicitly allow or deny requests
    from being sent to service name patterns.
    An ACL string uses the wildcard characters "*" and "?" to match one or more
    characters (in the same way service name patterns are matched).
    Two separate ACL parameters are
    specified for each service configuration to allow or deny destinations.
    If an ACL is not provided, the atom 'undefined' is used instead.  An ACL is
    provided as a list of strings that are service name patterns.  Instead of a
    string, an atom alias may be provided that was defined in the 'acl'
    configuration so that the service configuration is simpler and more
    consistent (i.e., without strings that are replicated among the service
    configuration entries).  A fake sample from a configuration file can
    illustrate how this works:
  </p>
<pre>
{acl, [
    {alias1, ["/service/name/prefix1", "/service/name/prefix2*", alias2]},
    {alias2, ["/subsystem1/prefix1*", "/subsystem2/prefix1"]}
]}.
{services, [
    {internal,
     (ServiceNamePrefix),
     (ErlangModuleName),
     (ModuleInitializationList),
     (DestinationRefreshMethod),
     (InitializationTimeout),
     (DefaultAsynchronousTimeout),
     (DefaultSynchronousTimeout),

     % ACL DENY LIST
     % (e.g, valid values could be: undefined or [alias1] or [alias2] or etc.)
     (DestinationDenyList),
     
     % ACL ALLOW LIST
     % (e.g, valid values could be: undefined or [alias1] or [alias2] or etc.)
     (DestinationAllowList),

     (ProcessCount),
     (MaxR),
     (MaxT),
     (ServiceOptionsPropList)},
    {external,
     (ServiceNamePrefix),
     (ExecutableFilePath),
     (ExecutableCommandLineArguments),
     (ExecutableEnvironmentalVariables),
     (DestinationRefreshMethod),
     (Protocol),
     (ProtocolBufferSize),
     (InitializationTimeout),
     (DefaultAsynchronousTimeout),
     (DefaultSynchronousTimeout),

     % ACL DENY LIST
     % (e.g, valid values could be: undefined or [alias1] or [alias2] or etc.)
     (DestinationDenyList),

     % ACL ALLOW LIST
     % (e.g, valid values could be: undefined or [alias1] or [alias2] or etc.)
     (DestinationAllowList),

     (ProcessCount),
     (ThreadCount),
     (MaxR),
     (MaxT),
     (ServiceOptionsPropList)},
]}.
...
</pre>
  <p class="paragraph">
    The <a href="api.html#2_services_add">CloudI Service API</a>
    supports dynamically starting services by supplying a
    'services' list in the same format as the configuration file.
    The CloudI Service API also supports defining multiple 'acl' aliases that
    may be referenced from dynamically configured services.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <h3 id="4_ServiceFail">4.8 - How do I Migrate a Service from a Failed or Failing Node?</h3>
  <p class="paragraph">
    A migration would imply that there is unavoidable latency during a
    switchover from a failed node to a healthy node.  To avoid failover latency
    and improve scalability, services are replicated on all nodes.  Proper
    service implementation dictates that services will only cache data.
    All dynamic state a service uses should be accessed and/or stored by a
    database.  The implementation of services that avoids state-keeping within
    the service's data structures is required to ensure a service is
    scalable, fault-tolerant and reliable (i.e., no data-loss).
  </p>
  <p class="paragraph">
    So, a service should not need to be migrated from a node.  If a node has
    failed there are many possible courses of action:
  </p>
  <ul>
    <li>Shutdown CloudI on the Failed Node</li>
    <li>Stop the Service on the Failed Node by using the <a href="api.html#CloudI">CloudI Service API</a></li>
    <li>Disconnect the Failed Node from the Network to Diagnose in Isolation</li>
  </ul>
  <p class="paragraph">
    Since services are replicated on other nodes the system is fault-tolerant
    and can operate without a failed node.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <h3 id="4_URLregex">4.9 - Can I use Regular Expressions with Service Names (URLs)?</h3>
  <p class="paragraph">
    A string matching syntax simpler than regular expressions is provided
    for matching CloudI service names.  Both "*" and "?" are used as
    wildcard characters in service name patterns to match one or more
    characters of a service name.
    "?" never matches the character that follows it and is unable to be
    the last service name pattern character
    (i.e., "/?/" matches "/a/" but never "/a/b/" while "/*/" will match either).
    Attempting to use wildcard characters together (e.g., "?*" or any other
    combination) is invalid and will cause the operation to fail.
    Any number of wildcard characters may be used with the service name
    pattern string argument of the CloudI API functions
    <a href="api.html#1_subscribe">subscribe</a>
    and <a href="api.html#1_unsubscribe">unsubscribe</a>
    to match any service names the service wants to receive.
    While this approach may seem unusual, it helps keep service name
    lookups both efficient and parallel (i.e., within the Erlang code,
    without any need to call an external regex integration library).
    For more details refer to
    <a href="#4_NamePattern">"4.10 - How do Service Name Patterns work?"</a>.
  </p>
  <p class="paragraph">
    Another possibility is just using explicit service names, even when the
    service name contains a dynamic parameter.  Using all possible service
    names is bounded by the memory available.  To give an idea of the memory
    consumption, on a 64-bit machine using service names that contain a
    single dynamic integer, 1 million integers used within 1 million
    subscribe CloudI API calls will consume roughly 100 MB of RAM when the
    CloudI service is ran (i.e., the service that performs the subscribe
    CloudI API calls).  All other CloudI services that use a "lazy"
    destination refresh method will replicate the service name data
    structure, so that will increase the node's memory consumption.
    So, depending on your needs and your memory limitations, you may want to
    use explicit service names or service names with wildcard characters.
    Using wildcard characters is normally a more efficient choice due
    to the memory consumption and its impact on caching but it puts the burden
    of validation on the source code handling the service request.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <h3 id="4_NamePattern">4.10 - How do Service Name Patterns work?</h3>
  <p class="paragraph">
    Service name patterns are strings that may contain any number of
    the wildcard characters "*" and "?".  Both "*" and "?" match
    one or more characters of a service name.
    "?" never matches the character that follows it and is unable to be
    the last service name pattern character
    (i.e., "/?/" matches "/a/" but never "/a/b/" while "/*/" will match either).
    Attempting to use wildcard characters together (e.g., "?*" or any other
    combination) is invalid and will cause the operation to fail.
    The CloudI API
    <a href="api.html#1_subscribe">subscribe</a>
    function call takes a service name pattern parameter
    that is used to represent the service requests the service wants
    to receive.  The service name patterns are matched with
    (non-pattern) service names provided to a CloudI API
    <a href="api.html#1_send_async">send_async</a>,
    <a href="api.html#1_send_sync">send_sync</a>, or
    <a href="api.html#1_mcast_async">mcast_async</a> function when
    sending a service request.
  </p>
  <p class="paragraph">
    When a service name pattern exists that overlaps an exact service name,
    the most exact service name match is preferred, e.g.:
  </p>
  <ul>
    <li>Service A subscribes to "/accounting/balances/*"</li>
    <li>Service B subscribes to "/accounting/balances/fred"</li>
  </ul>
  <p class="paragraph">
    Service B will receive a service request sent to
    "/accounting/balances/fred" but Service A will receive all other service
    requests that match the prefix "/accounting/balances/".
  </p>
  <p class="paragraph">
    When several wildcard characters are used, the most exact service name
    match is preferred, where left-most characters are given more
    significance, e.g.:
  </p>
  <ul>
    <li>Service A subscribes to "/permissions/*/accounts/*"</li>
    <li>Service B subscribes to "/permissions/fred/accounts/*"</li>
    <li>Service C subscribes to "/permissions/*/accounts/add"</li>
    <li>Service D subscribes to "/permissions/fred/accounts/remove"</li>
  </ul>
  <p class="paragraph">
    Service B will receive a service request sent to
    "/permissions/fred/accounts/add", instead of Service C, because
    the left-most characters provide a more exact match.
    Service name prefixes within the service configuration provide a scope
    for the service name subscriptions and the prefix shows the significance
    of the left-most characters being used (the example above would likely
    utilize services with prefixes configured as "/permissions"
    with <a href="api.html#1_subscribe">subscribe</a> using the
    service name pattern argument "/*/accounts/*" in Service A).
  </p>
  <p class="paragraph">
    To avoid potential ambiguity, the service name patterns above are best as:
  </p>
  <ul>
    <li>Service A subscribes to "/permissions/?/accounts/*"</li>
    <li>Service B subscribes to "/permissions/fred/accounts/*"</li>
    <li>Service C subscribes to "/permissions/?/accounts/add"</li>
    <li>Service D subscribes to "/permissions/fred/accounts/remove"</li>
  </ul>
  <p class="paragraph">
    Using a "?" wildcard character instead of the "*" wildcard character
    ensures the match will not contain a "/" character
    (due to "/" being the character after "?").  The "?" wildcard character
    takes precedence when the "*" wildcard character is also present
    (e.g., if "/permissions/*/accounts/*" and "/permissions/?/accounts/*"
     are both valid matches, "/permissions/?/accounts/*" will be picked).
    The service name pattern subscriptions may be checked by using the
    <a href="api.html#2_services_search">services_search</a>
    CloudI Service API function to determine what services would
    receive a service request that uses the provided service name.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <h3 id="4_ThreadSafe">4.11 - Is the CloudI API thread-safe?</h3>
  <p class="paragraph">
    The <a href="api.html#Service">CloudI API</a> is not thread-safe
    (i.e., it is not reentrant)
    because it is meant to be used by individual threads that are configured
    within the CloudI service configuration (e.g., using the CloudI
    configuration file or the
    <a href="api.html#2_services_add_config">CloudI Service API</a>).
    This approach avoids any lock contention issues outside of the Erlang VM.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <h3 id="4_Speed">4.12 - How can CloudI requests take advantage of cache coherency, minimum network latency, and any logical grouping?</h3>
  <p class="paragraph">
    To provide better computing node grouping, service names should uniquely
    describe the context of the node.  If the context is provided, then there
    is a natural grouping for CloudI requests with any
    <a href="api.html#Service">CloudI API</a>
    usage that uses the associated service name(s).
    <a href="#4_NamePattern">Service name patterns</a>
    can provide extra flexibility for grouping service functionality.
    The destination refresh method can minimize network latency by preferring
    local services before using remote services (i.e., a "closest"
    <a href="api.html#1_Intro_dest">destination refresh method</a>).
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <h3 id="4_Erlang">4.13 - Why not just use Erlang directly?</h3>
  <p class="block">
    Erlang does naturally support integration in the following ways:
  </p>
  <ul>
    <li>NIF (Native Interface Function)</li>
    <li>port drivers</li>
    <li>port</li>
    <li>cnode</li>
  </ul>
  <p class="paragraph">
    NIFs and port drivers can integrate with external source code
    (normally only C or C++) as a dynamic library that is loaded by the
    Erlang VM.  This approach is the most efficient and the most
    error-prone (any memory corruption impacts the Erlang VM to create new
    and exciting system crashes, sabotaging the fault tolerance the Erlang VM
    provides).  A port is an external executable ran as a separate OS
    process linked to the Erlang VM, communicating over pipes.  A cnode is
    a separate executable communicating as an Erlang node with the
    distributed Erlang protocol.
  </p>
  <p class="paragraph">
    CloudI's external service execution is most similar to Erlang port
    integration.  However, CloudI provides many additional features for
    services that are normally not present:
  </p>
  <ul>
    <li>A Microservice abstraction for simpler <a href="https://en.wikipedia.org/wiki/Service_oriented_architecture" rel="noreferrer" target="_blank">Service Oriented Architecture (SOA)</a> development (Erlang processes are considered "Nanoservices").</li>
    <li>Any service can <a href="api.html#2_services_update" target="_blank">easily be updated</a> without downtime (<a href="https://erlang.org/doc/design_principles/appup_cookbook.html" rel="noreferrer" target="_blank">Erlang/OTP upgrades</a> require large amounts of ad-hoc development for upgrades).</li>
    <li>Protocol agnostic transactional communication with a small consistent API (i.e., the <a href="api.html#Service" target="_blank">CloudI API</a>).</li>
    <li>Each external service thread uses its own <a href="api.html#Service" target="_blank">CloudI API</a> object with a separate connection to the Erlang VM which avoids any contention that is normally seen with Erlang ports, Erlang cnodes and Erlang jinterface usage.</li>
    <li>All services are managed with fault tolerance constraints, in the same way as Erlang/OTP supervisors.</li>
    <li>All services are both started and stopped with an explicit order but Erlang/OTP application order is provided by release creation which creates ambiguity due to the top-level application's dependencies.</li>
    <li>A service can use service configuration options to easily adjust efficiency and memory consumption (e.g., <a href="api.html#2_services_add_config_opts" target="_blank">queue_limit, hibernate, request_pid_options, etc.</a>).</li>
    <li>Internal services can automatically handle more throughput than Erlang/OTP behaviors with <a href="api.html#2_services_add_config_opts" target="_blank">duo_mode</a> set within the service configuration options.</li>
    <li>Every service request receives a unique UUID (Universally Unique IDentifier).</li>
    <li>A service request timeout is decreased by any queuing or processing delays to provide better soft-realtime timeout enforcement than what Erlang/OTP provides.</li>
    <li>Service name grouping with <a href="#4_URLregex">pattern matching</a>.</li>
    <li>Every service request can utilize 255 possible request priorities</li>
    <li>TCP sockets are used instead of pipes to maximize atomic send throughput (pipes are typically 4096 on Linux (PIPE_BUF) while the localhost MTU on Linux is much higher).</li>
    <li>stdout and stderr output is logged automatically to the single CloudI log.</li>
    <li>A service does not require a node connection (like a cnode does), so it doesn't have service-count scalability problems (due to a distributed Erlang node being a member of a fully connected network topology).</li>
    <li>A long-running CloudI internal service is much more dependable when compared to a single Erlang process due to CloudI providing specific hints to the Erlang VM's garbage collection that avoids excessive memory consumption.</li>
    <li>Any transactions are more dependable in a CloudI external service when compared to NIFs or port drivers due to the potential for unexpected latency that can cause the Erlang VM scheduler to "lock-up" when NIF or port driver latency exceeds 1&nbsp;millisecond (a failure that requires manual recovery efforts).  To avoid the "lock-up" the dirty scheduler is used by a NIF with slower execution as a result, though causing instability within the Erlang VM is always possible with NIFs or port drivers.</li>
    <li>Core Erlang/OTP source code does not handle node-splits (global name registration, global transactions and mnesia are common examples), but CloudI provides master-less fault tolerance for a cluster of any number of CloudI nodes on an unreliable network.</li>
  </ul>
  <p class="paragraph">
    The <a href="api.html#Service" target="_blank">CloudI API</a> is
    consistent for all the supported programming languages,
    which makes it easier to move service functionality inbetween programming
    languages or inbetween services.  All external CloudI services communicate
    in the same way and all service requests are processed in the same way,
    to create a consistent integration framework.  Using CloudI naturally
    reduces the complexity of integration source code so that errors are more
    specific to the business logic being developed, because CloudI is
    continuously tested to ensure it provides both a stable and dependable
    integration framework.
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <h3 id="4_Null">4.14 - What is a null response (How do timeouts occur)?</h3>
  <p class="paragraph">
    A null response is when a service responds to a service request with
    both ResponseInfo and Response set to a binary of size 0.
    The sender of the service request will see the null response as a timeout.
  </p>
  <p class="paragraph">
    Whether a service request is completely asynchronous is determined
    by the service that handles the request (i.e., by returning a null response
    the service that handles the request is making the service request
    asynchronous, due to it having control of the request at that point in
    time).  When a null response is used, the sender will not know whether the
    service request was handled or if the timeout expired.
    (By using the phrase "completely asynchronous" above, the service name
    lookup blocking for the timeout period is ignored due to being a typical
    fault tolerance requirement, though blocking can be disabled with the
    <a href="api.html#2_services_add_config_opts">'request_name_lookup'
    service configuration option</a>.)
  </p>
  <p class="paragraph">
    To avoid blocking the sender for the timeout period when a null response is
    used the <a href="api.html#2_services_add_config_opts">'response_timeout_immediate_max' service configuration option</a>
    can be set to change how large a timeout value must be to provide the
    null response to the sender (i.e., some timeouts are short enough that
    there is no need to provide the null response, due to it wasting
    computational time, since it is the same as a timeout).  The timeout value
    will also be influenced by the <a href="api.html#2_services_add_config_opts">'request_timeout_adjustment' service configuration option</a>
    (due to it decreasing the timeout value based on the time spent
     handling the service request, i.e., not just the time spent before the
     service request is handled (which always reduces the timeout value)).
  </p>
  <div class="top"><a href="#4_contents">Top</a></div>

  <hr>
  <h2>5 - Migrating to CloudI</h2>

  <h3 id="5_Performance">5.1 - Performance Considerations</h3>
  <p class="paragraph">
    There is a latency penalty for communicating with a non-Erlang CloudI
    service because of the extra binary encoding and decoding when using
    the socket that connects the CloudI Erlang VM to the non-Erlang CloudI
    service Operating System (OS) process' thread.  The preemption of
    an Erlang VM scheduler thread (an Erlang process is data
    executed and scheduled as a user-level thread with the Erlang VM's
    use of kernel-level threads)
    by a CloudI service OS thread (a kernel-level thread from the OS) may
    degrade Erlang VM performance because of a mismatch between the
    kernel scheduler and the Erlang VM scheduler.  The kernel scheduler is
    slow to preempt OS processes while the Erlang VM is quick to preempt
    its light-weight processes
    (<a href="https://jlouisramblings.blogspot.com/2013/01/how-erlang-does-scheduling.html" rel="noreferrer" target="_blank">to pursue soft-realtime low-latency</a>)
    based on the process' internal reduction count.
    The mismatch between the kernel scheduler and the Erlang VM scheduler is
    minimized by CloudI's management of CloudI service requests, since an
    external service thread is only provided a single request at a time
    (and the mismatch is required to provide fault tolerance by isolating the
     memory used by external services from the Erlang VM memory).
  </p>
  <p class="paragraph">
    When the number of requests sent to a service name exceeds the number
    of service processes, the destination service processes will begin to
    queue new requests while
    handling older requests (the distribution of requests to processes
    is random, so it may queue slightly early).  A priority parameter can be
    used if there is differing importance for various service requests
    (priority is normally used when there is a data dependency that needs to
    be solved).  The priority parameter is 0 by default, but -128 is the
    highest priority and 127 is the lowest priority, so that provides much
    room for representing asynchronous data dependencies (synchronous data
    dependencies would use a pipe pattern) or simply processing time priority.
  </p>
  <div class="top"><a href="#5_contents">Top</a></div>

  <h3 id="5_Scalability">5.2 - Scalability Considerations</h3>
  <p class="paragraph">
    CloudI uses distributed Erlang for communicating between CloudI
    nodes (i.e., machines).  By default, distributed Erlang creates a
    fully-connected network topology by using connections that are called
    "visible" (since the node connections are commonly visible to other nodes).
    When all nodes are using visible connections, the cluster size is
    limited to somewhere between 50 and 100 nodes (when using the <a href="https://www.erlang.org/doc/man/net_kernel.html#set_net_ticktime-1" rel="noreferrer" target="_blank">default net_tick_time</a>
     of 60 seconds with a common Gigabit Ethernet network).
  </p>
  <p class="paragraph">
    To have a larger network of CloudI nodes, a network topology that is not
    fully-connected can be created with the nodes configuration items
    "listen" and "connect" (described in the <a href="api.html#2_nodes_set">nodes_set CloudI Service API</a>
     documentation).  By setting "connect" to "hidden" the CloudI node will not
    make a fully-connected network topology and each connection will be a
    single connection limited to that Erlang node.  To receive service name
    pattern subscription data from hidden nodes, the "listen" item can be set
    to "all".  The node connection settings can be used with the node
    discovery settings to make the network topology creation automatic
    based on the nodes configuration.
  </p>
  <p class="paragraph">
    SSH or HTTPS may be used to bridge CloudI clusters
    (i.e., with the CloudI service cloudi_service_router or
     cloudi_service_http_cowboy).
    Scaling for capacity planning should often require increasing the
    database node count more than the CloudI node count, but that depends
    on the CloudI services and their incoming data rate.
  </p>
  <div class="top"><a href="#5_contents">Top</a></div>

  <h3 id="5_Stability">5.3 - Stability and Fault Tolerance Considerations</h3>
  <p class="paragraph">
    CloudI software release and versioning utilizes
    <a href="https://semver.org/" rel="noreferrer" target="_blank">semantic versioning</a>
    to make any upgrade considerations more explicit.  Any other stability
    concerns are related to CloudI integration.
  </p>
  <p class="paragraph">
    CloudI requests are not sent in a way that is meant to be persistent
    to simplify error-handling.  Otherwise, fault-tolerant messaging would
    preserve requests that are irrelevant and/or erroneous at a future time.
    Instead, CloudI requests can cause a service to crash which means that
    the request is not handled by another service since it is unclear whether
    the request is erroneous or the service is buggy.  CloudI requests also
    have a certain lifetime defined by the request timeout, so that the
    relevance of the request data is limited by the timeout.  The request
    timeout acts to conserve processing time for the most relevant data and
    the services that require the data.  If data needs to be fault-tolerant,
    the data should be stored within a database.
  </p>
  <p class="paragraph">
    Error-handling should always be local (i.e., internal to the service)
    where the errors are most relevant.  Any invalid or corrupt service data
    can terminate the service and will trigger a restart of the service based
    on its configuration parameters.  A service should never be allowed to
    function in a zombie-state since this would only complicate performance,
    testing, debugging and development.
  </p>
  <p class="paragraph">
    The service must exit whenever an unrecoverable error occurs.  If a
    CloudI request causes an exception, the request will fail but the service
    will not be restarted.  So, services should always have proper exception
    handling, to ensure the context of any errors is explicit
    (otherwise, the service source code will become difficult to maintain
    if any CloudI requests fail).  Without service exception handling,
    the exception will cause exception information to be logged, however, the
    information may be minimal (this depends on the limits of the programming
    language used).
  </p>
  <p class="paragraph">
    The non-Erlang CloudI services receive their own Operating System (OS)
    process, so they are well isolated from the Erlang VM's memory.  However,
    Erlang CloudI services could be written with malevolent intentions which
    would make CloudI unstable or erroneous.  This means that Erlang CloudI
    service code must have a greater amount of implicit trust that the
    programmer is not trying to cause problems.  With non-Erlang CloudI
    services there isn't as much concern about whether there are problems
    within the software, since the errors receive isolation within the
    CloudI framework.
  </p>
  <div class="top"><a href="#5_contents">Top</a></div>

  <h3 id="5_Integration">5.4 - Integration Considerations</h3>
  <p class="paragraph">
    The stdout and stderr of any non-Erlang CloudI service is captured and
    sent separately to be logged by CloudI with the associated Operating System
    (OS) process id.  The <a href="api.html#Service">CloudI API</a>
    makes sure that both the stdout and the
    stderr streams are unbuffered within an external CloudI service, so the
    output will be logged as quickly as possible within the CloudI log as
    error data (for stderr data) or as info data (for stdout data).
  </p>
  <p class="paragraph">
    Any Erlang CloudI services can utilize CloudI's logging
    (ideally for information related to service problems or failures)
    for asynchronous logging (logging that does not carry a performance
    penalty).
  </p>
  <div class="top"><a href="#5_contents">Top</a></div>

  <h3 id="5_LoadTesting">5.5 - Load Testing</h3>
  <p class="paragraph">
    Since the 1.0.0 CloudI release, the http_req test has been used for
    executing various (<a href="http://tsung.erlang-projects.org/" rel="noreferrer" target="_blank">Tsung</a>)
    loadtests which have guided development and configuration
    decisions.  The main goal has been to reduce the latency due to
    external service integration, but it has also helped to minimize internal
    service latency.  The http_req test is a simple HTTP GET request query
    parameter that creates an XML response with the parsed integer.
    Typically, the loadtests have used 20 thousand concurrent connections
    with each connection performing 10 thousand requests per second.
    To keep the loadtesting fair, each http_req test was given a single
    OS process (and/or a single Erlang process) with no threads usage.
    All programming languages received the same amount of load, so that the
    loadtesting results can be compared when making CloudI integration
    decisions.  Below are summaries specific to past releases:
  </p>
  <ul>
    <li><a href="https://github.com/CloudI/loadtests/raw/master/tests/http_req/loadtest/results_v1_5_1/201512_summary.pdf" rel="noopener" target="_blank">1.5.1 summary</a></li>
    <li><a href="https://github.com/CloudI/loadtests/raw/master/tests/http_req/loadtest/results_v1_4_0/201412_summary.pdf" rel="noopener" target="_blank">1.4.0 summary</a></li>
    <li><a href="https://github.com/CloudI/loadtests/raw/master/tests/http_req/loadtest/results_v1_2_2/201306_summary.pdf" rel="noopener" target="_blank">1.2.2 summary</a></li>
    <li><a href="https://github.com/CloudI/loadtests/raw/master/tests/http_req/loadtest/results_v1_2_1/201303_summary.pdf" rel="noopener" target="_blank">1.2.1 summary</a></li>
    <li><a href="https://github.com/CloudI/loadtests/raw/master/tests/http_req/loadtest/results_v1_1_0/201210_summary.pdf" rel="noopener" target="_blank">1.1.0 summary</a></li>
  </ul>
  <p class="paragraph">
    To look at service request throughput to a single service name with a
    static request it is possible to use the request_rate test
    (to determine the maximum throughput for a service request during the
     service request timeout period without any errors or timeouts):
  </p>
  <ul>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_request_rate/results/results_v2_0_4#readme" rel="noopener" target="_blank">2.0.5 (prerelease) results (all CloudI API implementations)</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_request_rate/results/results_v1_7_1#readme" rel="noopener" target="_blank">1.7.1 results (all CloudI API implementations)</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_request_rate/results/results_v1_5_4#readme" rel="noopener" target="_blank">1.5.4 results (including cloudi_service_queue)</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_request_rate/results/results_v1_5_1/results.txt" rel="noopener" target="_blank">1.5.1 results</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_request_rate/results/results_v1_4_0/results.txt" rel="noopener" target="_blank">1.4.0 results</a></li>
  </ul>
  <p>
    The latency graphs below show service request performance during the 1.5.1
    <a href="https://github.com/CloudI/loadtests/raw/master/tests/http_req/loadtest/results_v1_5_1/201512_tsung_output.tar.bz2" rel="noopener" target="_blank">Tsung loadtests</a>
    of 20k connections at 10k req/s
    (with Erlang 18.2.1 and Ubuntu 12.04.5 using CloudI cowboy integration):
  </p>
  <ul>
    <li>
      C++/C
      <img alt="Load Test Mean Latency C" src="images/201512_graphes-Transactions-mean_c.png" /><br />
      <img alt="Load Test Min Latency C" src="images/201512_graphes-Transactions-min_sample_c.png" width="280" /><img alt="Load Test Max Latency C" src="images/201512_graphes-Transactions-max_sample_c.png" width="280" />
      <br /><br />
    </li>
    <li>
      Erlang
      <img alt="Load Test Mean Latency Erlang" src="images/201512_graphes-Transactions-mean_erlang.png" /><br />
      <img alt="Load Test Min Latency Erlang" src="images/201512_graphes-Transactions-min_sample_erlang.png" width="280" /><img alt="Load Test Max Latency Erlang" src="images/201512_graphes-Transactions-max_sample_erlang.png" width="280" />
      <br /><br />
    </li>
    <li>
      Java
      <img alt="Load Test Mean Latency Java" src="images/201512_graphes-Transactions-mean_java.png" /><br />
      <img alt="Load Test Min Latency Java" src="images/201512_graphes-Transactions-min_sample_java.png" width="280" /><img alt="Load Test Max Latency Java" src="images/201512_graphes-Transactions-max_sample_java.png" width="280" />
      <br /><br />
    </li>
    <li>
      Javascript
      <img alt="Load Test Mean Latency JavaScript" src="images/201512_graphes-Transactions-mean_javascript.png" /><br />
      <img alt="Load Test Min Latency JavaScript" src="images/201512_graphes-Transactions-min_sample_javascript.png" width="280" /><img alt="Load Test Max Latency JavaScript" src="images/201512_graphes-Transactions-max_sample_javascript.png" width="280" />
      <br /><br />
    </li>
    <li>
      Perl
      <img alt="Load Test Mean Latency Perl" src="images/201512_graphes-Transactions-mean_perl.png" /><br />
      <img alt="Load Test Min Latency Perl" src="images/201512_graphes-Transactions-min_sample_perl.png" width="280" /><img alt="Load Test Max Latency Perl" src="images/201512_graphes-Transactions-max_sample_perl.png" width="280" />
      <br /><br />
    </li>
    <li>
      PHP
      <img alt="Load Test Mean Latency PHP" src="images/201512_graphes-Transactions-mean_php.png" /><br />
      <img alt="Load Test Min Latency PHP" src="images/201512_graphes-Transactions-min_sample_php.png" width="280" /><img alt="Load Test Max Latency PHP" src="images/201512_graphes-Transactions-max_sample_php.png" width="280" />
      <br /><br />
    </li>
    <li>
      Python
      <img alt="Load Test Mean Latency Python/C" src="images/201512_graphes-Transactions-mean_python_c.png" />
      (with C integration)
      <br />
      <img alt="Load Test Min Latency Python/C" src="images/201512_graphes-Transactions-min_sample_python_c.png" width="280" /><img alt="Load Test Max Latency Python/C" src="images/201512_graphes-Transactions-max_sample_python_c.png" width="280" />
      <br /><br />
    </li>
    <li>
      Python
      <img alt="Load Test Mean Latency Python" src="images/201512_graphes-Transactions-mean_python.png" /><br />
      <img alt="Load Test Min Latency Python" src="images/201512_graphes-Transactions-min_sample_python.png" width="280" /><img alt="Load Test Max Latency Python" src="images/201512_graphes-Transactions-max_sample_python.png" width="280" />
      <br /><br />
    </li>
    <li>
      Ruby
      <img alt="Load Test Mean Latency Ruby" src="images/201512_graphes-Transactions-mean_ruby.png" /><br />
      <img alt="Load Test Min Latency Ruby" src="images/201512_graphes-Transactions-min_sample_ruby.png" width="280" /><img alt="Load Test Max Latency Ruby" src="images/201512_graphes-Transactions-max_sample_ruby.png" width="280" />
      <br /><br />
    </li>
  </ul>
  <div class="top"><a href="#5_contents">Top</a></div>

  <hr>
  <h2>6 - Services</h2>

  <h3 id="6_ATS">6.1 - ATS Service Implementation</h3>
  <p class="paragraph">
    The <a href="https://github.com/CloudI/CloudI/blob/master/src/api/ats/v2/cloudi.sats" rel="noopener" target="_blank">ATS CloudI API</a>
    provides an ATS2/Postiats interface to the C CloudI API for utilizing any
    <a href="https://en.wikipedia.org/wiki/ATS_(programming_language)" rel="noreferrer" target="_blank">ATS programming language</a>
    features in the implementation of a CloudI service.  The ATS CloudI API
    only utilizes the view types subset of the ATS2/Postiats programming
    language so it doesn't require compilation with garbage collection.
    That means the ATS CloudI API compilation utilizes -DATS_MEMALLOC_LIBC
    without ATS types causing memory leaks.  The ATS2/Postiats exception
    handling implementation is currently not thread-safe, so ATS service
    configurations should always have count_thread set to 1 (the default).
    Some of the integration tests that provide example usage of the ATS
    <a href="api.html#Service">CloudI API</a> are:
  </p>
  <ul>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/count/ats/v2/main.dats" rel="noopener" target="_blank">src/tests/count
        Basic Count Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/ats/v2/main.dats" rel="noopener" target="_blank">src/tests/http_req
        Basic HTTP Request Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/msg_size/ats/v2/main.dats" rel="noopener" target="_blank">src/tests/msg_size
        Basic Message Size (Forwarding) Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/messaging/ats/v2/main.dats" rel="noopener" target="_blank">src/tests/messaging
        Basic Messaging Test</a></li>
  </ul>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <h3 id="6_C">6.2 - C/C++ Service Implementation</h3>
  <p class="paragraph">
    There are separate header files that provide both a C CloudI API
    (<a href="https://github.com/CloudI/CloudI/blob/master/src/api/c/cloudi.h" rel="noopener" target="_blank">cloudi.h</a>)
    and a C++ CloudI API
    (<a href="https://github.com/CloudI/CloudI/blob/master/src/api/c/cloudi.hpp" rel="noopener" target="_blank">cloudi.hpp</a>) which are mutually exclusive.  The header
    files do not bring in external dependencies but both require the standard
    C++ library as a link-time dependency.  When compiling an executable that
    uses the C CloudI API with a C compiler, the '-fexceptions' C compiler
    flag is required to ensure source code is included to provide handling
    of C++ exceptions (add it to the CFLAGS).  The callback function type
    used by the C CloudI API allows passing a void * for thread-specific data
    to each execution of the callback function while the C++ CloudI API can
    utilize class data with callback functions that are class member functions.
    Some of the integration tests that provide example usage of the C/C++
    <a href="api.html#Service">CloudI API</a> are:
  </p>
  <ul>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/count/c/main.c" rel="noopener" target="_blank">src/tests/count (C, no threads)
        Basic Count Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/c/main.c" rel="noopener" target="_blank">src/tests/http_req (C, no threads)
        Basic HTTP Request Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/msg_size/cxx/main.cpp" rel="noopener" target="_blank">src/tests/msg_size (C++, no threads)
        Basic Message Size (Forwarding) Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/messaging/cxx/main.cpp" rel="noopener" target="_blank">src/tests/messaging (C++, threads)
        Basic Messaging Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/hexpi/cxx/main.cpp" rel="noopener" target="_blank">src/tests/hexpi (C++, threads)
        Hexadecimal PI Test</a></li>
  </ul>
  <p class="paragraph">
    If you need to run your service with valgrind, use valgrind as the
    executable in the service configuration and use the valgrind command line
    argument "--track-fds=yes" with the service command line after it.
    The valgrind output will appear within the cloudi.log output.  If you plan
    on using vgdb while valgrind is running, confirm {"USER", "${USER}"} is
    specified in the list of environment variables provided for valgrind
    (running as a CloudI service) so valgrind can properly create its
    vgdb file names.
  </p>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <h3 id="6_Erlang">6.3 - Erlang Service Implementation</h3>
  <p class="paragraph">
    Erlang CloudI services use the cloudi_service behavior to create an
    "internal" service (all non-Erlang CloudI services are "external").
    The cloudi_service behavior requires that the service implement the
    following functions:
  </p>
  <ul>
    <li>cloudi_service_init/4</li>
    <li>cloudi_service_handle_request/11</li>
    <li>cloudi_service_handle_info/3</li>
    <li>cloudi_service_terminate/3</li>
  </ul>
  <p class="paragraph">
    Many examples of Erlang CloudI services exist within the CloudI source code
    because the Erlang CloudI services provide integration with external
    systems like the supported databases (PostgreSQL, MySQL, etc.),
    the supported messaging (HTTP, SSH, etc.), and the CloudI Service API
    functionality.  Some of the integration tests and services that
    provide example usage of the Erlang
    <a href="api.html#Service">CloudI API</a> are:
  </p>
  <ul>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/count/erlang/src/cloudi_service_test_count.erl" rel="noopener" target="_blank">src/tests/count
        Basic Count Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/erlang/src/cloudi_service_test_http_req.erl" rel="noopener" target="_blank">src/tests/http_req
        Basic HTTP Request Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/msg_size/erlang/src/cloudi_service_test_msg_size.erl" rel="noopener" target="_blank">src/tests/msg_size
        Basic Message Size (Forwarding) Test</a></li>
    <li>src/tests/messaging 
        Basic Messaging Test (<a href="https://github.com/CloudI/CloudI/blob/master/src/tests/messaging/erlang/src/cloudi_service_test_messaging_sequence1.erl" rel="noopener" target="_blank">Sequence 1</a>,
        <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/messaging/erlang/src/cloudi_service_test_messaging_sequence2.erl" rel="noopener" target="_blank">Sequence 2</a>,
        <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/messaging/erlang/src/cloudi_service_test_messaging_sequence3.erl" rel="noopener" target="_blank">Sequence 3</a>,
        <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/messaging/erlang/src/cloudi_service_test_messaging_sequence4.erl" rel="noopener" target="_blank">Sequence 4</a>)
        </li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/hexpi/erlang/src/cloudi_service_test_hexpi.erl" rel="noopener" target="_blank">Hexadecimal PI Fault-Tolerant Map/Reduce Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_queue/src/cloudi_service_queue.erl" rel="noopener" target="_blank">cloudi_service_queue Service for Durable Service Requests</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_quorum/src/cloudi_service_quorum.erl" rel="noopener" target="_blank">cloudi_service_quorum Service for Service Redundancy</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_filesystem/src/cloudi_service_filesystem.erl" rel="noopener" target="_blank">cloudi_service_filesystem Service for Caching Static File Data</a></li>
  </ul>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <h3 id="6_Go">6.4 - Go Service Implementation</h3>
  <p class="paragraph">
    The Go CloudI API provides a simple interface for making Go CloudI
    services.  The Go CloudI API only uses Go source code internally
    to avoid errors and simplify concurrency.  If thread-specific data is
    necessary, the Go CloudI API initialization can be passed a pointer
    type that is provided to each callback function execution.
    The integration tests that provide example usage of the Go
    <a href="api.html#Service">CloudI API</a> are:
  </p>
  <ul>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/count/gopath/src/count_go/main.go" rel="noopener" target="_blank">src/tests/count
        Basic Count Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/gopath/src/http_req_go/main.go" rel="noopener" target="_blank">src/tests/http_req
        Basic HTTP Request Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/msg_size/gopath/src/msg_size_go/main.go" rel="noopener" target="_blank">src/tests/msg_size
        Basic Message Size (Forwarding) Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/messaging/gopath/src/messaging_go/main.go" rel="noopener" target="_blank">src/tests/messaging
        Basic Messaging Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/null/gopath/src/null_go/main.go" rel="noopener" target="_blank">src/tests/null
        Basic Null Response Test</a></li>
  </ul>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <h3 id="6_Haskell">6.5 - Haskell Service Implementation</h3>
  <p class="paragraph">
    The Haskell CloudI API provides a simple interface for making Haskell CloudI
    services.  The Haskell CloudI API only uses Haskell source code internally
    to avoid errors and simplify concurrency.  If thread-specific data is
    necessary, the Haskell CloudI API would be instantiated using its
    parameterized type to store the state data (if it is unnecessary, it is
    simplest to use the unit type ("()") as the type parameter, as shown
    in the examples below).  Updating the thread-specific data requires using
    the callback function return type.  The integration tests that provide
    example usage of the Haskell
    <a href="api.html#Service">CloudI API</a> are:
  </p>
  <ul>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/count/haskell/Main.hs" rel="noopener" target="_blank">src/tests/count
        Basic Count Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/haskell/Main.hs" rel="noopener" target="_blank">src/tests/http_req
        Basic HTTP Request Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/msg_size/haskell/Main.hs" rel="noopener" target="_blank">src/tests/msg_size
        Basic Message Size (Forwarding) Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/messaging/haskell/Main.hs" rel="noopener" target="_blank">src/tests/messaging
        Basic Messaging Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/null/haskell/Main.hs" rel="noopener" target="_blank">src/tests/null
        Basic Null Response Test</a></li>
  </ul>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <h3 id="6_Java">6.6 - Java Service Implementation</h3>
  <p class="paragraph">
    The Java CloudI API uses synchronous IO on file descriptors for
    an efficient light-weight interface using only Java source code,
    to avoid errors and simplify concurrency.  No abstract interface classes
    are enforced to prefer HasA relationships instead of IsA as
    described by <a href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noreferrer" target="_blank">Erich Gamma et. al. in "Design Patterns: Elements of Reusable
    Object-Oriented Software" (page 20, "Favor object composition over class inheritance")</a>
    and to stay consistent with the
    other CloudI API implementations using function references for
    service name subscriptions.  If Java 8 or higher is used, it is
    possible to use method references for CloudI API subscriptions
    (example use is shown in the http_req integration test).
    Some of the integration tests that provide example usage of the Java
    <a href="api.html#Service">CloudI API</a> are:
  </p>
  <ul>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/count/java/org/cloudi/tests/count/Task.java" rel="noopener" target="_blank">src/tests/count
        Basic Count Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/java/org/cloudi/tests/http_req/Task.java" rel="noopener" target="_blank">src/tests/http_req
        Basic HTTP Request Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/msg_size/java/org/cloudi/tests/msg_size/Task.java" rel="noopener" target="_blank">src/tests/msg_size
        Basic Message Size (Forwarding) Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/messaging/java/org/cloudi/tests/messaging/Task.java" rel="noopener" target="_blank">src/tests/messaging
        Basic Messaging Test</a></li>
  </ul>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <h3 id="6_JavaScript">6.7 - JavaScript/node.js Service Implementation</h3>
  <p class="paragraph">
    The JavaScript CloudI API provides a simple interface for making JavaScript
    CloudI services. The JavaScript CloudI API only uses JavaScript source code
    internally with
    <a href="https://nodejs.org/" rel="noreferrer" target="_blank">node.js</a>
    as its only dependency, to avoid errors and simplify concurrency.
    The integration tests that provide example usage of the JavaScript
    <a href="api.html#Service">CloudI API</a> are:
  </p>
  <ul>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/count/count.js" rel="noopener" target="_blank">src/tests/count
        Basic Count Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/http_req.js" rel="noopener" target="_blank">src/tests/http_req
        Basic HTTP Request Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/msg_size/msg_size.js" rel="noopener" target="_blank">src/tests/msg_size
        Basic Message Size (Forwarding) Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/messaging/messaging.js" rel="noopener" target="_blank">src/tests/messaging
        Basic Messaging Test</a></li>
  </ul>
  <p>
    If node.js provided user-level threading like
    <a href="https://github.com/laverdet/node-fibers" rel="noreferrer" target="_blank">https://github.com/laverdet/node-fibers</a>, it would be supported if it
    handles multiple node.js domains (currently node.js only uses a single
    global domain (i.e., the top of the global domain stack)).
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <h3 id="6_OCaml">6.8 - OCaml Service Implementation</h3>
  <p class="paragraph">
    The OCaml CloudI API provides a simple interface for making OCaml CloudI
    services.  The OCaml CloudI API only uses OCaml source code internally
    to avoid errors and simplify concurrency.  If thread-specific data is
    necessary, the OCaml CloudI API would be instantiated using its
    parameterized type to store the state data (if it is unnecessary, it is
    simplest to use the unit type as the type parameter).
    The integration tests that provide example usage of the OCaml
    <a href="api.html#Service">CloudI API</a> are:
  </p>
  <ul>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/count/ocaml/main.ml" rel="noopener" target="_blank">src/tests/count
        Basic Count Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/ocaml/main.ml" rel="noopener" target="_blank">src/tests/http_req
        Basic HTTP Request Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/msg_size/ocaml/main.ml" rel="noopener" target="_blank">src/tests/msg_size
        Basic Message Size (Forwarding) Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/messaging/ocaml/main.ml" rel="noopener" target="_blank">src/tests/messaging
        Basic Messaging Test</a></li>
  </ul>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <h3 id="6_Perl">6.9 - Perl Service Implementation</h3>
  <p class="paragraph">
    The Perl CloudI API provides a simple interface for making Perl
    CloudI services. The Perl CloudI API only uses Perl source code
    internally to avoid errors and simplify concurrency. If thread-specific
    data is necessary a Perl module can be used as the CloudI service
    (the count integration test provides an example).
    The integration tests that provide example usage of the Perl
    <a href="api.html#Service">CloudI API</a> are:
  </p>
  <ul>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/count/CountTask.pm" rel="noopener" target="_blank">src/tests/count
        Basic Count Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/http_req.pl" rel="noopener" target="_blank">src/tests/http_req
        Basic HTTP Request Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/msg_size/msg_size.pl" rel="noopener" target="_blank">src/tests/msg_size
        Basic Message Size (Forwarding) Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/messaging/MessagingTask.pm" rel="noopener" target="_blank">src/tests/messaging
        Basic Messaging Test</a></li>
  </ul>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <h3 id="6_PHP">6.10 - PHP Service Implementation</h3>
  <p class="paragraph">
    The PHP CloudI API provides a simple interface for making PHP
    CloudI services. The PHP CloudI API only uses PHP source code
    internally to avoid errors and simplify concurrency.
    The integration tests that provide example usage of the PHP
    <a href="api.html#Service">CloudI API</a> are:
  </p>
  <ul>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/count/count.php" rel="noopener" target="_blank">src/tests/count
        Basic Count Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/http_req.php" rel="noopener" target="_blank">src/tests/http_req
        Basic HTTP Request Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/msg_size/msg_size.php" rel="noopener" target="_blank">src/tests/msg_size
        Basic Message Size (Forwarding) Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/messaging/messaging.php" rel="noopener" target="_blank">src/tests/messaging
        Basic Messaging Test</a></li>
  </ul>
  <p>
    PHP <a href="https://www.php.net/manual/en/intro.parallel.php" rel="noreferrer" target="_blank">parallel</a>
    may be used for separate threads (with PHP &ge; 7.2).
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <h3 id="6_Python">6.11 - Python Service Implementation</h3>
  <p class="paragraph">
    The Python CloudI API provides a simple interface for making Python
    CloudI services.  Some of the integration tests that provide example usage
    of the Python
    <a href="api.html#Service">CloudI API</a> are:
  </p>
  <ul>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/count/count.py" rel="noopener" target="_blank">src/tests/count
        Basic Count Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/http_req.py" rel="noopener" target="_blank">src/tests/http_req
        Basic HTTP Request Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/msg_size/msg_size.py" rel="noopener" target="_blank">src/tests/msg_size
        Basic Message Size (Forwarding) Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/messaging/messaging.py" rel="noopener" target="_blank">src/tests/messaging
        Basic Messaging Test</a></li>
  </ul>
  <p class="paragraph">
    An example configuration (from the <a href="https://github.com/CloudI/CloudI/blob/master/src/cloudi_tests.conf.in" rel="noopener" target="_blank">integration tests CloudI configuration</a>)
    is provided below:
  </p>
<pre>
{external,
    "/tests/http/",
    "@PYTHON@",
    "tests/http/service/service.py",
    [],
    none, default, default,
    5000, 5000, 5000, [api], undefined, 1, 4, 5, 300, []}
</pre>
  <p>
    There are two implementations of the Python CloudI API: a pure-Python
    CloudI API (module "cloudi") and a Python/C CloudI API (module "cloudi_c").
    Just specify the Python library by the module imported, since the same
    interface is provided within both choices.  The "cloudi_c" module has
    been shown to provide a <a href="https://github.com/CloudI/loadtests/raw/master/tests/http_req/loadtest/results_v1_1_0/201210_summary.pdf" rel="noopener" target="_blank">speedup greater than 400%</a>
    when compared with the "cloudi" module, with both under a load of 10,000
    requests/second.  For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <h3 id="6_Ruby">6.12 - Ruby Service Implementation</h3>
  <p class="paragraph">
    The Ruby CloudI API provides a simple interface for making Ruby
    CloudI services. The Ruby CloudI API only uses Ruby source code
    internally to avoid errors and simplify concurrency.
    Some of the integration tests that provide example
    usage of the Ruby <a href="api.html#Service">CloudI API</a> are:
  </p>
  <ul>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/count/count.rb" rel="noopener" target="_blank">src/tests/count
        Basic Count Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/http_req.rb" rel="noopener" target="_blank">src/tests/http_req
        Basic HTTP Request Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/msg_size/msg_size.rb" rel="noopener" target="_blank">src/tests/msg_size
        Basic Message Size (Forwarding) Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/messaging/messaging.rb" rel="noopener" target="_blank">src/tests/messaging
        Basic Messaging Test</a></li>
  </ul>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <h3 id="6_Rust">6.13 - Rust Service Implementation</h3>
  <p class="paragraph">
    The Rust CloudI API provides a simple interface for making Rust
    CloudI services. The Rust CloudI API only uses Rust source code
    internally to avoid errors and simplify concurrency.
    Some of the integration tests that provide example
    usage of the Rust <a href="api.html#Service">CloudI API</a> are:
  </p>
  <ul>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/count/rust/main.rs" rel="noopener" target="_blank">src/tests/count
        Basic Count Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/rust/main.rs" rel="noopener" target="_blank">src/tests/http_req
        Basic HTTP Request Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/msg_size/rust/main.rs" rel="noopener" target="_blank">src/tests/msg_size
        Basic Message Size (Forwarding) Test</a></li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/messaging/rust/main.rs" rel="noopener" target="_blank">src/tests/messaging
        Basic Messaging Test</a></li>
  </ul>
  <p>
    For more information, please refer to <a href="#4_API">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <h3 id="6_HTTP">6.14 - HTTP Integration</h3>
  <p class="paragraph">
    HTTP integration with CloudI services uses service names that have a prefix
    that matches the Uniform Resource Locator (URL) path.  A simple example
    caches static filesystem files recursively so that the file path is
    the service name suffix (with the "/get" HTTP method suffix at the end,
    e.g., "index.html/get").  The example can be found in the <a href="https://github.com/CloudI/CloudI/blob/master/src/cloudi_tests.conf.in" rel="noopener" target="_blank">integration tests CloudI configuration</a>
    usage of the <a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_filesystem/src/cloudi_service_filesystem.erl" rel="noopener" target="_blank">cloudi_service_filesystem</a> which is shown below:
  </p>
<pre>
{internal,
    "/tests/http_req/",
    cloudi_service_filesystem,
    [{directory, "tests/http_req/public_html/"}],
    none,
    5000, 5000, 5000, [api], undefined, 1, 5, 300, []}
</pre>
  <p class="paragraph">
    When CloudI is running with this service configuration, the files
    in the path tests/http_req/public_html/ are browsable at <a href="http://127.0.0.1:6464/tests/http_req/" target="_blank">http://127.0.0.1:6464/tests/http_req/</a>.
  </p>
  <p class="paragraph">
    The incoming HTTP traffic goes through the <a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_http_cowboy/src/cloudi_service_http_cowboy.erl" rel="noopener" target="_blank">cloudi_service_http_cowboy</a>
    Erlang CloudI service (or <a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_http_elli/src/cloudi_service_http_elli.erl" rel="noopener" target="_blank">cloudi_service_http_elli</a>)
    and simply uses the URL path
    to send a request to the subscribing CloudI service, where the prefix of
    the service name was set in the service configuration but the suffix of
    the service name was declared programmatically by calling the CloudI API
    <a href="api.html#1_subscribe">subscribe</a> function.
    cloudi_service_http_cowboy adds the "/get" suffix
    (when configured with "{use_method_suffix, true}", the default)
    on the URL to make the service name for the CloudI service request
    which contains the HTTP request headers in the RequestInfo value of the
    service request (RequestInfo is normally used for key-value service
    request meta-data).
  </p>
  <p class="paragraph">
    Quicker access to static files can be provided by nginx or other simple HTTP
    servers, so this is just an internal service example of CloudI HTTP
    integration (CloudI is normally for dynamic requests that require
    both scalability and fault tolerance).
  </p>
  <p class="paragraph">
    Other simple HTTP integration examples can be found among the integration
    tests:
  </p>
  <ul>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/" rel="noopener" target="_blank">src/tests/http_req Basic HTTP Request Test</a>
        (with <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/c_src/main.c" rel="noopener" target="_blank">C</a>/<a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/erlang/src/cloudi_service_test_http_req.erl" rel="noopener" target="_blank">Erlang</a>/<a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/java/org/cloudi/tests/http_req/Task.java" rel="noopener" target="_blank">Java</a>/<a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/http_req.js" rel="noopener" target="_blank">JavaScript-node.js</a>/<a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/http_req.pl" rel="noopener" target="_blank">Perl</a>/<a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/http_req.php" rel="noopener" target="_blank">PHP</a>/<a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/http_req.py" rel="noopener" target="_blank">Python</a>/<a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http_req/http_req.rb" rel="noopener" target="_blank">Ruby</a> services)</li>
    <li><a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http/" rel="noopener" target="_blank">src/tests/http HTTP Test</a>
        (with <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http/run.sh" rel="noopener" target="_blank">curl file-based test requests</a> using
         <a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_quorum/src/cloudi_service_quorum.erl" rel="noopener" target="_blank">cloudi_service_quorum</a>
         and <a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http/http.py" rel="noopener" target="_blank">Python</a>/<a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http/http.rb" rel="noopener" target="_blank">Ruby</a>/<a href="https://github.com/CloudI/CloudI/blob/master/src/tests/http/java/org/cloudi/tests/http/Task.java" rel="noopener" target="_blank">Java</a> services)</li>
    <li><a href="#4_WebSockets" target="_blank">WebSocket Integration</a></li>
  </ul>
  <p class="paragraph">
    To prevent HTTP requests from going to internal services, Access Control
    List (ACL) entries can be added that prevent the cloudi_service_http_cowboy
    Erlang
    CloudI service from sending to the internal services.  The ACL entries
    would be service name patterns that include the internal services in a
    list that is referenced directly (i.e., literally as a list of string) or
    indirectly by an atom that represents the list of strings.  The ACL
    entries would be specified for the cloudi_service_http_cowboy service
    configuration's deny list.  If service names are named consistently so that
    the service name represents a path which is a destination in a tree or
    hierarchy, then there should be no problems when adding or removing
    services dynamically (since the ACL entries will remain valid for the
    consistent service name pattern usage).  URLs can be matched dynamically
    using <a href="#4_URLregex">service name patterns</a>.
  </p>
  <p class="paragraph">
    The cloudi_service_http_cowboy configuration allows you to specify various
    output formats for the incoming HTTP requests with the "output"
    configuration value.  The possible values are:
  </p>
  <table><tr><td>
    external<br />
    (default)
  </td><td>
    All service request data is Erlang binaries
    (can be sent to either internal or external services) but service
    response data can have ResponseInfo as an Erlang list of two element
    tuples (list({binary(),&nbsp;binary()), convenient within internal services)
  </td></tr><tr><td>
    internal
  </td><td>
    RequestInfo is sent in service requests as an Erlang list of two
    element tuples (list({binary(),&nbsp;binary()), can only be sent to
    internal services)
  </td></tr><tr><td>
    binary
  </td><td>
    All service request and response data are Erlang binaries
    (can be sent to either internal or external services)
  </td></tr><tr><td>
    lists
  </td><td>
    All service request and response data are Erlang lists
    (can only be sent to internal services)
  </td></tr></table>
  <p>
    For more information, please refer to <a href="#4_API_HTTP">"4.1 - How do I integrate external software with CloudI?"</a>.
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <h3 id="6_FaultTolerance">6.15 - Service Fault Tolerance</h3>
  <p class="paragraph">
    General fault tolerance considerations within the CloudI framework are
    described in <a href="#5_Stability">"5.3 - Stability and Fault Tolerance Considerations"</a>.
    State migration is not necessary for fault tolerance within the
    CloudI framework, as explained in <a href="#4_ServiceFail">"4.8 - How do I Migrate a Service from a Failed or Failing Node?"</a>.
    Instead, multiple service instances are used to ensure redundancy
    provides system fault tolerance.
  </p>
  <p class="paragraph">
    An example of <a href="https://en.wikipedia.org/wiki/Byzantine_fault_tolerance" rel="noreferrer" target="_blank">Byzantine fault tolerance</a>
    which can be used with any CloudI service requests is provided as <a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_quorum/src/cloudi_service_quorum.erl" rel="noopener" target="_blank">cloudi_service_quorum</a>.
    The cloudi_service_quorum uses its configured service name prefix it
    was started with to match any incoming service requests
    (i.e., any service names that match the prefix) which it proxies with
    mcast_async_active to all available service name destinations, using
    the suffix that was matched.  So, if cloudi_service_quorum was started
    with the prefix "/byzantine", like the example found in the <a href="https://github.com/CloudI/CloudI/blob/master/src/cloudi_tests.conf.in" rel="noopener" target="_blank">integration tests CloudI configuration</a>:
  </p>
<pre>
    {internal,
        "/byzantine",
        cloudi_service_quorum,
        [{quorum, byzantine}],
        immediate_closest,
        5000, 5000, 5000, undefined, undefined, 1, 5, 300, []}
</pre>
  <p class="paragraph">
    then all service requests that match the "/byzantine*" service name pattern
    will be sent with mcast_async_active to the suffix matched by "*".
    When the quorum configuration is set to 'byzantine', it ensure that
    less than 1/3rd of the responses are erroneous (or timeouts) before
    responding to the original cloudi_service_quorum service request.
    However, the 'byzantine' setting (the default) requires that at least
    4 destination service processes exist, otherwise the original
    cloudi_service_quorum service request will timeout.  The quorum can also
    be configured as a percentage of the total available destination service
    processes or as an absolute integer count of required destination service
    processes.
  </p>
  <p class="paragraph">
    If CloudI service requests need to be durable (stored on the filesystem
    during the lifetime of the transaction, i.e., the timeout duration),
    the service requests can be sent through
    <a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_queue/src/cloudi_service_queue.erl" rel="noopener" target="_blank">cloudi_service_queue</a>
    to handle either a destination failure or both a source failure and
    destination failure (based on the 'fault_isolation' configuration
    argument being either 'destination' or 'both').  A durable service request
    may contain data that causes a service failure so it is possible that
    using cloudi_service_queue may cause the same failure to occur
    multiple times.  To always pursue fail-fast operation with CloudI services
    it is best to not make service requests durable and instead only rely on
    the service request response to determine a transaction is successful.
  </p>
  <p class="paragraph">
    For system fault tolerance testing, the system configuration
    options <a href="api.html#2_services_add_config_opts_monkey_latency">monkey_latency</a>
    and <a href="api.html#2_services_add_config_opts_monkey_chaos">monkey_chaos</a>
    can be used to simulate failures.  The simulated failures can then be used
    with higher-level processing to ensure the system remains robust
    during the internal failures (i.e., to prove system fault tolerance
    during higher-level system testing).
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <h3 id="6_Monitoring">6.16 - Service Monitoring</h3>
  <p class="paragraph">
    The <a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_monitoring/src/cloudi_service_monitoring.erl" rel="noopener" target="_blank">cloudi_service_monitoring</a>
    provides the ability to monitor the internals of any CloudI service
    with some small service configuration changes.
    When modifying an internal service, the following service configuration
    options are added:
  </p>
<pre class="code">
{aspects_init_after,
 [{{cloudi_service_monitoring, aspect_init_after_internal}}]},
{aspects_request_before,
 [{{cloudi_service_monitoring, aspect_request_before_internal}}]},
{aspects_request_after,
 [{{cloudi_service_monitoring, aspect_request_after_internal}}]},
{aspects_info_before,
 [{{cloudi_service_monitoring, aspect_info_before_internal}}]},
{aspects_info_after,
 [{{cloudi_service_monitoring, aspect_info_after_internal}}]},
{aspects_terminate_before,
 [{{cloudi_service_monitoring, aspect_terminate_before_internal}}]},
</pre>
  <p class="paragraph">
    When modifying an external service, the following service configuration
    options are added:
  </p>
<pre class="code">
{aspects_init_after,
 [{{cloudi_service_monitoring, aspect_init_after_external}}]},
{aspects_request_before,
 [{{cloudi_service_monitoring, aspect_request_before_external}}]},
{aspects_request_after,
 [{{cloudi_service_monitoring, aspect_request_after_external}}]},
{aspects_terminate_before,
 [{{cloudi_service_monitoring, aspect_terminate_before_external}}]},
</pre>
  <p class="paragraph">
    If services are being started within Erlang source code, the configuration
    modifications can occur with the function call
    cloudi_service_monitoring:add/1.  To monitor all CloudI log output the
    logging configuration can be modified with:
  </p>
<pre class="code">
{aspects_log_after,
 [{{cloudi_service_monitoring, aspect_log_after}}]},
</pre>
  <p class="paragraph">
    The cloudi_service_monitoring service arguments control where the monitoring
    metrics are sent, the interval, and whether the Erlang VM metrics should be
    included (see <a href="https://github.com/CloudI/CloudI/blob/master/src/lib/cloudi_service_monitoring/src/cloudi_service_monitoring.erl" rel="noopener" target="_blank">cloudi_service_monitoring</a> for more details).
  </p>
  <div class="top"><a href="#6_contents">Top</a></div>

  <hr>
  <h2>7 - Troubleshooting</h2>

  <h3 id="7_start">7.1 - Why does CloudI stop shortly after being started?</h3>
  <p class="paragraph">
    If any services listed in the CloudI configuration file fail to initialize
    CloudI will shutdown.  This behavior is required to ensure CloudI services
    are able to fail-fast when services are unable to initialize.  If this has
    happened while running the integration tests, please submit
    the problem (with the /usr/local/var/log/cloudi/cloudi.log file and the
    build's config.log file) as <a href="#2_ReportingBugs">a bug</a>.
  </p>
  <p class="paragraph">
    The best place to have validation in a service is during service
    <a href="api.html#1_initialization_timeout">initialization</a>
    so the service's starting state is confirmed to be correct.
    Performing verification during service initialization is important due to
    the lifetime of a service's execution being typically undefined.
    Critical CloudI services should have their configuration in the CloudI
    configuration file (instead of using the CloudI Service API to dynamically
    start the services with <a href="api.html#2_services_add">services_add</a>)
    to take advantage of fail-fast service initialization.
  </p>
  <div class="top"><a href="#7_contents">Top</a></div>

  <h3 id="7_slow">7.2 - Why is CloudI making my Linux machine slow?</h3>
  <p class="paragraph">
    The machine is likely overloaded by the number of services and their
    configured concurrency.  However, the Linux scheduler that is selected
    may make the overloaded machine slower by pausing CPU intensive
    execution.  For CloudI use it is best to select a scheduler for
    CPU intensive execution (high-throughput).  Either
    (multiqueue) "none" with Linux&nbsp;&ge;&nbsp;5.0 or
    (non-multiqueue) "noop" (or <a href="https://en.wikipedia.org/wiki/CFQ" rel="noreferrer" target="_blank">"cfq"</a>)
    with Linux&nbsp;&lt;&nbsp;5.0 .
  </p>
  <p class="paragraph">
    Having CloudI services overload a machine is uncommon when the
    service configuration is created based on the available resources.
    The CloudI integration tests do a variety of different processing
    that has often caused CloudI to overload small machines
    (see <a href="api.html#2_services_add">services_add</a>
     for service configuration details or
     <a href="faq.html#5_Performance">"5.1 - Performance Considerations"</a>
     for general information about scheduler limitations).
  </p>
  <div class="top"><a href="#7_contents">Top</a></div>

  <h3 id="7_install">7.3 - Why does my container or guest VM installation of CloudI have problems?</h3>
  <p class="paragraph">
    CloudI Erlang source code executes within the Erlang/OTP VM
    (BEAM, i.e., "Bogdan/Björn's Erlang Abstract Machine") and requires
    accurate time-keeping during its execution.  Typically time information
    is obtained using clock_gettime with CLOCK_MONOTONIC and CLOCK_REALTIME
    (e.g., on Linux).  The time source can be checked in the Erlang shell with
    "erlang:system_info(os_monotonic_time_source)." and
    "erlang:system_info(os_system_time_source).".
  </p>
  <h4>Container Execution</h4>
  <p>
    Container execution of CloudI can occur on an overloaded machine to
    cause timeouts to occur prematurely after not giving CloudI CPU time.
    Docker containers should be using --cpus.  LXC containers should be using
    limits.cpu config.  If the container system does not support CPU quotas,
    timeouts will be inaccurate.
  </p>
  <h4>Guest VM Execution</h4>
  <p>
    Guest VM execution can have relatively accurate time-keeping on Linux when
    the clocksource is set to kvm&#8209;clock
    (Linux kernel argument "clocksource=kvm&#8209;clock").
    The Linux scheduler should be set to either
    (multiqueue) "none" with Linux&nbsp;&ge;&nbsp;5.0 or
    (non-multiqueue) "noop" with Linux&nbsp;&lt;&nbsp;5.0 .
    Various CloudI testing occurs in guest VM execution without problems,
    though execution is slower than bare-metal execution.
  </p>
  <div class="top"><a href="#7_contents">Top</a></div>

  <h3 id="7_cpu">7.4 - How can I control the CPU utilization of CloudI?</h3>
  <p class="paragraph">
    The Erlang VM is able to detect the CPU topology on most
    Operating Systems (OS) and the CPU topology is used for binding scheduler
    threads to logical processors.  The number of scheduler threads may be
    set with the erl <a href="https://www.erlang.org/doc/man/erl.html#+S" rel="noreferrer" target="_blank">+S</a>
    command-line argument.  Additional <a href="https://www.erlang.org/doc/man/erl.html#emulator-flags" rel="noreferrer" target="_blank">erl</a>
    command-line arguments for CloudI execution (like +S) can be added to the
    etc directory vm.args file (or the NODE.args node-specific file where
    NODE is the node name configured for the CloudI build).
  </p>
  <p class="paragraph">
    To control the specific CPUs that are used by the Erlang VM
    (in a cross-platform way, i.e., any OS) it may be necessary to provide the
    CPU topology explicitly with the erl <a href="https://www.erlang.org/doc/man/erl.html#+sct" rel="noreferrer" target="_blank">+sct</a>
    command-line argument.  An example is provided below using a
    <a href="https://en.wikipedia.org/wiki/List_of_PowerEdge_servers#Generation_11" rel="noreferrer" target="_blank">Dell PowerEdge R710</a>
    with 2 <a href="https://en.wikipedia.org/wiki/List_of_Intel_Xeon_processors_(Nehalem-based)#ark47922" rel="noreferrer" target="_blank">Xeon X5650</a>
    CPUs, each with 6 cores and 2 hyper-threads per core.
    The example below provides configuration for using only the
    second physical CPU for execution.
  </p>
  <p class="paragraph">
    If the Erlang VM is able to automatically detect the CPU topology on the OS,
    it will do so when binding the scheduler threads to the available
    logical processors (by default the scheduler threads are unbound).
    The default scheduler bind type is used below with the erl <a href="https://www.erlang.org/doc/man/erl.html#+sbt" rel="noreferrer" target="_blank">+sbt</a>
    command-line argument:
  </p>
<pre>
$ erl +sbt db
1> erlang:system_info(cpu_topology).
[{node,[{processor,[{core,[{thread,{logical,1}},
                           {thread,{logical,13}}]},
                    {core,[{thread,{logical,3}},{thread,{logical,15}}]},
                    {core,[{thread,{logical,5}},{thread,{logical,17}}]},
                    {core,[{thread,{logical,7}},{thread,{logical,19}}]},
                    {core,[{thread,{logical,9}},{thread,{logical,21}}]},
                    {core,[{thread,{logical,11}},{thread,{logical,23}}]}]}]},
 {node,[{processor,[{core,[{thread,{logical,0}},
                           {thread,{logical,12}}]},
                    {core,[{thread,{logical,2}},{thread,{logical,14}}]},
                    {core,[{thread,{logical,4}},{thread,{logical,16}}]},
                    {core,[{thread,{logical,6}},{thread,{logical,18}}]},
                    {core,[{thread,{logical,8}},{thread,{logical,20}}]},
                    {core,[{thread,{logical,10}},{thread,{logical,22}}]}]}]}]
2> erlang:system_info(scheduler_bindings).
{1,3,5,7,9,11,0,2,4,6,8,10,13,15,17,19,21,23,12,14,16,18,20,22}
</pre>
  <p class="paragraph">
    On Linux we can verify the logical processors that belong to each
    physical CPU with:
  </p>
<pre>
$ cat /sys/devices/system/node/node0/cpulist
0,2,4,6,8,10,12,14,16,18,20,22
$ cat /sys/devices/system/node/node1/cpulist
1,3,5,7,9,11,13,15,17,19,21,23
</pre>
  <p class="paragraph">
    To use only the second physical CPU, the CPU topology can be
    manually specified with the erl <a href="https://www.erlang.org/doc/man/erl.html#+sct" rel="noreferrer" target="_blank">+sct</a>
    command-line argument as:
  </p>
<pre>
L1,13t0-1c0p0N1:L3,15t2-3c1p0N1:L5,17t4-5c2p0N1:L7,19t6-7c3p0N1:L9,21t8-9c4p0N1:L11,23t10-11c5p0N1:L0,12t0-1c0p1N0:L2,14t2-3c1p1N0:L4,16t4-5c2p1N0:L6,18t6-7c3p1N0:L8,20t8-9c4p1N0:L10,22t10-11c5p1N0
</pre>
  <p class="paragraph">
    The +sct value above has the "p" processor (physical CPU) integers using a
    reverse ordering when compared to the "N" NUMA Node integers.
    To bind scheduler threads in the same order as the provided
    CPU topology the erl <a href="https://www.erlang.org/doc/man/erl.html#+sbt" rel="noreferrer" target="_blank">+sbt</a>
    command-line argument can be provided the "ns" value (for no_spread).
    Combining the <a href="https://www.erlang.org/doc/man/erl.html#emulator-flags" rel="noreferrer" target="_blank">erl</a> command-line arguments together
    for using only the second physical CPU would look like:
  </p>
<pre>
+sct L1,13t0-1c0p0N1:L3,15t2-3c1p0N1:L5,17t4-5c2p0N1:L7,19t6-7c3p0N1:L9,21t8-9c4p0N1:L11,23t10-11c5p0N1:L0,12t0-1c0p1N0:L2,14t2-3c1p1N0:L4,16t4-5c2p1N0:L6,18t6-7c3p1N0:L8,20t8-9c4p1N0:L10,22t10-11c5p1N0
+sbt ns
+S 12
</pre>
  <p class="paragraph">
    The +S command-line argument ensures only 12 scheduler threads are used
    and the single physical CPU in the example has 6 cores with 2 hyper-threads
    per core, so the CPU topology ordering allows the scheduler threads to be
    bound to only the second physical CPU.
  </p>
  <h4>External Services</h4>
  <p class="paragraph">
    External CloudI services require separate configuration to control their
    CPU use.  On Linux it is best to use the <a href="api.html#2_services_add_config_opts_cgroup">cgroup</a>
    service configuration option (instead of the taskset executable).
    The cgroup configuration example below would ensure an external service
    only uses the second physical CPU described above:
  </p>
<pre class="code">
{cgroup,
 [{name, "CloudI/external_service_example1"},
  {parameters,
   [{"cpuset.cpus", "1,13,3,15,5,17,7,19,9,21,11,23"}]}]}
</pre>
  <p class="paragraph">
    With the develop branch CloudI source code it is possible to use the
    <a href="api.html#2_services_add_config_opts_bind">bind</a> service
    configuration option with the same string value
    (i.e.,&nbsp;"1,13,3,15,5,17,7,19,9,21,11,23").  In the future,
    <a href="api.html#2_services_add_config_opts_bind">bind</a> should be
    preferred due to cross-platform support with less CloudI execution
    user privileges required.
  </p>
  <p class="paragraph">
    External CloudI services have additional service configuration options
    which influence CPU utilization in a more general way:
    <ul>
      <li><a href="api.html#2_services_add_config_opts">nice</a> - modify process scheduling priority</li>
      <li><a href="api.html#2_services_add_config_opts_limit">limit</a> - explicit limits</li>
      <li><a href="api.html#2_services_add_config_opts_owner">owner</a> - user/group limits</li>
    </ul>
  </p>
  <div class="top"><a href="#7_contents">Top</a></div>
</div>

<script>clipboard_copy_init();</script>

</body>
</html>
