<!DOCTYPE html>
<html lang="en">
<head>
  <title>CloudI: A Cloud at the lowest level - API Documentation</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta content="Cloud Framework for fault-tolerant distributed processing with dynamic load balancing" name="description" />
  <meta content="api, cloud, private cloud, framework, erlang, fault tolerant, distributed systems, embarrassingly parallel, divide and conquer, cloudi" name="keywords" />
  <meta content="global" name="distribution" />
  <script src="style.js"></script>
  <link rel="stylesheet" type="text/css" href="style.css" />
  <link rel="shortcut icon" href="images/cloud.ico" type="image/x-icon" />
  <!-- Open Graph Protocol (OGP) with LinkedIn requirements -->
  <meta property="og:title" content="CloudI: A Cloud at the lowest level - API Documentation" />
  <meta property="og:description" content="CloudI is an open-source private cloud computing framework for efficient, secure, and internal data processing. CloudI provides scaling for previously unscalable source code with efficient fault-tolerant execution of ATS, C/C++, Erlang/Elixir, Go, Haskell, Java, JavaScript/node.js, OCaml, Perl, PHP, Python, Ruby, or Rust services.

The bare essentials for efficient fault-tolerant processing on a cloud!" />
  <meta property="og:image" content="https://cloudi.org/images/cloud_ogp.png" />
  <meta property="og:url" content="https://cloudi.org/api.html" />
  <meta property="og:type" content="website" />
</head>
<body>

<div id="header">
<a href="https://cloudi.org/">
Cloud<span style="font-family:serif">I</span><img alt="Active Cloud" width="156" height="106" src="images/cloud.png" />
</a>
</div>
<br />
<div id="navigation">
  <ul>
    <li><a href="index.html">QUICKSTART</a></li>
    <li><a href="api.html" class="active">API</a></li>
    <li><a href="faq.html">FAQ</a></li>
    <li><a href="tutorials.html">Tutorials</a>
        (<a href="tutorial_java.html">Java</a>)</li>
    <li><a href="https://cloudi.org/download" rel="noopener" target="_blank">Download</a></li>
    <li><a href="https://github.com/CloudI/CloudI/tree/develop#readme">Source</a></li>
    <li><a href="support.html">Support</a></li>
  </ul>
</div>

<div id="content">
  <h1>CloudI API Documentation</h1>
  <h3 style="text-align:center">version 2.0.7<br />
  last updated on October 26<sup>th</sup> 2023</h3>

  <h2 id="Service">CloudI API - Making a Service</h2>
  <ul class="api">
    <li><a href="#1_Intro"             >1.0 - Introduction</a></li>
    <li><a href="#1_initialization"    >1.1 - (initialization)</a></li>
    <li><a href="#1_termination"       >1.2 - (termination)</a></li>
    <li><a href="#1_subscribe"         >1.3 - subscribe</a></li>
    <li><a href="#1_subscribe_count"   >1.4 - subscribe_count</a></li>
    <li><a href="#1_unsubscribe"       >1.5 - unsubscribe</a></li>
    <li><a href="#1_get_pid"           >1.6 - get_pid
                                        (internal services only)</a></li>
    <li><a href="#1_get_pids"          >1.7 - get_pids
                                        (internal services only)</a></li>
    <li><a href="#1_send_sync"         >1.8 - send_sync</a></li>
    <li><a href="#1_send_async"        >1.9 - send_async</a></li>
    <li><a href="#1_send_async_active" >1.10 - send_async_active
                                        (internal services only)</a></li>
    <li><a href="#1_mcast_async"       >1.11 - mcast_async</a></li>
    <li><a href="#1_mcast_async_active">1.12 - mcast_async_active
                                        (internal services only)</a></li>
    <li><a href="#1_recv_async"        >1.13 - recv_async</a></li>
    <li><a href="#1_recv_asyncs"       >1.14 - recv_asyncs
                                        (internal services only)</a></li>
    <li><a href="#1_return"            >1.15 - return</a></li>
    <li><a href="#1_forward"           >1.16 - forward</a></li>
    <li><a href="#1_poll"              >1.17 - poll
                                        (external services only)</a></li>
    <li><a href="#1_shutdown"          >1.18 - shutdown</a></li>
  </ul>
  <h2 id="CloudI">CloudI Service API - Controlling CloudI</h2>
  <ul class="api">
    <li><a href="#2_Intro"                 >2.0 - Introduction</a></li>
    <li><a href="#2_acl_add"               >2.1 - acl_add</a></li>
    <li><a href="#2_acl_remove"            >2.2 - acl_remove</a></li>
    <li><a href="#2_acl"                   >2.3 - acl</a></li>
    <li><a href="#2_service_subscriptions" >2.4 - service_subscriptions</a></li>
    <li><a href="#2_services_add"          >2.5 - services_add</a></li>
    <li><a href="#2_services_remove"       >2.6 - services_remove</a></li>
    <li><a href="#2_services_restart"      >2.7 - services_restart</a></li>
    <li><a href="#2_services_suspend"      >2.8 - services_suspend</a></li>
    <li><a href="#2_services_resume"       >2.9 - services_resume</a></li>
    <li><a href="#2_services_search"       >2.10 - services_search</a></li>
    <li><a href="#2_services_status"       >2.11 - services_status</a></li>
    <li><a href="#2_services_update"       >2.12 - services_update</a></li>
    <li><a href="#2_services"              >2.13 - services</a></li>
    <li><a href="#2_nodes_set"             >2.14 - nodes_set</a></li>
    <li><a href="#2_nodes_get"             >2.15 - nodes_get</a></li>
    <li><a href="#2_nodes_add"             >2.16 - nodes_add</a></li>
    <li><a href="#2_nodes_remove"          >2.17 - nodes_remove</a></li>
    <li><a href="#2_nodes_alive"           >2.18 - nodes_alive</a></li>
    <li><a href="#2_nodes_dead"            >2.19 - nodes_dead</a></li>
    <li><a href="#2_nodes_status"          >2.20 - nodes_status</a></li>
    <li><a href="#2_nodes"                 >2.21 - nodes</a></li>
    <li><a href="#2_logging_set"           >2.22 - logging_set</a></li>
    <li><a href="#2_logging_file_set"      >2.23 - logging_file_set</a></li>
    <li><a href="#2_logging_level_set"     >2.24 - logging_level_set</a></li>
    <li><a href="#2_logging_stdout_set"    >2.25 - logging_stdout_set</a></li>
    <li><a href="#2_logging_syslog_set"    >2.26 - logging_syslog_set</a></li>
    <li><a href="#2_logging_formatters_set">2.27 - logging_formatters_set</a></li>
    <li><a href="#2_logging_redirect_set"  >2.28 - logging_redirect_set</a></li>
    <li><a href="#2_logging_status"        >2.29 - logging_status</a></li>
    <li><a href="#2_logging_status_reset"  >2.30 - logging_status_reset</a></li>
    <li><a href="#2_logging"               >2.31 - logging</a></li>
    <li><a href="#2_code_path_add"         >2.32 - code_path_add</a></li>
    <li><a href="#2_code_path_remove"      >2.33 - code_path_remove</a></li>
    <li><a href="#2_code_path"             >2.34 - code_path</a></li>
    <li><a href="#2_code_status"           >2.35 - code_status</a></li>
  </ul>

  <hr>
  <h2>CloudI API - Making a Service</h2>

  <h3 id="1_Intro">1.0 - Introduction</h3>
  <p class="paragraph">
    The CloudI API provides a simple messaging API which allows CloudI services
    to send requests.  The CloudI API supports both publish/subscribe and
    request/reply communication in an intuitive way.  It is not necessary to
    understand the Erlang programming language (or Elixir), to use the
    CloudI API since a full CloudI API implementation is provided for every
    supported programming language (ATS, C/C++, Elixir, Erlang, Go, Haskell,
    Java, JavaScript, OCaml, Perl, PHP, Python, Ruby, and Rust, currently).
  </p>
  <p class="paragraph">
    The CloudI API messaging is different from other messaging APIs and
    provides simpler integration for a few reasons: 
  </p>
  <ul>
    <li>CloudI API usage requires CloudI usage as an application server to enforce fault-tolerance and scalability constraints on source code execution</li>
    <li>The CloudI service that receives a request determines whether a reply occurs (returning no response data is the same as not providing a reply)</li>
    <li>All required callbacks are minimal (only a single request callback is necessary for a CloudI service to handle requests) to keep CloudI services simpler, so they are less error-prone than other solutions</li>
    <li>Requests are not persisted to database storage to avoid persisting errors since errors are often transient and only relate to a specific context</li>
    <li>All CloudI API programming language integration makes CloudI services first-class processes within the Erlang VM to provide consistent functionality and fault tolerance</li>
    <li>Every CloudI API request contains a priority</li>
    <li>Every CloudI API request contains a unique v1 UUID for identifying the request and its response</li>
    <li>Every CloudI API request contains a timeout which is updated based on the queuing and processing delays the request encounters</li>
  </ul>
  <p class="paragraph">
    The <a href="#1_subscribe">subscribe</a> function subscribes to a
    service name pattern string which may contain "*" and "?" wildcard
    characters, to accept any matching service requests.  Either
    "*" or "?" in a service name pattern will match one or more characters
    with "?" never matching the character that follows it
    ("?" is unable to be the last character, i.e.,
     "/?/" matches "/a/" but never "/a/b/" while "/*/" will match either).
    The <a href="#1_send_sync">send_sync</a> function and the
    <a href="#1_send_async">send_async</a> function provide point-to-point
    communication based on the service name provided.  When multiple services
    <a href="#1_subscribe">subscribe</a> with the same service name pattern
    the destination is picked based on the sending service's "destination
    refresh method", which can be any of the following:
  </p>
  <table id="1_Intro_dest"><tr><th>
    Destination Refresh Method
  </th><th>
    Meaning
  </th></tr><tr><td>
    lazy_closest (or)<br /> immediate_closest
  </td><td>
    A service running on the local node will be selected,
    unless the destination only exists on a remote node
  </td></tr><tr><td>
    lazy_furthest (or)<br /> immediate_furthest
  </td><td>
    A service running on a remote node will be selected,
    unless the destination only exists on the local node
  </td></tr><tr><td>
    lazy_random (or)<br /> immediate_random
  </td><td>
    A service is selected randomly from the subscribed services
  </td></tr><tr><td>
    lazy_local (or)<br /> immediate_local
  </td><td>
    Only a service on the local node is selected
  </td></tr><tr><td>
    lazy_remote (or)<br /> immediate_remote
  </td><td>
    Only a service on a remote node is selected
  </td></tr><tr><td>
    lazy_newest (or)<br /> immediate_newest
  </td><td>
    Only the most recently subscribed service is selected
  </td></tr><tr><td>
    lazy_oldest (or)<br /> immediate_oldest
  </td><td>
    Only the first subscribed service is selected
  </td></tr><tr><td>
    none
  </td><td>
    The service should never send a request and it is an error when the
    service attempts to send (the service may still receive requests)
  </td></tr></table>
  <p class="paragraph">
    The "lazy" prefix and the "immediate" prefix on the destination refresh
    method determines whether stale data is used within the service's data
    or if a single lookup process is used to get the most current
    destination result, respectively ("lazy" is for when long-lived services
    are the destination but consumes more service memory, and "immediate" is
    for when short-lived services are the destination but creates contention
    for the lookup process).
  </p>
  <p class="paragraph">
    When separate service processes subscribe with the same service name
    pattern, each subscription is used based on random selection
    (if more than one service processes are available based on the
     destination refresh method), when a service request is sent to the
    service name.  If the same service subscribes with the same
    service name pattern more than once within a single external service
    thread, each subscription is used in round-robin order
    (first subscription is called first, so order is preserved),
    when the service thread receives a request for the specific
    service name pattern.
  </p>
  <p class="paragraph">
    The <a href="#1_mcast_async">mcast_async</a> function provides
    publish functionality by sending a request asynchronously to all
    services that have <a href="#1_subscribe">subscribe</a>d to the same
    service name pattern.  To receive an asynchronous request
    <a href="#1_recv_async">recv_async</a> is used with the "TransId"
    (i.e., Transaction Id, a v1 UUID) or a null UUID to receive the
    oldest service request.
  </p>
  <p class="paragraph">
    The <a href="#1_return">return</a> function is used to respond to a
    service request and terminate the current request handler
    (i.e., the service request is finished, at that point).
    A service can <a href="#1_return">return</a> a
    <a href="faq.html#4_Null">null response</a> if the sending
    service should not receive a response, which can be used for typical
    response-less publish functionality.
    The <a href="#1_forward">forward</a>
    function provides a new destination for the same service request,
    delaying the request's completion, but still terminating the current
    request handler.
  </p>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_initialization">1.1 - (initialization)</h3>
  <p class="paragraph">
    The service configuration will control the CloudI API initialization,
    which is done automatically, but does influence the source code.
    The service configuration defines the number of Operating System (OS)
    processes to create and
    the number of threads for an external service.  For an internal service,
    the configuration defines the number of Erlang processes to create.
    A number specified as an integer in the configuration is the exact
    number of processes or threads.
    However, if the number is specified as a floating point number, it is used
    as a CPU count (i.e., Erlang scheduler count) multipler where &gt;1.0
    implies floor and &lt;1.0 implies round.  The external service
    APIs provide the thread_count function so that the total number of threads
    can be used for thread creation, with each thread holding an instance of
    the CloudI API (to avoid lock contention):
  </p>

  <div class="tabs" style="min-height: 13em;">
  <div id="1_initialization_C">
  <a href="#1_initialization_C">C</a>
  <div class="tab_contents">
<pre class="code">
int cloudi_initialize_thread_count(unsigned int * const thread_count);
int cloudi_initialize(cloudi_instance_t * api,
                      unsigned int const thread_index,
                      void * state);
</pre>
  </div>
  </div> <!-- C -->
  <div id="1_initialization_CXX">
  <a href="#1_initialization_CXX">C++</a>
  <div class="tab_contents">
<pre class="code">
unsigned int CloudI::API::thread_count();
CloudI::API(unsigned int const thread_index,
            bool const terminate_return_value = true);
</pre>
  </div>
  </div> <!-- C++ -->
  <div id="1_initialization_Elixir">
  <a href="#1_initialization_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
  def cloudi_service_init(_args, _prefix, _timeout, dispatcher) do
    # ...
    {:ok, :undefined}
  end
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_initialization_Erlang">
  <a href="#1_initialization_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
cloudi_service_init(_Args, _Prefix, _Timeout, Dispatcher) -&gt;
    % ...
    {ok, #state{}}.
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_initialization_Go">
  <a href="#1_initialization_Go">Go</a>
  <div class="tab_contents">
<pre class="code">
cloudi.ThreadCount() (uint32, error)
cloudi.API(threadIndex uint32, state interface{}) (*Instance, error)
</pre>
  </div>
  </div> <!-- Go -->
  <div id="1_initialization_Java">
  <a href="#1_initialization_Java">Java</a>
  <div class="tab_contents">
<pre class="code">
int org.cloudi.API.thread_count();
org.cloudi.API(final int thread_index);
</pre>
  </div>
  </div> <!-- Java -->
  <div id="1_initialization_JavaScript">
  <a href="#1_initialization_JavaScript">JavaScript</a>
  <div class="tab_contents">
<pre class="code">
CloudI.API.thread_count();
CloudI.API(thread_index, callback);
</pre>
  </div>
  </div> <!-- JavaScript -->
  <div id="1_initialization_Perl">
  <a href="#1_initialization_Perl">Perl</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API-&gt;thread_count();
CloudI::API-&gt;new($thread_index);
</pre>
  </div>
  </div> <!-- Perl -->
  <div id="1_initialization_PHP">
  <a href="#1_initialization_PHP">PHP</a>
  <div class="tab_contents">
<pre class="code">
\CloudI\API::thread_count();
\CloudI\API($thread_index);
</pre>
  </div>
  </div> <!-- PHP -->
  <div id="1_initialization_Python">
  <a href="#1_initialization_Python">Python</a>
  <div class="tab_contents">
<pre class="code">
cloudi.API.thread_count()
cloudi.API(thread_index)
</pre>
  </div>
  </div> <!-- Python -->
  <div id="1_initialization_Ruby">
  <a href="#1_initialization_Ruby">Ruby</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API.thread_count()
CloudI::API.new(thread_index)
</pre>
  </div>
  </div> <!-- Ruby -->
  <div id="1_initialization_code">
  <a href="#1_initialization_code">&nbsp;</a>
  <div class="tab_contents">
    Initialize an instance of the CloudI API
  </div>
  </div> <!-- Description -->
  </div>

  <p id="1_initialization_timeout" class="paragraph">
    An internal service uses the configured initialization timeout to limit the
    execution time spent within the cloudi_service_init/4 cloudi_service
    behaviour callback function.  An external service uses the configured
    initialization timeout to limit the execution time spent between
    creating an instance of the CloudI API and calling the CloudI API
    <a href="#1_poll">poll</a> function (for the first time).
    During the service initialization the CloudI API functions that may not be
    called are:
    <a href="#1_send_sync">send_sync</a>,
    <a href="#1_recv_async">recv_async</a>,
    <a href="#1_return">return</a> and
    <a href="#1_forward">forward</a>
    (i.e., send_sync and recv_async block to receive a service request response
     but service initialization must be asynchronous and within the
     initialization timeout period, return and forward are only valid
     when completing the handling of a service request).
  </p>
  <p class="paragraph">
    If the initialization timeout is exceeded a service failure has
    occurred and a restart will occur (if possible) based on the configured
    MaxR (maximum restarts) and MaxT (maximum time period in seconds) service
    configuration values.  If the service was configured in the
    CloudI configuration file (i.e., <a href="https://github.com/CloudI/CloudI/blob/master/src/cloudi_minimal.conf.in" rel="noopener" target="_blank">/usr/local/etc/cloudi/cloudi.conf</a>,
    used when CloudI is first started) and one of
    the configured services fails initialization MaxR times, CloudI will
    shutdown to prevent erroneous operation.  To avoid the fail-fast
    handling of the CloudI configuration file, the CloudI Service API
    <a href="#2_services_add">services_add</a> function may be used
    to provide service configuration (the return value will provide
    information about service initialization failures exceeding MaxR).
  </p>
  <p class="paragraph">
    The service configuration also allows Access Control Lists (ACLs) to define
    explicit service name patterns for allowing or denying service
    destinations when the service sends a service request.  The ACLs along
    with the destination refresh method determine how service requests are
    sent while other <a href="#2_services_add_config_opts">service options</a>
    can tweak default settings.
  </p>
  <p class="paragraph">
    External (non-Erlang) services are provided both the command line and
    the environmental variables specified within the service configuration.
    External sevice configuration uses the full path to the executable while
    internal services use the module name (and the OTP application name)
    within the code search paths.  All environmental variables set in the
    shell executing the Erlang VM can be used within the executable path,
    arguments and environment set in the configuration of an external service,
    using standard shell syntax (e.g., "${USER}" or "$USER",
    where "\\$" is a literal "$" character).
  </p>
  <p>
  Please see <a href="#2_services_add">the CloudI Service API (services_add)</a>
  for more details about service configuration.
  <br /><br />
  Specific Language Integration Notes:
  </p>
  <p class="paragraph">
    The Elixir/Erlang CloudI API functions shown below accept the most function
    parameters in cloudi_service but functions with less parameters do
    exist and they utilize default values for timeouts and request
    priority.  Both the Timeout parameter and the Priority parameter
    accept the 'undefined' atom to assign the default configured value.
    Please see the
    <a href="api/cloudi_core-2.0.7/cloudi_service.html#index" target="_blank">cloudi_service module</a>
    to see all the available functions and the behavior interface functions
    that are implemented within an Erlang service.  The cloudi_service module
    is used within CloudI services, however, it is also possible to use CloudI
    services from external Erlang processes with a subset of the CloudI API
    functions in the
    <a href="api/cloudi_core-2.0.7/cloudi.html#index" target="_blank">cloudi module</a>.
  </p>
  <p class="paragraph">
    Both the C and the C++ CloudI API rely on the same underlying code, with
    the C++ API object as a wrapper around the C API pointer, so there should
    be no large performance difference.  STL is avoided, to avoid the
    libstdc++ memory pool and internal memory pools are used.  The C++
    CloudI API functions below use the STRING type to represent either
    char const * const (or) std::string const &amp;, since both are
    supported with overloaded functions.
  </p>
  <p class="paragraph">
    The Java CloudI API doesn't have any C or C++ integration.  It only uses
    reflection to utilize the low-level file descriptor object and
    store object function pointers.
  </p>
  <p class="paragraph">
    The python CloudI API is provided as both the "cloudi" module and the
    "cloudi_c" module.  The "cloudi_c" module uses the C++ CloudI API for
    more efficiency, while the "cloudi" module only uses Python source code.
  </p>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_termination">1.2 - (termination)</h3>
  <p class="paragraph">
    An internal service uses the termination timeout to limit the
    execution time spent within the cloudi_service_terminate/3 cloudi_service
    behaviour callback function.  An external service uses the
    termination timeout to limit the execution time spent between
    returning from the CloudI API
    <a href="#1_poll">poll</a> function and the service OS process exit.
    The termination timout is slightly less than
    MaxT (maximum time period in seconds) divided by MaxR (maximum restarts)
    to ensure service failures are finite
    (MaxR and MaxT are both service configuration values).
    During termination no CloudI API functions may be called.
    The termination execution time is used to cleanup the service's
    state (e.g., close connections or files).
  </p>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_subscribe">1.3 - subscribe</h3>
  <div class="tabs" style="min-height: 43em;">
  <div id="1_subscribe_C">
  <a href="#1_subscribe_C">C</a>
  <div class="tab_contents">
<pre class="code">
typedef void (*cloudi_callback_t)(int const request_type,
                                  char const * const name,
                                  char const * const pattern,
                                  void const * const request_info,
                                  uint32_t const request_info_size,
                                  void const * const request,
                                  uint32_t const request_size,
                                  uint32_t timeout,
                                  int8_t priority,
                                  char const * const trans_id,
                                  char const * const source,
                                  uint32_t const source_size,
                                  void * state,
                                  cloudi_instance_t * api);
int cloudi_subscribe(cloudi_instance_t * api,
                     char const * const pattern,
                     cloudi_callback_t f);
</pre>
  </div>
  </div> <!-- C -->
  <div id="1_subscribe_CXX">
  <a href="#1_subscribe_CXX">C++</a>
  <div class="tab_contents">
<pre class="code">
template &lt;typename T&gt;
int CloudI::API::subscribe(STRING pattern,
                           T &amp; object,
                           void (T::*f) (CloudI::API const &amp;,
                                         int const,
                                         STRING,
                                         STRING,
                                         void const * const,
                                         uint32_t const,
                                         void const * const,
                                         uint32_t const,
                                         uint32_t,
                                         int8_t,
                                         char const * const,
                                         char const * const,
                                         uint32_t const)) const;
int CloudI::API::subscribe(STRING pattern,
                           void (*f) (API const &amp;,
                                      int const,
                                      STRING,
                                      STRING,
                                      void const * const,
                                      uint32_t const,
                                      void const * const,
                                      uint32_t const,
                                      uint32_t,
                                      int8_t,
                                      char const * const,
                                      char const * const,
                                      uint32_t const)) const
</pre>
  </div>
  </div> <!-- C++ -->
  <div id="1_subscribe_Elixir">
  <a href="#1_subscribe_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
:cloudi_service.subscribe(dispatcher, pattern)
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_subscribe_Erlang">
  <a href="#1_subscribe_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
cloudi_service:subscribe(Dispatcher :: pid(), Pattern :: string()) -&gt;
    ok.
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_subscribe_Go">
  <a href="#1_subscribe_Go">Go</a>
  <div class="tab_contents">
<pre class="code">
func (api *cloudi.Instance) Subscribe(pattern string,
                                      function cloudi.Callback) error
</pre>
  </div>
  </div> <!-- Go -->
  <div id="1_subscribe_Java">
  <a href="#1_subscribe_Java">Java</a>
  <div class="tab_contents">
<pre class="code">
void org.cloudi.API.subscribe(final String pattern,
                              final Object instance,
                              final String methodName);
// with Java &ge; 8 a method reference can be used
void org.cloudi.API.subscribe(final String pattern,
                              final FunctionInterface9 callback);
</pre>
  </div>
  </div> <!-- Java -->
  <div id="1_subscribe_JavaScript">
  <a href="#1_subscribe_JavaScript">JavaScript</a>
  <div class="tab_contents">
<pre class="code">
var callback = function () {};
CloudI.API.subscribe(pattern, object, object_function, callback);
</pre>
  </div>
  </div> <!-- JavaScript -->
  <div id="1_subscribe_Perl">
  <a href="#1_subscribe_Perl">Perl</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API-&gt;subscribe($pattern, $function);
CloudI::API-&gt;subscribe($pattern, $object, $method);
</pre>
  </div>
  </div> <!-- Perl -->
  <div id="1_subscribe_PHP">
  <a href="#1_subscribe_PHP">PHP</a>
  <div class="tab_contents">
<pre class="code">
\CloudI\API::subscribe($pattern, $object, $method);
</pre>
  </div>
  </div> <!-- PHP -->
  <div id="1_subscribe_Python">
  <a href="#1_subscribe_Python">Python</a>
  <div class="tab_contents">
<pre class="code">
cloudi.API.subscribe(pattern, function)
</pre>
  </div>
  </div> <!-- Python -->
  <div id="1_subscribe_Ruby">
  <a href="#1_subscribe_Ruby">Ruby</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API.subscribe(pattern, function)
</pre>
  </div>
  </div> <!-- Ruby -->
  <div id="1_subscribe_code">
  <a href="#1_subscribe_code">&nbsp;</a>
  <div class="tab_contents">
    Subscribe to a service name pattern
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    Subscribes with a service name pattern which provides a destination for
    other services to send to.  The subscribing service will receive a
    service request, if a different service sends a service request with a
    service name that matches the service name pattern.  The service name
    pattern is a string that may contain "*" and "?" wildcard characters,
    to accept any matching service requests.  Either "*" or "?" in a
    service name pattern will match one or more characters
    with "?" never matching the character that follows it
    ("?" is unable to be the last character, i.e.,
     "/?/" matches "/a/" but never "/a/b/" while "/*/" will match either).
    The service names and service name patterns are expected to be in a
    filepath format (e.g., "/root/directory/file.extension") by some
    provided CloudI services, though nothing enforces this convention.
    Good design dictates that service names operate within a given scope.
    Both the service names and the service name patterns should represent
    an appropriate scope, which the service manages
    (i.e., the same concept as a
    <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier" rel="noreferrer" target="_blank">Uniform Resource Identifier (URI)</a>).
  </p>
  <p class="paragraph">
    When a service subscribes to a service name pattern, the supplied pattern
    string is appended to the service name prefix from the service's
    configuration, to provide the full service name pattern.  The prefix
    provided within the service's configuration declares the scope of all
    service operations, as they are seen from other running services.
    Multiple subscribe function calls can increase the probability of
    receiving a service request when other services are subscribed with the
    same service name pattern.
  </p>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_subscribe_count">1.4 - subscribe_count</h3>
  <div class="tabs" style="min-height: 12em;">
  <div id="1_subscribe_count_C">
  <a href="#1_subscribe_count_C">C</a>
  <div class="tab_contents">
<pre class="code">
int cloudi_subscribe_count(cloudi_instance_t * api,
                           char const * const pattern);
// cloudi_get_subscribe_count(p) to get the result
</pre>
  </div>
  </div> <!-- C -->
  <div id="1_subscribe_count_CXX">
  <a href="#1_subscribe_count_CXX">C++</a>
  <div class="tab_contents">
<pre class="code">
int CloudI::API::subscribe_count(STRING pattern) const;
// CloudI::API::get_subscribe_count() to get the result
</pre>
  </div>
  </div> <!-- C++ -->
  <div id="1_subscribe_count_Elixir">
  <a href="#1_subscribe_count_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
:cloudi_service.subscribe_count(dispatcher, pattern)
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_subscribe_count_Erlang">
  <a href="#1_subscribe_count_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
cloudi_service:subscribe_count(Dispatcher :: pid(),
                               Pattern :: string()) -&gt;
    non_neg_integer().
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_subscribe_count_Go">
  <a href="#1_subscribe_count_Go">Go</a>
  <div class="tab_contents">
<pre class="code">
func (api *cloudi.Instance) SubscribeCount(pattern string)
                                          (uint32, error)
</pre>
  </div>
  </div> <!-- Go -->
  <div id="1_subscribe_count_Java">
  <a href="#1_subscribe_count_Java">Java</a>
  <div class="tab_contents">
<pre class="code">
int org.cloudi.API.subscribe_count(final String pattern);
// return value is result
</pre>
  </div>
  </div> <!-- Java -->
  <div id="1_subscribe_count_JavaScript">
  <a href="#1_subscribe_count_JavaScript">JavaScript</a>
  <div class="tab_contents">
<pre class="code">
var callback = function (count) {};
CloudI.API.subscribe_count(pattern, callback);
</pre>
  </div>
  </div> <!-- JavaScript -->
  <div id="1_subscribe_count_Perl">
  <a href="#1_subscribe_count_Perl">Perl</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API-&gt;subscribe_count($pattern);
</pre>
  </div>
  </div> <!-- Perl -->
  <div id="1_subscribe_count_PHP">
  <a href="#1_subscribe_count_PHP">PHP</a>
  <div class="tab_contents">
<pre class="code">
\CloudI\API::subscribe_count($pattern);
</pre>
  </div>
  </div> <!-- PHP -->
  <div id="1_subscribe_count_Python">
  <a href="#1_subscribe_count_Python">Python</a>
  <div class="tab_contents">
<pre class="code">
cloudi.API.subscribe_count(pattern)
# return value is result
</pre>
  </div>
  </div> <!-- Python -->
  <div id="1_subscribe_count_Ruby">
  <a href="#1_subscribe_count_Ruby">Ruby</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API.subscribe_count(pattern)
# return value is result
</pre>
  </div>
  </div> <!-- Ruby -->
  <div id="1_subscribe_count_code">
  <a href="#1_subscribe_count_code">&nbsp;</a>
  <div class="tab_contents">
    Determine how many subscriptions has occurred with a service name pattern
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    Provide a count of how many times a subscription has occurred for a
    specific service name pattern with the current service process.
    Often the result is either 0 or 1, but it is possible to subscribe any
    number of times to change the probability of the service process getting
    a service request, when many service processes are subscribing with the
    same service name.  This function will always check the authoritative
    service process registry, so the result is always correct at that
    point in time (i.e., a lazy destination refresh method will not affect
    the subscribe_count result).
  </p>
  <p class="paragraph">
    subscribe_count would be most common during testing and first learning
    about CloudI, but the function may also be used if the subscribe function
    usage is complex and not tracked separately (i.e., tracked within the
    service process' internal state).
  </p>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_unsubscribe">1.5 - unsubscribe</h3>
  <div class="tabs" style="min-height: 11em;">
  <div id="1_unsubscribe_C">
  <a href="#1_unsubscribe_C">C</a>
  <div class="tab_contents">
<pre class="code">
int cloudi_unsubscribe(cloudi_instance_t * api,
                       char const * const pattern);
</pre>
  </div>
  </div> <!-- C -->
  <div id="1_unsubscribe_CXX">
  <a href="#1_unsubscribe_CXX">C++</a>
  <div class="tab_contents">
<pre class="code">
int CloudI::API::unsubscribe(STRING pattern) const;
</pre>
  </div>
  </div> <!-- C++ -->
  <div id="1_unsubscribe_Elixir">
  <a href="#1_unsubscribe_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
:cloudi_service.unsubscribe(dispatcher, pattern)
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_unsubscribe_Erlang">
  <a href="#1_unsubscribe_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
cloudi_service:unsubscribe(Dispatcher :: pid(), Pattern :: string()) -&gt;
    ok.
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_unsubscribe_Go">
  <a href="#1_unsubscribe_Go">Go</a>
  <div class="tab_contents">
<pre class="code">
func (api *cloudi.Instance) Unsubscribe(pattern string) error
</pre>
  </div>
  </div> <!-- Go -->
  <div id="1_unsubscribe_Java">
  <a href="#1_unsubscribe_Java">Java</a>
  <div class="tab_contents">
<pre class="code">
void org.cloudi.API.unsubscribe(final String pattern);
</pre>
  </div>
  </div> <!-- Java -->
  <div id="1_unsubscribe_JavaScript">
  <a href="#1_unsubscribe_JavaScript">JavaScript</a>
  <div class="tab_contents">
<pre class="code">
var callback = function () {};
CloudI.API.unsubscribe(pattern, callback);
</pre>
  </div>
  </div> <!-- JavaScript -->
  <div id="1_unsubscribe_Perl">
  <a href="#1_unsubscribe_Perl">Perl</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API-&gt;unsubscribe($pattern);
</pre>
  </div>
  </div> <!-- Perl -->
  <div id="1_unsubscribe_PHP">
  <a href="#1_unsubscribe_PHP">PHP</a>
  <div class="tab_contents">
<pre class="code">
\CloudI\API::unsubscribe($pattern);
</pre>
  </div>
  </div> <!-- PHP -->
  <div id="1_unsubscribe_Python">
  <a href="#1_unsubscribe_Python">Python</a>
  <div class="tab_contents">
<pre class="code">
cloudi.API.unsubscribe(pattern)
</pre>
  </div>
  </div> <!-- Python -->
  <div id="1_unsubscribe_Ruby">
  <a href="#1_unsubscribe_Ruby">Ruby</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API.unsubscribe(pattern)
</pre>
  </div>
  </div> <!-- Ruby -->
  <div id="1_unsubscribe_code">
  <a href="#1_unsubscribe_code">&nbsp;</a>
  <div class="tab_contents">
    Unsubscribe from a service name pattern
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    Unsubscribe will remove the service's subscription for the specific
    service name pattern.  If a service has subscribed with the same service
    name pattern multiple times, the unsubscribe will only remove one
    subscription instance.  The subscription instance which is removed
    is whatever subscription would have been called next, for a matching
    service request.
  </p>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_get_pid">1.6 - get_pid (internal services only)</h3>
  <div class="tabs" style="min-height: 15em;">
  <div id="1_get_pid_Elixir">
  <a href="#1_get_pid_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
:cloudi_service.get_pid(dispatcher, name, timeout)
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_get_pid_Erlang">
  <a href="#1_get_pid_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
cloudi_service:get_pid(Dispatcher :: pid(),
                       Name :: string(),
                       Timeout :: non_neg_integer() | 'undefined' |
                                  'limit_min' | 'limit_max') -&gt;
    {'ok', PatternPid :: {string(), pid()}} |
    {'error', Reason :: atom()}.
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_get_pid_code">
  <a href="#1_get_pid_code">&nbsp;</a>
  <div class="tab_contents">
    Get a service process identifier for a service whose service name
    pattern subscription matches the provided service name
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    Internal (Elixir/Erlang-only) services can request an Erlang process
    based on the service name provided, before calling either the
    send_sync function or the send_async function.  The get_pid
    function should rarely be necessary, but it can allow other logic
    to be used for determining which service should receive a request
    (e.g., based on apparent processing power, like within the hexpi test).
    The Erlang PatternPid tuple returned could become invalid if the service
    destination terminated, so the Erlang process monitoring becomes
    the burden of the get_pid function user.  Due to the intimate nature
    of this function, it only exists within the Elixir/Erlang CloudI API
    (to implement it in other languages would cause service destination
     inconsistencies due to the function delay and the potential storage
     before the destination is used).
  </p>
  <p class="paragraph">
     The get_pid function provides a way to split the service name lookup
     latency from the service request latency so that two separate timeout
     values can be used, instead of a single timeout.
  </p>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_get_pids">1.7 - get_pids (internal services only)</h3>
  <div class="tabs" style="min-height: 15em;">
  <div id="1_get_pids_Elixir">
  <a href="#1_get_pids_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
:cloudi_service.get_pids(dispatcher, name, timeout)
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_get_pids_Erlang">
  <a href="#1_get_pids_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
cloudi_service:get_pids(Dispatcher :: pid(),
                        Name :: string(),
                        Timeout :: non_neg_integer() | 'undefined' |
                                   'limit_min' | 'limit_max') -&gt;
    {'ok', PatternPids :: nonempty_list({string(), pid()})} |
    {'error', Reason :: atom()}.
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_get_pids_code">
  <a href="#1_get_pids_code">&nbsp;</a>
  <div class="tab_contents">
    Get all service process identifiers for services whose service name
    pattern subscriptions match the provided service name
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    Internal (Elixir/Erlang-only) services can request a list of Erlang
    processes based on the service name provided, before calling either the
    send_sync function or the send_async function.  If all Erlang processes
    returned need to be used with send_async, it is easier to use the
    <a href="#1_mcast_async">mcast_async</a> function.  The get_pids
    function should rarely be necessary, but it can allow other logic
    to be used for determining which service should receive a request
    (e.g., based on apparent processing power, like within the hexpi test).
    The Erlang PatternPids tuple list returned could contain invalid
    Erlang processes if the service destination terminated, so the
    Erlang process monitoring becomes
    the burden of the get_pids function user.  Due to the intimate nature
    of this function, it only exists within the Elixir/Erlang CloudI API
    (to implement it in other languages would cause service destination
     inconsistencies due to the function delay and the potential storage
     before the destination is used).
  </p>
  <p class="paragraph">
     The get_pids function provides a way to split the service name lookup
     latency from the service request latency so that two separate timeout
     values can be used, instead of a single timeout (e.g., with mcast_async).
  </p>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_send_sync">1.8 - send_sync</h3>
  <div class="tabs" style="min-height: 31em;">
  <div id="1_send_sync_C">
  <a href="#1_send_sync_C">C</a>
  <div class="tab_contents">
<pre class="code">
int cloudi_send_sync_(cloudi_instance_t * api,
                      char const * const name,
                      void const * const request_info,
                      uint32_t const request_info_size,
                      void const * const request,
                      uint32_t const request_size,
                      uint32_t timeout,
                      int8_t const priority);
</pre>
  </div>
  </div> <!-- C -->
  <div id="1_send_sync_CXX">
  <a href="#1_send_sync_CXX">C++</a>
  <div class="tab_contents">
<pre class="code">
int CloudI::API::send_sync(STRING name,
                           void const * const request_info,
                           uint32_t const request_info_size,
                           void const * const request,
                           uint32_t const request_size,
                           uint32_t timeout,
                           int8_t const priority) const;
</pre>
  </div>
  </div> <!-- C++ -->
  <div id="1_send_sync_Elixir">
  <a href="#1_send_sync_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
:cloudi_service.send_sync(dispatcher, name,
                          request_info, request, timeout, priority)
:cloudi_service.send_sync(dispatcher, name,
                          request_info, request, timeout, priority,
                          pattern_pid)
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_send_sync_Erlang">
  <a href="#1_send_sync_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
cloudi_service:send_sync(Dispatcher :: pid(),
                         Name :: string(),
                         RequestInfo :: any(),
                         Request :: any(),
                         Timeout :: non_neg_integer() | 'undefined' |
                                    'limit_min' | 'limit_max',
                         Priority :: integer() | 'undefined') -&gt;
    {'ok', ResponseInfo :: any(), Response :: any()} |
    {'ok', Response :: any()} |
    {'error', Reason :: atom()}.
cloudi_service:send_sync(Dispatcher :: pid(),
                         Name :: string(),
                         RequestInfo :: any(),
                         Request :: any(),
                         Timeout :: non_neg_integer() | 'undefined' |
                                    'limit_min' | 'limit_max',
                         Priority :: integer() | 'undefined',
                         PatternPid :: {string(), pid()}) -&gt;
    {'ok', ResponseInfo :: any(), Response :: any()} |
    {'ok', Response :: any()} |
    {'error', Reason :: atom()}.
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_send_sync_Go">
  <a href="#1_send_sync_Go">Go</a>
  <div class="tab_contents">
<pre class="code">
func (api *cloudi.Instance) SendSync(name string,
                                     requestInfo, request []byte,
                                     timeoutPriority ...interface{})
                                    ([]byte, []byte, []byte, error)
</pre>
  </div>
  </div> <!-- Go -->
  <div id="1_send_sync_Java">
  <a href="#1_send_sync_Java">Java</a>
  <div class="tab_contents">
<pre class="code">
Response org.cloudi.API.send_sync(String name, byte[] request_info,
                                  byte[] request, Integer timeout,
                                  Byte priority);
</pre>
  </div>
  </div> <!-- Java -->
  <div id="1_send_sync_JavaScript">
  <a href="#1_send_sync_JavaScript">JavaScript</a>
  <div class="tab_contents">
<pre class="code">
CloudI.API.send_sync(name, request, callback,
                     timeout, request_info, priority);
</pre>
  </div>
  </div> <!-- JavaScript -->
  <div id="1_send_sync_Perl">
  <a href="#1_send_sync_Perl">Perl</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API-&gt;send_sync($name, $request,
                       $timeout, $request_info, $priority);
</pre>
  </div>
  </div> <!-- Perl -->
  <div id="1_send_sync_PHP">
  <a href="#1_send_sync_PHP">PHP</a>
  <div class="tab_contents">
<pre class="code">
\CloudI\API::send_sync($name, $request,
                       $timeout = null, $request_info = null,
                       $priority = null);
</pre>
  </div>
  </div> <!-- PHP -->
  <div id="1_send_sync_Python">
  <a href="#1_send_sync_Python">Python</a>
  <div class="tab_contents">
<pre class="code">
cloudi.API.send_sync(name, request,
                     timeout=None, request_info=None, priority=None)
</pre>
  </div>
  </div> <!-- Python -->
  <div id="1_send_sync_Ruby">
  <a href="#1_send_sync_Ruby">Ruby</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API.send_sync(name, request,
                      timeout=nil, request_info=nil, priority=nil)
</pre>
  </div>
  </div> <!-- Ruby -->
  <div id="1_send_sync_code">
  <a href="#1_send_sync_code">&nbsp;</a>
  <div class="tab_contents">
    Send a synchronous service request to
    a single service process whose service name
    pattern subscription matches the provided service name
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    Send a synchronous request to a service name with a specific timeout
    and a specific priority.  If a timeout is not provided, the default
    synchronous timeout from the service configuration is used.  If a
    priority is not provided, the default priority from the service
    configuration options is used (normally the default priority is 0).
  </p>
  <div class="tabs" style="min-height: 19em;">
  <div id="1_send_sync_return_C">
  <a href="#1_send_sync_return_C">C</a>
  <div class="tab_contents">
  <p>
    Separate functions are provided to get the function result after
    a successful send_sync function call (an integer 0 return value).
  </p>
<pre class="code">
cloudi_get_response(p)
cloudi_get_response_size(p)
cloudi_get_response_info(p)
cloudi_get_response_info_size(p)
cloudi_get_trans_id_count(p)
cloudi_get_trans_id(p, i)
</pre>
  </div>
  </div> <!-- C -->
  <div id="1_send_sync_return_CXX">
  <a href="#1_send_sync_return_CXX">C++</a>
  <div class="tab_contents">
  <p>
    Separate functions are provided to get the function result after
    a successful send_sync function call (an integer 0 return value).
  </p>
<pre class="code">
char const * CloudI::API::get_response() const;
uint32_t CloudI::API::get_response_size() const;
char const * CloudI::API::get_response_info() const;
uint32_t CloudI::API::get_response_info_size() const;
uint32_t CloudI::API::get_trans_id_count() const;
char const * CloudI::API::get_trans_id(unsigned int const i = 0) const;
</pre>
  </div>
  </div> <!-- C++ -->
  <div id="1_send_sync_return_Elixir">
  <a href="#1_send_sync_return_Elixir">Elixir</a>
  <div class="tab_contents">
  <p>
    response_info is only returned if it does not equal "".
    response is only returned if it does not equal "".
  </p>
<pre class="code">
{:ok, response_info, response}
{:ok, response}
{:error, reason}
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_send_sync_return_Erlang">
  <a href="#1_send_sync_return_Erlang">Erlang</a>
  <div class="tab_contents">
  <p>
    ResponseInfo is only returned if it does not equal &lt;&lt;&gt;&gt;.
    Response is only returned if it does not equal &lt;&lt;&gt;&gt;.
  </p>
<pre class="code">
{'ok', ResponseInfo :: any(), Response :: any()}
{'ok', Response :: any()}
{'error', Reason :: atom()}
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_send_sync_return_Go">
  <a href="#1_send_sync_return_Go">Go</a>
  <div class="tab_contents">
  <p>
    responseInfo is []byte (nil if an error occurred).<br />
    response is []byte (nil if an error occurred).<br />
    transId is []byte (nil if an error occurred).<br />
    err is error (nil if successful).
  </p>
<pre class="code">
(responseInfo, response, transId, err)
</pre>
  </div>
  </div> <!-- Go -->
  <div id="1_send_sync_return_Java">
  <a href="#1_send_sync_return_Java">Java</a>
  <div class="tab_contents">
  <p>
    A class encapsulates the function result.
  </p>
<pre class="code">
org.cloudi.API.Response
</pre>
  </div>
  </div> <!-- Java -->
  <div id="1_send_sync_return_JavaScript">
  <a href="#1_send_sync_return_JavaScript">JavaScript</a>
  <div class="tab_contents">
  <p>
    The callback provides the function result.
  </p>
<pre class="code">
callback(response_info, response, trans_id);
</pre>
  </div>
  </div> <!-- JavaScript -->
  <div id="1_send_sync_return_Perl">
  <a href="#1_send_sync_return_Perl">Perl</a>
  <div class="tab_contents">
  <p>
    An array provides the function result.
  </p>
<pre class="code">
($response_info, $response, $trans_id)
</pre>
  </div>
  </div> <!-- Perl -->
  <div id="1_send_sync_return_PHP">
  <a href="#1_send_sync_return_PHP">PHP</a>
  <div class="tab_contents">
  <p>
    An array provides the function result.
  </p>
<pre class="code">
array($response_info, $response, $trans_id)
</pre>
  </div>
  </div> <!-- PHP -->
  <div id="1_send_sync_return_Python">
  <a href="#1_send_sync_return_Python">Python</a>
  <div class="tab_contents">
  <p>
    A tuple provides the function result.
  </p>
<pre class="code">
(response_info, response, trans_id)
</pre>
  </div>
  </div> <!-- Python -->
  <div id="1_send_sync_return_Ruby">
  <a href="#1_send_sync_return_Ruby">Ruby</a>
  <div class="tab_contents">
  <p>
    An array provides the function result.
  </p>
<pre class="code">
[response_info, response, trans_id]
</pre>
  </div>
  </div> <!-- Ruby -->
  <div id="1_send_sync_return_code">
  <a href="#1_send_sync_return_code">&nbsp;</a>
  <div class="tab_contents">
    send_sync return value
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    The send_sync response data is provided in ways typical to each programming
    language, as shown above.  The non-Erlang send_sync functions
    provide the TransId of the request because the calling service may need
    to use the v1 UUID to manipulate and/or store the response.
  </p>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_send_async">1.9 - send_async</h3>
  <div class="tabs" style="min-height: 29em;">
  <div id="1_send_async_C">
  <a href="#1_send_async_C">C</a>
  <div class="tab_contents">
<pre class="code">
int cloudi_send_async_(cloudi_instance_t * api,
                       char const * const name,
                       void const * const request_info,
                       uint32_t const request_info_size,
                       void const * const request,
                       uint32_t const request_size,
                       uint32_t timeout,
                       int8_t const priority);
</pre>
  </div>
  </div> <!-- C -->
  <div id="1_send_async_CXX">
  <a href="#1_send_async_CXX">C++</a>
  <div class="tab_contents">
<pre class="code">
int CloudI::API::send_async(STRING name,
                            void const * const request_info,
                            uint32_t const request_info_size,
                            void const * const request,
                            uint32_t const request_size,
                            uint32_t timeout,
                            int8_t const priority) const;
</pre>
  </div>
  </div> <!-- C++ -->
  <div id="1_send_async_Elixir">
  <a href="#1_send_async_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
:cloudi_service.send_async(dispatcher, name,
                           request_info, request, timeout, priority)
:cloudi_service.send_async(dispatcher, name,
                           request_info, request, timeout, priority,
                           pattern_pid)
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_send_async_Erlang">
  <a href="#1_send_async_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
cloudi_service:send_async(Dispatcher :: pid(),
                          Name :: string(),
                          RequestInfo :: any(),
                          Request :: any(),
                          Timeout :: non_neg_integer() | 'undefined' |
                                    'limit_min' | 'limit_max',
                          Priority :: integer() | 'undefined') -&gt;
    {'ok', TransId :: &lt;&lt;_:128&gt;&gt;} |
    {'error', Reason :: atom()}.
cloudi_service:send_async(Dispatcher :: pid(),
                          Name :: string(),
                          RequestInfo :: any(),
                          Request :: any(),
                          Timeout :: non_neg_integer() | 'undefined' |
                                    'limit_min' | 'limit_max',
                          Priority :: integer() | 'undefined',
                          PatternPid :: {string(), pid()}) -&gt;
    {'ok', TransId :: &lt;&lt;_:128&gt;&gt;} |
    {'error', Reason :: atom()}.
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_send_async_Go">
  <a href="#1_send_async_Go">Go</a>
  <div class="tab_contents">
<pre class="code">
func (api *cloudi.Instance) SendAsync(name string,
                                      requestInfo, request []byte,
                                      timeoutPriority ...interface{})
                                     ([]byte, error)
</pre>
  </div>
  </div> <!-- Go -->
  <div id="1_send_async_Java">
  <a href="#1_send_async_Java">Java</a>
  <div class="tab_contents">
<pre class="code">
TransId org.cloudi.API.send_async(String name, byte[] request_info,
                                  byte[] request, Integer timeout,
                                  Byte priority);
</pre>
  </div>
  </div> <!-- Java -->
  <div id="1_send_async_JavaScript">
  <a href="#1_send_async_JavaScript">JavaScript</a>
  <div class="tab_contents">
<pre class="code">
CloudI.API.send_async(name, request, callback,
                      timeout, request_info, priority);
</pre>
  </div>
  </div> <!-- JavaScript -->
  <div id="1_send_async_Perl">
  <a href="#1_send_async_Perl">Perl</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API-&gt;send_async($name, $request,
                        $timeout, $request_info, $priority);
</pre>
  </div>
  </div> <!-- Perl -->
  <div id="1_send_async_PHP">
  <a href="#1_send_async_PHP">PHP</a>
  <div class="tab_contents">
<pre class="code">
\CloudI\API::send_async($name, $request,
                        $timeout = null, $request_info = null,
                        $priority = null);
</pre>
  </div>
  </div> <!-- PHP -->
  <div id="1_send_async_Python">
  <a href="#1_send_async_Python">Python</a>
  <div class="tab_contents">
<pre class="code">
cloudi.API.send_async(name, request,
                      timeout=None, request_info=None, priority=None)
</pre>
  </div>
  </div> <!-- Python -->
  <div id="1_send_async_Ruby">
  <a href="#1_send_async_Ruby">Ruby</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API.send_async(name, request,
                       timeout=nil, request_info=nil, priority=nil)
</pre>
  </div>
  </div> <!-- Ruby -->
  <div id="1_send_async_code">
  <a href="#1_send_async_code">&nbsp;</a>
  <div class="tab_contents">
    Send an asynchronous service request to
    a single service process whose service name
    pattern subscription matches the provided service name
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    Send an asynchronous request to a service name with a specific timeout
    and a specific priority.  If a timeout is not provided, the default
    asynchronous timeout from the service configuration is used.  If a
    priority is not provided, the default priority from the service
    configuration options is used (normally the default priority is 0).
  </p>
  <p class="paragraph">
    An asynchronous send will block until a live service matches the
    service name destination or the timeout expires (when the service
    configuration option <a href="#2_services_add_config_opts">request_name_lookup</a>
    is set to 'sync', the default, if an asynchronous lookup is required
    set request_name_lookup to 'async').  Once the asynchronous request is
    sent the TransId which identifies the request is returned.
  </p>
  <div class="tabs" style="min-height: 15em;">
  <div id="1_send_async_return_C">
  <a href="#1_send_async_return_C">C</a>
  <div class="tab_contents">
  <p>
    Separate functions are provided to get the function result after
    a successful send_async function call (an integer 0 return value).
  </p>
<pre class="code">
cloudi_get_trans_id_count(p)
cloudi_get_trans_id(p, i)
</pre>
  </div>
  </div> <!-- C -->
  <div id="1_send_async_return_CXX">
  <a href="#1_send_async_return_CXX">C++</a>
  <div class="tab_contents">
  <p>
    Separate functions are provided to get the function result after
    a successful send_async function call (an integer 0 return value).
  </p>
<pre class="code">
uint32_t CloudI::API::get_trans_id_count() const;
char const * CloudI::API::get_trans_id(unsigned int const i = 0) const;
</pre>
  </div>
  </div> <!-- C++ -->
  <div id="1_send_async_return_Elixir">
  <a href="#1_send_async_return_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
{:ok, trans_id}
{:error, reason}
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_send_async_return_Erlang">
  <a href="#1_send_async_return_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
{'ok', TransId :: &lt;&lt;_:128&gt;&gt;}
{'error', Reason :: atom()}
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_send_async_return_Go">
  <a href="#1_send_async_return_Go">Go</a>
  <div class="tab_contents">
  <p>
    transId is []byte (nil if an error occurred).<br />
    err is error (nil if successful).
  </p>
<pre class="code">
(transId, err)
</pre>
  </div>
  </div> <!-- Go -->
  <div id="1_send_async_return_Java">
  <a href="#1_send_async_return_Java">Java</a>
  <div class="tab_contents">
  <p>
    A class encapsulates the function result.
  </p>
<pre class="code">
org.cloudi.API.TransId
</pre>
  </div>
  </div> <!-- Java -->
  <div id="1_send_async_return_JavaScript">
  <a href="#1_send_async_return_JavaScript">JavaScript</a>
  <div class="tab_contents">
  <p>
    The callback provides the function result,
    the trans_id as a string of 16 bytes.
  </p>
<pre class="code">
callback(trans_id);
</pre>
  </div>
  </div> <!-- JavaScript -->
  <div id="1_send_async_return_Perl">
  <a href="#1_send_async_return_Perl">Perl</a>
  <div class="tab_contents">
  <p>
    The trans_id is a string of 16 bytes.
  </p>
<pre class="code">
$trans_id
</pre>
  </div>
  </div> <!-- Perl -->
  <div id="1_send_async_return_PHP">
  <a href="#1_send_async_return_PHP">PHP</a>
  <div class="tab_contents">
  <p>
    The trans_id is a string of 16 bytes.
  </p>
<pre class="code">
$trans_id
</pre>
  </div>
  </div> <!-- PHP -->
  <div id="1_send_async_return_Python">
  <a href="#1_send_async_return_Python">Python</a>
  <div class="tab_contents">
  <p>
    The trans_id is a string of 16 bytes.
  </p>
<pre class="code">
trans_id
</pre>
  </div>
  </div> <!-- Python -->
  <div id="1_send_async_return_Ruby">
  <a href="#1_send_async_return_Ruby">Ruby</a>
  <div class="tab_contents">
  <p>
    The trans_id is a string of 16 bytes.
  </p>
<pre class="code">
trans_id
</pre>
  </div>
  </div> <!-- Ruby -->
  <div id="1_send_async_return_code">
  <a href="#1_send_async_return_code">&nbsp;</a>
  <div class="tab_contents">
    send_async return value
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    The send_async result is provided in ways typical to each programming
    language, as shown above.  A TransId is a v1 UUID.
  </p>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_send_async_active">1.10 - send_async_active (internal services only)</h3>
  <div class="tabs" style="min-height: 31em;">
  <div id="1_send_async_active_Elixir">
  <a href="#1_send_async_active_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
:cloudi_service.send_async_active(dispatcher, name,
                                  request_info, request,
                                  timeout, priority)
:cloudi_service.send_async_active(dispatcher, name,
                                  request_info, request,
                                  timeout, priority,
                                  pattern_pid)
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_send_async_active_Erlang">
  <a href="#1_send_async_active_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
cloudi_service:send_async_active(Dispatcher :: pid(),
                                 Name :: string(),
                                 RequestInfo :: any(),
                                 Request :: any(),
                                 Timeout :: non_neg_integer() |
                                            'undefined' |
                                            'limit_min' | 'limit_max',
                                 Priority :: integer() | 'undefined') -&gt;
    {'ok', TransId :: &lt;&lt;_:128&gt;&gt;} |
    {'error', atom()}.
cloudi_service:send_async_active(Dispatcher :: pid(),
                                 Name :: string(),
                                 RequestInfo :: any(),
                                 Request :: any(),
                                 Timeout :: non_neg_integer() |
                                            'undefined' |
                                            'limit_min' | 'limit_max',
                                 Priority :: integer() | 'undefined',
                                 PatternPid :: {string(), pid()}) -&gt;
    {'ok', TransId :: &lt;&lt;_:128&gt;&gt;} |
    {'error', atom()}.
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_send_async_active_code">
  <a href="#1_send_async_active_code">&nbsp;</a>
  <div class="tab_contents">
    Send an asynchronous service request to
    a single service process whose service name
    pattern subscription matches the provided service name
    with the result as an Erlang message
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    The send_async_active function provides the same functionality as
    the send_async function within an Erlang process, but the response is
    automatically sent to the Erlang process, after completion.  Using
    send_async_active is the preferred way to send an asynchronous
    service request in Erlang because it utilizes Erlang's concurrency
    without requiring a blocking operation (a passive send, using Erlang
    vernacular, since it would otherwise require a call of the function
    recv_async to receive the request).  The send_async_active function
    is not implemented in other languages because of their lack of
    native event handling.
  </p>
  <div class="tabs" style="min-height: 13em;">
  <div id="1_send_async_active_return_Elixir">
  <a href="#1_send_async_active_return_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
{:return_async_active, name, pattern,
 response_info, response, timeout, trans_id}
{:timeout_async_active, trans_id}
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_send_async_active_return_Erlang">
  <a href="#1_send_async_active_return_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
{'return_async_active', Name :: string(), Pattern :: string(),
 ResponseInfo :: any(), Response :: any(),
 Timeout :: non_neg_integer(), TransId :: &lt;&lt;_:128&gt;&gt;}
{'timeout_async_active', TransId :: &lt;&lt;_:128&gt;&gt;}
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_send_async_active_return_code">
  <a href="#1_send_async_active_return_code">&nbsp;</a>
  <div class="tab_contents">
    send_async_active incoming Erlang process message
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    The send_async_active message is sent to the Erlang process as an
    Erlang message, so it arrives in the cloudi_service_handle_info function
    of the Erlang service module (i.e., the module that implements the
    <a href="api/cloudi_core-2.0.7/cloudi_service.html#description" target="_blank">cloudi_service behavior</a>).
    The message formats are also provided as records that are accessible with:
  </p>
<pre class="code">
-include_lib("cloudi_core/include/cloudi_service.hrl").
</pre>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_mcast_async">1.11 - mcast_async</h3>
  <div class="tabs" style="min-height: 18em;">
  <div id="1_mcast_async_C">
  <a href="#1_mcast_async_C">C</a>
  <div class="tab_contents">
<pre class="code">
int cloudi_mcast_async_(cloudi_instance_t * api,
                        char const * const name,
                        void const * const request_info,
                        uint32_t const request_info_size,
                        void const * const request,
                        uint32_t const request_size,
                        uint32_t timeout,
                        int8_t const priority);
</pre>
  </div>
  </div> <!-- C -->
  <div id="1_mcast_async_CXX">
  <a href="#1_mcast_async_CXX">C++</a>
  <div class="tab_contents">
<pre class="code">
int CloudI::API::mcast_async(STRING name,
                             void const * const request_info,
                             uint32_t const request_info_size,
                             void const * const request,
                             uint32_t const request_size,
                             uint32_t timeout,
                             int8_t const priority) const;
</pre>
  </div>
  </div> <!-- C++ -->
  <div id="1_mcast_async_Elixir">
  <a href="#1_mcast_async_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
:cloudi_service.mcast_async(dispatcher, name,
                            request_info, request, timeout, priority)
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_mcast_async_Erlang">
  <a href="#1_mcast_async_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
cloudi_service:mcast_async(Dispatcher :: pid(),
                           Name :: string(),
                           RequestInfo :: any(),
                           Request :: any(),
                           Timeout :: non_neg_integer() | 'undefined' |
                                      'limit_min' | 'limit_max',
                           Priority :: integer() | 'undefined') -&gt;
    {'ok', TransIdList :: list(&lt;&lt;_:128&gt;&gt;)} |
    {'error', Reason :: atom()}.
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_mcast_async_Go">
  <a href="#1_mcast_async_Go">Go</a>
  <div class="tab_contents">
<pre class="code">
func (api *cloudi.Instance) McastAsync(name string,
                                       requestInfo, request []byte,
                                       timeoutPriority ...interface{})
                                      ([][]byte, error)
</pre>
  </div>
  </div> <!-- Go -->
  <div id="1_mcast_async_Java">
  <a href="#1_mcast_async_Java">Java</a>
  <div class="tab_contents">
<pre class="code">
List&lt;TransId&gt; org.cloudi.API.mcast_async(String name,
                                         byte[] request_info,
                                         byte[] request,
                                         Integer timeout,
                                         Byte priority);
</pre>
  </div>
  </div> <!-- Java -->
  <div id="1_mcast_async_JavaScript">
  <a href="#1_mcast_async_JavaScript">JavaScript</a>
  <div class="tab_contents">
<pre class="code">
CloudI.API.mcast_async(name, request, callback,
                       timeout, request_info, priority);
</pre>
  </div>
  </div> <!-- JavaScript -->
  <div id="1_mcast_async_Perl">
  <a href="#1_mcast_async_Perl">Perl</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API-&gt;mcast_async($name, $request,
                         $timeout, $request_info, $priority);
</pre>
  </div>
  </div> <!-- Perl -->
  <div id="1_mcast_async_PHP">
  <a href="#1_mcast_async_PHP">PHP</a>
  <div class="tab_contents">
<pre class="code">
\CloudI\API::mcast_async($name, $request,
                         $timeout = null, $request_info = null,
                         $priority = null);
</pre>
  </div>
  </div> <!-- PHP -->
  <div id="1_mcast_async_Python">
  <a href="#1_mcast_async_Python">Python</a>
  <div class="tab_contents">
<pre class="code">
cloudi.API.mcast_async(name, request,
                       timeout=None, request_info=None, priority=None)
</pre>
  </div>
  </div> <!-- Python -->
  <div id="1_mcast_async_Ruby">
  <a href="#1_mcast_async_Ruby">Ruby</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API.mcast_async(name, request,
                        timeout=nil, request_info=nil, priority=nil)
</pre>
  </div>
  </div> <!-- Ruby -->
  <div id="1_mcast_async_code">
  <a href="#1_mcast_async_code">&nbsp;</a>
  <div class="tab_contents">
    Send an asynchronous service request to
    all service processes whose service name
    pattern subscriptions match the provided service name
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    Multicast asynchronously, which is the same as publish, except that
    it is possible to respond to the service request.  The function mcast_async
    will send the service request asynchronously to all services that have
    subscribed to a service name pattern that matches the service name
    destination.  The mcast_async function will block until at least a
    single request has been sent or the timeout has expired (when the
    service configuration option <a href="#2_services_add_config_opts">request_name_lookup</a>
    is set to 'sync', the default, if an asynchronous lookup is required set
    request_name_lookup to 'async').  The result of
    the function call is a list of TransIds (one TransId per service request).
    If a publish request is required, the destination service should
    have a <a href="faq.html#4_Null">null response</a>,
    so that the service request response is ignored.
  </p>
  <div class="tabs" style="min-height: 15em;">
  <div id="1_mcast_async_return_C">
  <a href="#1_mcast_async_return_C">C</a>
  <div class="tab_contents">
  <p>
    Separate functions are provided to get the function result after
    a successful send_async function call (an integer 0 return value).
  </p>
<pre class="code">
cloudi_get_trans_id_count(p)
cloudi_get_trans_id(p, i)
</pre>
  </div>
  </div> <!-- C -->
  <div id="1_mcast_async_return_CXX">
  <a href="#1_mcast_async_return_CXX">C++</a>
  <div class="tab_contents">
  <p>
    Separate functions are provided to get the function result after
    a successful send_async function call (an integer 0 return value).
  </p>
<pre class="code">
uint32_t CloudI::API::get_trans_id_count() const;
char const * CloudI::API::get_trans_id(unsigned int const i = 0) const;
</pre>
  </div>
  </div> <!-- C++ -->
  <div id="1_mcast_async_return_Elixir">
  <a href="#1_mcast_async_return_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
{:ok, trans_id_list}
{:error, reason}
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_mcast_async_return_Erlang">
  <a href="#1_mcast_async_return_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
{'ok', TransIdList :: list(&lt;&lt;_:128&gt;&gt;)}
{'error', Reason :: atom()}
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_mcast_async_return_Go">
  <a href="#1_mcast_async_return_Go">Go</a>
  <div class="tab_contents">
  <p>
    transIds is [][]byte (nil if an error occurred).<br />
    err is error (nil if successful).
  </p>
<pre class="code">
(transIds, err)
</pre>
  </div>
  </div> <!-- Go -->
  <div id="1_mcast_async_return_Java">
  <a href="#1_mcast_async_return_Java">Java</a>
  <div class="tab_contents">
  <p>
    A class encapsulates the function result.
  </p>
<pre class="code">
List&lt;org.cloudi.API.TransId&gt;
</pre>
  </div>
  </div> <!-- Java -->
  <div id="1_mcast_async_return_JavaScript">
  <a href="#1_mcast_async_return_JavaScript">JavaScript</a>
  <div class="tab_contents">
  <p>
    The callback provides the function result,
    an array of trans_id strings (each trans_id is a string of 16 bytes).
  </p>
<pre class="code">
callback(trans_ids);
</pre>
  </div>
  </div> <!-- JavaScript -->
  <div id="1_mcast_async_return_Perl">
  <a href="#1_mcast_async_return_Perl">Perl</a>
  <div class="tab_contents">
  <p>
    An array of trans_id strings (each trans_id is a string of 16 bytes).
  </p>
<pre class="code">
@trans_ids
</pre>
  </div>
  </div> <!-- Perl -->
  <div id="1_mcast_async_return_PHP">
  <a href="#1_mcast_async_return_PHP">PHP</a>
  <div class="tab_contents">
  <p>
    An array of trans_id strings (each trans_id is a string of 16 bytes).
  </p>
<pre class="code">
$trans_ids
</pre>
  </div>
  </div> <!-- PHP -->
  <div id="1_mcast_async_return_Python">
  <a href="#1_mcast_async_return_Python">Python</a>
  <div class="tab_contents">
  <p>
    An array of trans_id strings (each trans_id is a string of 16 bytes).
  </p>
<pre class="code">
[trans_id]
</pre>
  </div>
  </div> <!-- Python -->
  <div id="1_mcast_async_return_Ruby">
  <a href="#1_mcast_async_return_Ruby">Ruby</a>
  <div class="tab_contents">
  <p>
    An array of trans_id strings (each trans_id is a string of 16 bytes).
  </p>
<pre class="code">
[trans_id]
</pre>
  </div>
  </div> <!-- Ruby -->
  <div id="1_mcast_async_return_code">
  <a href="#1_mcast_async_return_code">&nbsp;</a>
  <div class="tab_contents">
    mcast_async return value
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    The mcast_async result is provided in ways typical to each programming
    language, as shown above.  A TransId is a v1 UUID.
  </p>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_mcast_async_active">1.12 - mcast_async_active (internal services only)</h3>
  <div class="tabs" style="min-height: 20em;">
  <div id="1_mcast_async_active_Elixir">
  <a href="#1_mcast_async_active_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
:cloudi_service.mcast_async_active(dispatcher, name,
                                   request_info, request,
                                   timeout, priority)
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_mcast_async_active_Erlang">
  <a href="#1_mcast_async_active_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
cloudi_service:mcast_async_active(Dispatcher :: pid(),
                                  Name :: string(),
                                  RequestInfo :: any(),
                                  Request :: any(),
                                  Timeout :: non_neg_integer() |
                                             'undefined' |
                                             'limit_min' | 'limit_max',
                                  Priority :: integer() |
                                              'undefined') -&gt;
    {'ok', TransIdList :: list(&lt;&lt;_:128&gt;&gt;)} |
    {'error', Reason :: atom()}.
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_mcast_async_active_code">
  <a href="#1_mcast_async_active_code">&nbsp;</a>
  <div class="tab_contents">
    Send an asynchronous service request to
    all service processes whose service name
    pattern subscriptions match the provided service name
    with the result as an Erlang message
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    The mcast_async_active function provides the same functionality as
    the mcast_async function within an Erlang process, but the response is
    automatically sent to the Erlang process, after completion.  Using
    mcast_async_active is the preferred way to publish an asynchronous
    service request in Erlang because it utilizes Erlang's concurrency
    without requiring a blocking operation (a passive send, using Erlang
    vernacular, since it would otherwise require a call of the function
    recv_async to receive the request).  The mcast_async_active function
    is not implemented in other languages because of their lack of
    native event handling.
  </p>
  <div class="tabs" style="min-height: 13em;">
  <div id="1_mcast_async_active_return_Elixir">
  <a href="#1_mcast_async_active_return_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
{:return_async_active, name, pattern,
 response_info, response, timeout, trans_id}
{:timeout_async_active, trans_id}
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_mcast_async_active_return_Erlang">
  <a href="#1_mcast_async_active_return_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
{'return_async_active', Name :: string(), Pattern :: string(),
 ResponseInfo :: any(), Response :: any(),
 Timeout :: non_neg_integer(), TransId :: &lt;&lt;_:128&gt;&gt;}
{'timeout_async_active', TransId :: &lt;&lt;_:128&gt;&gt;}
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_mcast_async_active_return_code">
  <a href="#1_mcast_async_active_return_code">&nbsp;</a>
  <div class="tab_contents">
    mcast_async_active incoming Erlang process message
    (the same as <a href="#1_send_async_active_return_Erlang">send_async_active</a>
    messages)
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    The mcast_async_active message is sent to the Erlang process as an
    Erlang message, so it arrives in the cloudi_service_handle_info function
    of the Erlang service module (i.e., the module that implements the
    <a href="api/cloudi_core-2.0.7/cloudi_service.html#description" target="_blank">cloudi_service behavior</a>).
    The message formats are also provided as records that are accessible with:
  </p>
<pre class="code">
-include_lib("cloudi_core/include/cloudi_service.hrl").
</pre>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_recv_async">1.13 - recv_async</h3>
  <div class="tabs" style="min-height: 18em;">
  <div id="1_recv_async_C">
  <a href="#1_recv_async_C">C</a>
  <div class="tab_contents">
<pre class="code">
int cloudi_recv_async(cloudi_instance_t * api,
                      uint32_t timeout,
                      char const * const trans_id,
                      int consume);
</pre>
  </div>
  </div> <!-- C -->
  <div id="1_recv_async_CXX">
  <a href="#1_recv_async_CXX">C++</a>
  <div class="tab_contents">
<pre class="code">
int CloudI::API::recv_async(uint32_t timeout,
                            STRING trans_id,
                            bool consume) const;
</pre>
  </div>
  </div> <!-- C++ -->
  <div id="1_recv_async_Elixir">
  <a href="#1_recv_async_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
:cloudi_service.recv_async(dispatcher, timeout, trans_id, consume)
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_recv_async_Erlang">
  <a href="#1_recv_async_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
cloudi_service:recv_async(Dispatcher :: pid(),
                          Timeout :: non_neg_integer() | 'undefined' |
                                     'limit_min' | 'limit_max',
                          TransId :: &lt;&lt;_:128&gt;&gt;,
                          Consume :: boolean()) -&gt;
    {'ok', ResponseInfo :: any(), Response :: any(),
           TransId :: &lt;&lt;_:128&gt;&gt;} |
    {'error', Reason :: atom()}.
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_recv_async_Go">
  <a href="#1_recv_async_Go">Go</a>
  <div class="tab_contents">
<pre class="code">
func (api *cloudi.Instance) RecvAsync(extra ...interface{})
                                     ([]byte, []byte, []byte, error)
</pre>
  </div>
  </div> <!-- Go -->
  <div id="1_recv_async_Java">
  <a href="#1_recv_async_Java">Java</a>
  <div class="tab_contents">
<pre class="code">
Response org.cloudi.API.recv_async(Integer timeout, byte[] transId,
                                   boolean consume);
</pre>
  </div>
  </div> <!-- Java -->
  <div id="1_recv_async_JavaScript">
  <a href="#1_recv_async_JavaScript">JavaScript</a>
  <div class="tab_contents">
<pre class="code">
CloudI.API.recv_async(callback,
                      timeout, trans_id, consume);
</pre>
  </div>
  </div> <!-- JavaScript -->
  <div id="1_recv_async_Perl">
  <a href="#1_recv_async_Perl">Perl</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API-&gt;recv_async($timeout, $trans_id, $consume);
</pre>
  </div>
  </div> <!-- Perl -->
  <div id="1_recv_async_PHP">
  <a href="#1_recv_async_PHP">PHP</a>
  <div class="tab_contents">
<pre class="code">
\CloudI\API::recv_async($timeout = null, $trans_id = null,
                        $consume = true);
</pre>
  </div>
  </div> <!-- PHP -->
  <div id="1_recv_async_Python">
  <a href="#1_recv_async_Python">Python</a>
  <div class="tab_contents">
<pre class="code">
cloudi.API.recv_async(timeout=None, trans_id=None, consume=True)
</pre>
  </div>
  </div> <!-- Python -->
  <div id="1_recv_async_Ruby">
  <a href="#1_recv_async_Ruby">Ruby</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API.recv_async(timeout=nil, trans_id=nil, consume=true)
</pre>
  </div>
  </div> <!-- Ruby -->
  <div id="1_recv_async_code">
  <a href="#1_recv_async_code">&nbsp;</a>
  <div class="tab_contents">
    Receive an asynchronous service request response
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    Receive an asynchronous service request's response.  If a TransId is not
    provided, a null UUID is used to request the oldest response
    that has not timed out.  By default, the recv_async function will consume
    the service request so it is not accessible with the same function call
    in the future.  The TransId of the service request is always returned
    for any external use or tracking of the request or response.
  </p>
  <div class="tabs" style="min-height: 19em;">
  <div id="1_recv_async_return_C">
  <a href="#1_recv_async_return_C">C</a>
  <div class="tab_contents">
  <p>
    Separate functions are provided to get the function result after
    a successful recv_async function call (an integer 0 return value).
  </p>
<pre class="code">
cloudi_get_response(p)
cloudi_get_response_size(p)
cloudi_get_response_info(p)
cloudi_get_response_info_size(p)
cloudi_get_trans_id_count(p)
cloudi_get_trans_id(p, i)
</pre>
  </div>
  </div> <!-- C -->
  <div id="1_recv_async_return_CXX">
  <a href="#1_recv_async_return_CXX">C++</a>
  <div class="tab_contents">
  <p>
    Separate functions are provided to get the function result after
    a successful recv_async function call (an integer 0 return value).
  </p>
<pre class="code">
char const * CloudI::API::get_response() const;
uint32_t CloudI::API::get_response_size() const;
char const * CloudI::API::get_response_info() const;
uint32_t CloudI::API::get_response_info_size() const;
uint32_t CloudI::API::get_trans_id_count() const;
char const * CloudI::API::get_trans_id(unsigned int const i = 0) const;
</pre>
  </div>
  </div> <!-- C++ -->
  <div id="1_recv_async_return_Elixir">
  <a href="#1_recv_async_return_Elixir">Elixir</a>
  <div class="tab_contents">
  <p>
    response_info and response are only returned if both
    do not not equal "".
  </p>
<pre class="code">
{:ok, response_info, response, trans_id}
{:error, reason}
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_recv_async_return_Erlang">
  <a href="#1_recv_async_return_Erlang">Erlang</a>
  <div class="tab_contents">
  <p>
    ResponseInfo and Response are only returned if both
    do not not equal &lt;&lt;&gt;&gt;.
  </p>
<pre class="code">
{'ok', ResponseInfo :: any(), Response :: any(),
       TransId :: &lt;&lt;_:128&gt;&gt;}
{'error', Reason :: atom()}
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_recv_async_return_Go">
  <a href="#1_recv_async_return_Go">Go</a>
  <div class="tab_contents">
  <p>
    responseInfo is []byte (nil if an error occurred).<br />
    response is []byte (nil if an error occurred).<br />
    transId is []byte (nil if an error occurred).<br />
    err is error (nil if successful).
  </p>
<pre class="code">
(responseInfo, response, transId, err)
</pre>
  </div>
  </div> <!-- Go -->
  <div id="1_recv_async_return_Java">
  <a href="#1_recv_async_return_Java">Java</a>
  <div class="tab_contents">
  <p>
    A class encapsulates the function result.
  </p>
<pre class="code">
org.cloudi.API.Response
</pre>
  </div>
  </div> <!-- Java -->
  <div id="1_recv_async_return_JavaScript">
  <a href="#1_recv_async_return_JavaScript">JavaScript</a>
  <div class="tab_contents">
  <p>
    The callback provides the function result.
  </p>
<pre class="code">
callback(response_info, response, trans_id);
</pre>
  </div>
  </div> <!-- JavaScript -->
  <div id="1_recv_async_return_Perl">
  <a href="#1_recv_async_return_Perl">Perl</a>
  <div class="tab_contents">
  <p>
    An array provides the function result.
  </p>
<pre class="code">
($response_info, $response, $trans_id)
</pre>
  </div>
  </div> <!-- Perl -->
  <div id="1_recv_async_return_PHP">
  <a href="#1_recv_async_return_PHP">PHP</a>
  <div class="tab_contents">
  <p>
    An array provides the function result.
  </p>
<pre class="code">
array($response_info, $response, $trans_id)
</pre>
  </div>
  </div> <!-- PHP -->
  <div id="1_recv_async_return_Python">
  <a href="#1_recv_async_return_Python">Python</a>
  <div class="tab_contents">
  <p>
    A tuple provides the function result.
  </p>
<pre class="code">
(response_info, response, trans_id)
</pre>
  </div>
  </div> <!-- Python -->
  <div id="1_recv_async_return_Ruby">
  <a href="#1_recv_async_return_Ruby">Ruby</a>
  <div class="tab_contents">
  <p>
    An array provides the function result.
  </p>
<pre class="code">
[response_info, response, trans_id]
</pre>
  </div>
  </div> <!-- Ruby -->
  <div id="1_recv_async_return_code">
  <a href="#1_recv_async_return_code">&nbsp;</a>
  <div class="tab_contents">
    recv_async return value
  </div>
  </div> <!-- Description -->
  </div>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_recv_asyncs">1.14 - recv_asyncs (internal services only)</h3>
  <div class="tabs" style="min-height: 18em;">
  <div id="1_recv_asyncs_Elixir">
  <a href="#1_recv_asyncs_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
:cloudi_service.recv_asyncs(dispatcher,
                            timeout, trans_id_list, consume)
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_recv_asyncs_Erlang">
  <a href="#1_recv_asyncs_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
cloudi_service:recv_asyncs(Dispatcher :: pid(),
                           Timeout :: non_neg_integer() | 'undefined' |
                                      'limit_min' | 'limit_max',
                           TransIdList :: list(&lt;&lt;_:128&gt;&gt;),
                           Consume :: boolean()) -&gt;
    {'ok', list({ResponseInfo :: any(), Response :: any(),
                 TransId :: &lt;&lt;_:128&gt;&gt;})} |
    {'error', Reason :: atom()}.
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_recv_asyncs_code">
  <a href="#1_recv_asyncs_code">&nbsp;</a>
  <div class="tab_contents">
    Receive many asynchronous service request responses
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    Internal (Elixir/Erlang-only) services can block to receive multiple
    asynchronous service request responses.  By default, the recv_asyncs
    function will consume the service request so it is not accessible with the
    same function call in the future.  The TransId of the service request is
    always returned for any external use or tracking of the request or response.
    The recv_asyncs function is not implemented in other languages to avoid
    unbounded memory consumption and caching/heap allocation impossibilities.
  </p>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_return">1.15 - return</h3>
  <div class="tabs" style="min-height: 22em;">
  <div id="1_return_C">
  <a href="#1_return_C">C</a>
  <div class="tab_contents">
<pre class="code">
int cloudi_return(cloudi_instance_t * api,
                  int const request_type,
                  char const * const name,
                  char const * const pattern,
                  void const * const response_info,
                  uint32_t const response_info_size,
                  void const * const response,
                  uint32_t const response_size,
                  uint32_t timeout,
                  char const * const trans_id,
                  char const * const source,
                  uint32_t const source_size);
</pre>
  </div>
  </div> <!-- C -->
  <div id="1_return_CXX">
  <a href="#1_return_CXX">C++</a>
  <div class="tab_contents">
<pre class="code">
int CloudI::API::return_(int const request_type,
                         STRING name,
                         STRING pattern,
                         void const * const response_info,
                         uint32_t const response_info_size,
                         void const * const response,
                         uint32_t const response_size,
                         uint32_t timeout,
                         char const * const trans_id,
                         char const * const source,
                         uint32_t const source_size) const;
</pre>
  </div>
  </div> <!-- C++ -->
  <div id="1_return_Elixir">
  <a href="#1_return_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
:cloudi_service.return(dispatcher, request_type, name, pattern,
                       response_info, response,
                       timeout, trans_id, source)
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_return_Erlang">
  <a href="#1_return_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
cloudi_service:return(Dispatcher :: pid(),
                      RequestType :: 'send_async' | 'send_sync',
                      Name :: string(),
                      Pattern :: string(),
                      ResponseInfo :: any(),
                      Response :: any(),
                      Timeout :: non_neg_integer(),
                      TransId :: &lt;&lt;_:128&gt;&gt;,
                      Source :: pid()) -&gt;
    none().
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_return_Go">
  <a href="#1_return_Go">Go</a>
  <div class="tab_contents">
<pre class="code">
func (api *cloudi.Instance) Return(requestType int,
                                   name, pattern string,
                                   responseInfo, response []byte,
                                   timeout uint32,
                                   transId [16]byte,
                                   source cloudi.Source)
</pre>
  </div>
  </div> <!-- Go -->
  <div id="1_return_Java">
  <a href="#1_return_Java">Java</a>
  <div class="tab_contents">
<pre class="code">
void org.cloudi.API.return_(Integer request_type,
                            String name, String pattern,
                            byte[] response_info, byte[] response,
                            Integer timeout, byte[] transId,
                            OtpErlangPid source);
</pre>
  </div>
  </div> <!-- Java -->
  <div id="1_return_JavaScript">
  <a href="#1_return_JavaScript">JavaScript</a>
  <div class="tab_contents">
<pre class="code">
CloudI.API.return_(request_type, name, pattern,
                   response_info, response, timeout, trans_id, source);
</pre>
  </div>
  </div> <!-- JavaScript -->
  <div id="1_return_Perl">
  <a href="#1_return_Perl">Perl</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API-&gt;return_($request_type, $name, $pattern,
                     $response_info, $response,
                     $timeout, $trans_id, $source);
</pre>
  </div>
  </div> <!-- Perl -->
  <div id="1_return_PHP">
  <a href="#1_return_PHP">PHP</a>
  <div class="tab_contents">
<pre class="code">
\CloudI\API::return_($request_type, $name, $pattern,
                     $response_info, $response,
                     $timeout, $trans_id, $source);
</pre>
  </div>
  </div> <!-- PHP -->
  <div id="1_return_Python">
  <a href="#1_return_Python">Python</a>
  <div class="tab_contents">
<pre class="code">
cloudi.API.return_(request_type, name, pattern, response_info, response,
                   timeout, trans_id, source)
</pre>
  </div>
  </div> <!-- Python -->
  <div id="1_return_Ruby">
  <a href="#1_return_Ruby">Ruby</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API.return_(request_type, name, pattern, response_info, response,
                    timeout, trans_id, source)
</pre>
  </div>
  </div> <!-- Ruby -->
  <div id="1_return_code">
  <a href="#1_return_code">&nbsp;</a>
  <div class="tab_contents">
    Return a received service request response
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    Return a response to a service request.  The return function will
    throw a caught exception so that the request handler execution is aborted
    after returning the service request response.  The simplest
    and preferred way to return a response within an Erlang service is to
    utilize the cloudi_service_handle_request functon return values used by the
    <a href="api/cloudi_core-2.0.7/cloudi_service.html#Module%3acloudi_service_handle_request-11" target="_blank">cloudi_service behavior</a>.  You can also
    utilize the request handler return value for the response in the
    programming languages Java, Python, and Ruby.  However, within the
    external services it is more explicit (i.e., easier to understand the
    source code) when the source code uses the return functions.
  </p>
  <p class="paragraph">
    If the service is configured with the request_timeout_adjustment option set
    to true (the default is false), the request handler execution time will
    automatically decrement the request timeout, after the request has been
    handled.  If the service is configured with the response_timeout_adjustment
    option set to true (the default is false), the response timeout is
    automatically decremented based on the sender-side's timing (more accurate).
  </p>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_forward">1.16 - forward</h3>
  <div class="tabs" style="min-height: 22em;">
  <div id="1_forward_C">
  <a href="#1_forward_C">C</a>
  <div class="tab_contents">
<pre class="code">
int cloudi_forward(cloudi_instance_t * api,
                   int const request_type,
                   char const * const name,
                   void const * const request_info,
                   uint32_t const request_info_size,
                   void const * const request,
                   uint32_t const request_size,
                   uint32_t timeout,
                   int8_t const priority,
                   char const * const trans_id,
                   char const * const source,
                   uint32_t const source_size);
</pre>
  </div>
  </div> <!-- C -->
  <div id="1_forward_CXX">
  <a href="#1_forward_CXX">C++</a>
  <div class="tab_contents">
<pre class="code">
int CloudI::API::forward_(int const request_type,
                          STRING name,
                          void const * const request_info,
                          uint32_t const request_info_size,
                          void const * const request,
                          uint32_t const request_size,
                          uint32_t timeout,
                          int8_t const priority,
                          char const * const trans_id,
                          char const * const source,
                          uint32_t const source_size) const;
</pre>
  </div>
  </div> <!-- C++ -->
  <div id="1_forward_Elixir">
  <a href="#1_forward_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
:cloudi_service.forward(dispatcher, request_type, name,
                        request_info, request,
                        timeout, priority, trans_id, source)
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_forward_Erlang">
  <a href="#1_forward_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
cloudi_service:forward(Dispatcher :: pid(),
                       RequestType :: 'send_async' | 'send_sync',
                       Name :: string(),
                       RequestInfo :: any(),
                       Request :: any(),
                       Timeout :: non_neg_integer(),
                       Priority :: integer(),
                       TransId :: &lt;&lt;_:128&gt;&gt;,
                       Source :: pid()) -&gt;
    none().
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_forward_Go">
  <a href="#1_forward_Go">Go</a>
  <div class="tab_contents">
<pre class="code">
func (api *cloudi.Instance) Forward(requestType int,
                                    name string,
                                    requestInfo, request []byte,
                                    timeout uint32,
                                    priority int8,
                                    transId [16]byte,
                                    source cloudi.Source)
</pre>
  </div>
  </div> <!-- Go -->
  <div id="1_forward_Java">
  <a href="#1_forward_Java">Java</a>
  <div class="tab_contents">
<pre class="code">
Response org.cloudi.API.forward_(Integer request_type, String name,
                                 byte[] request_info, byte[] request,
                                 Integer timeout, Byte priority,
                                 byte[] transId, OtpErlangPid source);
</pre>
  </div>
  </div> <!-- Java -->
  <div id="1_forward_JavaScript">
  <a href="#1_forward_JavaScript">JavaScript</a>
  <div class="tab_contents">
<pre class="code">
CloudI.API.forward_(request_type, name, request_info, request,
                    timeout, priority, trans_id, source);
</pre>
  </div>
  </div> <!-- JavaScript -->
  <div id="1_forward_Perl">
  <a href="#1_forward_Perl">Perl</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API-&gt;forward_($request_type, $name, $request_info, $request,
                      $timeout, $priority, $trans_id, $source);
</pre>
  </div>
  </div> <!-- Perl -->
  <div id="1_forward_PHP">
  <a href="#1_forward_PHP">PHP</a>
  <div class="tab_contents">
<pre class="code">
\CloudI\API::forward_($request_type, $name, $request_info, $request,
                      $timeout, $priority, $trans_id, $source);
</pre>
  </div>
  </div> <!-- PHP -->
  <div id="1_forward_Python">
  <a href="#1_forward_Python">Python</a>
  <div class="tab_contents">
<pre class="code">
cloudi.API.forward_(request_type, name, request_info, request,
                    timeout, priority, trans_id, source)
</pre>
  </div>
  </div> <!-- Python -->
  <div id="1_forward_Ruby">
  <a href="#1_forward_Ruby">Ruby</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API.forward_(request_type, name, request_info, request,
                     timeout, priority, trans_id, source)
</pre>
  </div>
  </div> <!-- Ruby -->
  <div id="1_forward_code">
  <a href="#1_forward_code">&nbsp;</a>
  <div class="tab_contents">
    Forward a received service request to
    a single service process whose service name
    pattern subscription matches the provided service name
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    Forward the service request to a different destination, possibly with
    different parameters (e.g., a completely different request).  The forward
    function will throw a caught exception so that the request handler
    execution is aborted after forwarding the service request.  The simplest
    and preferred way to forward a request within an Erlang service is to
    utilize the cloudi_service_handle_request functon return values used by the
    <a href="api/cloudi_core-2.0.7/cloudi_service.html#Module%3acloudi_service_handle_request-11" target="_blank">cloudi_service behavior</a>.
    All external services must use a forward function when forwarding a request.
  </p>
  <p class="paragraph">
    If the service is configured with the request_timeout_adjustment option set
    to true (the default is false), the request handler execution time will
    automatically decrement the request timeout, after the request has been
    handled.  If the service is configured with the response_timeout_adjustment
    option set to true (the default is false), the response timeout is
    automatically decremented based on the sender-side's timing (more accurate).
  </p>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_poll">1.17 - poll (external services only)</h3>
  <div class="tabs" style="min-height: 11em;">
  <div id="1_poll_C">
  <a href="#1_poll_C">C</a>
  <div class="tab_contents">
<pre class="code">
int cloudi_poll(cloudi_instance_t * api,
                int timeout);
</pre>
  </div>
  </div> <!-- C -->
  <div id="1_poll_CXX">
  <a href="#1_poll_CXX">C++</a>
  <div class="tab_contents">
<pre class="code">
int CloudI::API::poll(int timeout = -1);
</pre>
  </div>
  </div> <!-- C++ -->
  <div id="1_poll_Go">
  <a href="#1_poll_Go">Go</a>
  <div class="tab_contents">
<pre class="code">
func (api *cloudi.Instance) Poll(timeout int32) (bool, error)
</pre>
  </div>
  </div> <!-- Go -->
  <div id="1_poll_Java">
  <a href="#1_poll_Java">Java</a>
  <div class="tab_contents">
<pre class="code">
boolean org.cloudi.API.poll(int timeout);
</pre>
  </div>
  </div> <!-- Java -->
  <div id="1_poll_JavaScript">
  <a href="#1_poll_JavaScript">JavaScript</a>
  <div class="tab_contents">
<pre class="code">
var callback = function (timeout_) {};
CloudI.API.poll(callback, timeout);
</pre>
  </div>
  </div> <!-- JavaScript -->
  <div id="1_poll_Perl">
  <a href="#1_poll_Perl">Perl</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API-&gt;poll($timeout);
</pre>
  </div>
  </div> <!-- Perl -->
  <div id="1_poll_PHP">
  <a href="#1_poll_PHP">PHP</a>
  <div class="tab_contents">
<pre class="code">
\CloudI\API::poll($timeout = -1);
</pre>
  </div>
  </div> <!-- PHP -->
  <div id="1_poll_Python">
  <a href="#1_poll_Python">Python</a>
  <div class="tab_contents">
<pre class="code">
cloudi.API.poll(timeout=-1)
</pre>
  </div>
  </div> <!-- Python -->
  <div id="1_poll_Ruby">
  <a href="#1_poll_Ruby">Ruby</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API.poll(timeout=nil)
</pre>
  </div>
  </div> <!-- Ruby -->
  <div id="1_poll_code">
  <a href="#1_poll_code">&nbsp;</a>
  <div class="tab_contents">
    Handle incoming service requests
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    External services use the poll function to accept service requests
    while blocking execution until either the timeout value expires or the
    service terminates.  The execution time before the first poll function
    call is service <a href="#1_initialization">initialization</a>.
    The timeout value is specified in milliseconds.  A timeout value of 0 can
    be used to not block on the poll function call.  If the timeout value is
    not provided a value of -1 is used to make the poll function call
    block until service termination (if the programming language allows
    default function argument or function overloading).  A boolean true
    value is used as the poll function return value if a timeout occurred
    (a non zero return value if the return value is an integer).  A boolean
    false value is used as the poll function return value if service
    <a href="#1_termination">termination</a> is in-progress.
  </p>
  <div class="top"><a href="#Service">Top</a></div>

  <h3 id="1_shutdown">1.18 - shutdown</h3>
  <div class="tabs" style="min-height: 22em;">
  <div id="1_shutdown_C">
  <a href="#1_shutdown_C">C</a>
  <div class="tab_contents">
<pre class="code">
int cloudi_shutdown(cloudi_instance_t * api,
                    char const * const reason);
</pre>
  </div>
  </div> <!-- C -->
  <div id="1_shutdown_CXX">
  <a href="#1_shutdown_CXX">C++</a>
  <div class="tab_contents">
<pre class="code">
int CloudI::API::shutdown() const;
int CloudI::API::shutdown(STRING reason) const;
</pre>
  </div>
  </div> <!-- C++ -->
  <div id="1_shutdown_Elixir">
  <a href="#1_shutdown_Elixir">Elixir</a>
  <div class="tab_contents">
<pre class="code">
% cloudi_service behaviour return values:
{:stop, :shutdown}
{:stop, {:shutdown, 'reason'}}
{:stop, :shutdown, state}
{:stop, {:shutdown, 'reason'}, state}
</pre>
  </div>
  </div> <!-- Elixir -->
  <div id="1_shutdown_Erlang">
  <a href="#1_shutdown_Erlang">Erlang</a>
  <div class="tab_contents">
<pre class="code">
% cloudi_service behaviour return values:
{stop, shutdown}
{stop, {shutdown, "reason"}}
{stop, shutdown, State}
{stop, {shutdown, "reason"}, State}
</pre>
  </div>
  </div> <!-- Erlang -->
  <div id="1_shutdown_Go">
  <a href="#1_shutdown_Go">Go</a>
  <div class="tab_contents">
<pre class="code">
func (api *cloudi.Instance) Shutdown(extra ...interface{}) error
</pre>
  </div>
  </div> <!-- Go -->
  <div id="1_shutdown_Java">
  <a href="#1_shutdown_Java">Java</a>
  <div class="tab_contents">
<pre class="code">
void org.cloudi.API.shutdown();
void org.cloudi.API.shutdown(String reason);
</pre>
  </div>
  </div> <!-- Java -->
  <div id="1_shutdown_JavaScript">
  <a href="#1_shutdown_JavaScript">JavaScript</a>
  <div class="tab_contents">
<pre class="code">
CloudI.API.shutdown(callback, reason);
</pre>
  </div>
  </div> <!-- JavaScript -->
  <div id="1_shutdown_Perl">
  <a href="#1_shutdown_Perl">Perl</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API-&gt;shutdown($reason);
</pre>
  </div>
  </div> <!-- Perl -->
  <div id="1_shutdown_PHP">
  <a href="#1_shutdown_PHP">PHP</a>
  <div class="tab_contents">
<pre class="code">
\CloudI\API::shutdown($reason = null);
</pre>
  </div>
  </div> <!-- PHP -->
  <div id="1_shutdown_Python">
  <a href="#1_shutdown_Python">Python</a>
  <div class="tab_contents">
<pre class="code">
cloudi.API.shutdown(reason=None)
</pre>
  </div>
  </div> <!-- Python -->
  <div id="1_shutdown_Ruby">
  <a href="#1_shutdown_Ruby">Ruby</a>
  <div class="tab_contents">
<pre class="code">
CloudI::API.shutdown(reason=nil)
</pre>
  </div>
  </div> <!-- Ruby -->
  <div id="1_shutdown_code">
  <a href="#1_shutdown_code">&nbsp;</a>
  <div class="tab_contents">
    Cause the service instance to have a successful shutdown
  </div>
  </div> <!-- Description -->
  </div>
  <p class="paragraph">
    The shutdown functionality provides a way of successfully stopping the
    service instance when no error has occurred.  All service processes are
    stopped and the service is removed without causing any service process
    restarts.  An optional reason string may be provided to log the reason
    for the service shutdown.
  </p>
  <div class="top"><a href="#Service">Top</a></div>

  <hr>
  <h2>CloudI Service API - Controlling CloudI</h2>

  <h3 id="2_Intro">2.0 - Introduction</h3>
  <p class="paragraph">
    When CloudI is first started, the configuration file at
    <a href="https://github.com/CloudI/CloudI/blob/master/src/cloudi_minimal.conf.in" rel="noopener" target="_blank">/usr/local/etc/cloudi/cloudi.conf</a>
    is used to determine what
    Access Control Lists (ACLs) should be used for services,
    what services should be started, what nodes should be connected,
    and what logging should occur.  All the configuration functionality
    for CloudI can be done dynamically, after startup, with the
    CloudI Service API.  A typical way to use the Service API is with
    either erlang terms or JSON-RPC over HTTP (using
    cloudi_service_api_requests and cloudi_service_http_cowboy).
    The CloudI Service API can also be accessed directly within the
    Erlang VM by using the
    <a href="api/cloudi_core-2.0.7/cloudi_service_api.html#index" target="_blank">cloudi_service_api module</a>.
  </p>
  <table><tr><th>
    Protocol
  </th><th>
    Example
  </th></tr><tr><td>
    Erlang
  </td><td>
<p class="code">
curl http://localhost:6464/cloudi/api/rpc/services.erl
</p>
  </td></tr><tr><td>
    JSON&#8209;RPC
  </td><td>
<p class="code">
curl -X POST -d '{"method": "services", "params":[], "id": 1}' http://localhost:6464/cloudi/api/rpc.json
</p>
  </td></tr></table>
  <p class="paragraph">
    The data returned in both examples is Erlang terms within a string.
    All of the examples below use the Erlang protocol.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_acl_add">2.1 - acl_add</h3>
<p class="code">
curl -X POST -d '[{sensitive, ["/accouting/*", "/finance/*"]}]' http://localhost:6464/cloudi/api/rpc/acl_add.erl
</p>
  <p class="paragraph">
    Add more ACL entries to be later used when starting services.  An ACL
    entry is an Erlang atom() -&gt; list(atom() | string()) relationship which
    provides a logical grouping of service name patterns
    (e.g., {api, ["/cloudi/api/*"]}).
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_acl_remove">2.2 - acl_remove</h3>
<p class="code">
curl -X POST -d '[sensitive]' http://localhost:6464/cloudi/api/rpc/acl_remove.erl
</p>
  <p class="paragraph">
    Remove ACL entries that are no longer needed.  Running services will
    retain their configuration, so this impacts services that are
    started in the future.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_acl">2.3 - acl</h3>
<p class="code">
curl http://localhost:6464/cloudi/api/rpc/acl.erl
</p>
  <p class="paragraph">
    List all the current ACL entries as lists of service name patterns.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_service_subscriptions">2.4 - service_subscriptions</h3>
<p class="code">
curl -X POST -d '"6a675470-7a1f-11e2-d40e-a5dd00000058"' http://localhost:6464/cloudi/api/rpc/service_subscriptions.erl
</p>
  <p class="paragraph">
    List the subscriptions a service instance has initiated.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_services_add">2.5 - services_add</h3>
<p class="code">
curl -X POST -d '[{internal, "/tests/http_req/", cloudi_service_request_rate, [{service_name, "/tests/http_req/ruby.xml/get"}, {request_rate, dynamic}], lazy_closest, 5000, 5000, 5000, undefined, undefined, 1, 5, 300, [{duo_mode, true}]}]' http://localhost:6464/cloudi/api/rpc/services_add.erl
</p>
  <p class="paragraph">
    Start services and return their Service UUIDs.  Provide service
    configuration using the same syntax
    found in the configuration file (i.e., <a href="https://github.com/CloudI/CloudI/blob/master/src/cloudi_minimal.conf.in" rel="noopener" target="_blank">/usr/local/etc/cloudi/cloudi.conf</a>).
    Internal services will need to be located in a code path that the
    running Erlang VM is aware of (see
    <a href="#2_code_path_add">code_path_add</a>).  The syntax of the
    configuration entries is shown below:
  </p>
<pre id="2_services_add_config">
% proplist format with cloudi_service_api types
[{type, internal | external},               % inferred from module or file_path
 {prefix, cloudi:service_name_pattern()},   % default is "/"
 {module, atom() | file:filename()},        % internal service only
 {file_path, file:filename()},              % external service only
 {args, list()},                            % default is []
 {env, list({string(), string()})},         % default is []
 {dest_refresh, <a href="#1_Intro_dest">dest_refresh()</a>},            % default is immediate_closest
 {protocol, default | local | tcp | udp},   % default is local
 {buffer_size, default | pos_integer()},    % default is 65536 bytes
 {timeout_init, 101..4294967195},           % default is 5000 milliseconds
 {timeout_async, 499..4294967295},          % default is 5000 milliseconds
 {timeout_sync, 499..4294967295},           % default is 5000 milliseconds
 {dest_list_deny, dest_list()},             % default is undefined
 {dest_list_allow, dest_list()},            % default is undefined
 {count_process, pos_integer() | float()},  % default is 1
 {count_thread, pos_integer() | float()},   % default is 1
 {max_r, non_neg_integer()},                % default is 5
 {max_t, seconds()},                        % default is 300 seconds
 {options, <a href="#2_services_add_config_opts">service_options_internal()</a> |     % default is []
           <a href="#2_services_add_config_opts">service_options_external()</a>}]

% internal service tuple format
{internal,
 (ServiceNamePrefix),
 (ErlangModuleName),
 (ModuleInitializationList),
 (<a href="#1_Intro_dest">DestinationRefreshMethod</a>),
 (InitializationTimeout in milliseconds),
 (DefaultAsynchronousTimeout in milliseconds),
 (DefaultSynchronousTimeout in milliseconds),
 (DestinationDenyACL),
 (DestinationAllowACL),
 (ProcessCount),
 (MaxR),
 (MaxT in seconds),
 (<a href="#2_services_add_config_opts">ServiceOptionsPropList</a>)}

% external service tuple format
{external,
 (ServiceNamePrefix),
 (ExecutableFilePath),
 (ExecutableCommandLineArguments),
 (ExecutableEnvironmentalVariables),
 (<a href="#1_Intro_dest">DestinationRefreshMethod</a>),
 (Protocol, use 'default'),
 (ProtocolBufferSize, use 'default'),
 (InitializationTimeout in milliseconds),
 (DefaultAsynchronousTimeout in milliseconds),
 (DefaultSynchronousTimeout in milliseconds),
 (DestinationDenyACL),
 (DestinationAllowACL),
 (ProcessCount),
 (ThreadCount),
 (MaxR),
 (MaxT in seconds),
 (<a href="#2_services_add_config_opts">ServiceOptionsPropList</a>)}
</pre>
  <p class="paragraph">
    The ACL lists contain either atoms that reference the current ACL
    configuration or pattern strings.  
    The ProcessCount and ThreadCount can be specified as integers for an
    exact count or as a floating point number to provide a CPU multiplier
    (X &lt; 1.0 is round, X &gt; 1.0 is floor).  MaxR is the maximum
    restarts allowed within MaxT seconds (same parameters used by Erlang
    supervisors).  The ServiceOptionsPropList provides the configurable
    defaults:
  </p>
  <p class="paragraph">
    Timeout configuration values in milliseconds may be
    provided as 'limit_min' or 'limit_max' to use the extreme values
    (be careful, since 'limit_max' is the equivalent of 49.7 days and
     no one wants to wait 49.7 days to discover a failure).  This is possible
    with the configuration values timeout_init, timeout_async, timeout_sync
    and the service configuration options values
    request_timeout_immediate_max, response_timeout_immediate_max,
    timeout_terminate, restart_delay, monkey_latency .
  </p>
  <table id="2_services_add_config_opts"><tr><th>
    Option
  </th><th>
    Default
  </th><th>
    Details
  </th></tr><tr><td>
    priority_default
  </td><td>
    0
  </td><td>
    -128(high) &le; priority &le; 127(low)
  </td></tr><tr><td>
    queue_limit
  </td><td>
    undefined
  </td><td>
    A limit on the total number of incoming service requests that
    are queued while the service is busy (limits memory consumption).
  </td></tr><tr><td>
    queue_size
  </td><td>
    undefined
  </td><td>
    A limit on the total memory consumption of incoming service requests that
    are queued while the service is busy (in kilobytes).
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_rate_request_max">
    rate_request_max
    </a>
  </td><td>
    undefined
  </td><td>
    A limit on the incoming service request rate (in requests per second).
    When set to a list ([])
    <a href="#2_services_add_config_opts_rate_request_max">
    options can be provided</a> or it can be set to a number value.
  </td></tr><tr><td>
    dest_refresh_start
  </td><td>
    500
  </td><td>
    Delay after startup (in milliseconds) before requesting the initial
    service group membership (when using a lazy destination refresh method).
  </td></tr><tr><td>
    dest_refresh_delay
  </td><td>
    300000
  </td><td>
    Maximum possible time (in milliseconds) for a service death to remove
    service group membership (when using a lazy destination refresh method).
  </td></tr><tr><td>
    request_name_lookup
  </td><td>
    sync
  </td><td>
    Specify whether the service name lookup is sync or async during the
    timeout period.
  </td></tr><tr><td>
    request_timeout_adjustment
  </td><td>
    false
  </td><td>
    Should the service request handler execution time decrement the
    request timeout, after the request has been handled.
  </td></tr><tr><td>
    request_timeout_immediate_max
  </td><td>
    20001
  </td><td>
    Defines the maximum timeout (in milliseconds) considered "immediate".
    A service request timeout that is greater than or equal to this value
    causes the destination to be monitored to avoid timer memory consumption
    when a destination dies.
  </td></tr><tr><td>
    response_timeout_adjustment
  </td><td>
    false
  </td><td>
    Should the service's incoming response timeout be automatically decremented
    based on the sender-side's timing (more accurate).
  </td></tr><tr><td>
    response_timeout_immediate_max
  </td><td>
    20001
  </td><td>
    Defines the maximum timeout (in milliseconds) considered "immediate".
    A service request response timeout that is greater than or equal to this
    value will send a <a href="faq.html#4_Null">null response</a>
    instead of discarding a <a href="faq.html#4_Null">null response</a> and
    relying on the sending-side's timer expiring.
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_count_process_dynamic">
    count_process_dynamic
    </a>
  </td><td>
    false
  </td><td>
    Dynamically adjust the number of processes used within the service instance
    based on the service request rate that occurs.  When set to a list ([])
    <a href="#2_services_add_config_opts_count_process_dynamic">
    options can be provided</a>.
  </td></tr><tr><td>
    fatal_exceptions
  </td><td>
    true
  </td><td>
    Uncaught exceptions should cause the service to restart instead of
    causing a <a href="faq.html#4_Null">null response</a>.
    A programming language's fatal exception types will always cause a
    service restart when this option is set to false.
  </td></tr><tr><td>
    fatal_timeout
  </td><td>
    false
  </td><td>
    A service request timeout is fatal in the service handling the service
    request.  Enabling this ensures the service request execution is
    terminating though it may impact the consistency of global state usage
    if the service is writing to global state and has a timeout during its
    execution.
  </td></tr><tr><td>
    fatal_timeout_delay
  </td><td>
    0
  </td><td>
    Provide an offset on the fatal timeout value to avoid premature
    failure of the service when the service request is handled during a time
    period close to the service request timeout value.
  </td></tr><tr><td>
    timeout_terminate
  </td><td>
    undefined
  </td><td>
    Termination timeout (in milliseconds) for all the configured service
    processes.  When the termination timeout is not set, an upper-bound is used
    to ensure that the configured service lifetime is finite when
    errors occur
    ((1000 * MaxT) / MaxR - 100, if MaxR &gt; 0 and MaxT &gt; 0).
    When MaxR is 0 the default termination timeout (not an upper-bound) is
    (1000 * MaxT) - 100, if MaxT &gt; 0, or 2000, if MaxT = 0.
    All default termination timeout values are clamped to the range [10..60000].
  </td></tr><tr><td>
    restart_all
  </td><td>
    false
  </td><td>
    Restart all processes when one process fails.
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_restart_delay">
    restart_delay
    </a>
  </td><td>
    false
  </td><td>
    Delay the restart of the service after a failure, to avoid spurious
    failures when global resources require extra time before they are used
    with a new service instance.  When set to a list ([])
    <a href="#2_services_add_config_opts_restart_delay">
    options can be provided</a>.
  </td></tr><tr><td>
    critical
  </td><td>
    false
  </td><td>
    Stop the CloudI node if the service fails by being unable to restart
    (all possible restarts (MaxR) already occurred (in MaxT seconds)).
  </td></tr><tr><td>
    scope
  </td><td>
    default
  </td><td>
    The scope (an Erlang atom) is the scope which is used for all service
    name lookups and subscriptions.  If you use a unique scope, you can
    isolate your service and reduce contention when using an immediate
    <a href="#1_Intro_dest">destination refresh method</a>.
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_monkey_latency">
    monkey_latency
    </a>
  </td><td>
    false
  </td><td>
    Add latency to all service requests and info messages for systems testing.
    If set to 'system', use the settings within the cloudi_core Erlang
    application configuration. When set to a list ([])
    <a href="#2_services_add_config_opts_monkey_latency">
    options can be provided</a>.
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_monkey_chaos">
    monkey_chaos
    </a>
  </td><td>
    false
  </td><td>
    Add instability to the service for testing systems fault tolerance.
    If set to 'system', use the settings within the cloudi_core Erlang
    application configuration.  When set to a list ([])
    <a href="#2_services_add_config_opts_monkey_chaos">
    options can be provided</a>.
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_bind">
    bind
    </a>
  </td><td>
    false
  </td><td>
    Bind execution to specific logical processors.
    Usage requires the Erlang VM was started with the <a href="https://www.erlang.org/doc/man/erl.html#+sbt" rel="noreferrer" target="_blank">+sbt</a>
    command-line argument to bind Erlang process scheduler threads to
    logical processors (e.g., +sbt db).  When set to true the logical
    processors are assigned using round-robin order.  When set to a
    <a href="#2_services_add_config_opts_bind">
    string value all logical processors are provided explicitly</a>.
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_limit">
    limit</a>
  </td><td>
    []
  </td><td>
    (external services only) A list of <a href="#2_services_add_config_opts_limit">resource limits to set</a>
    for the OS processes an external service creates.
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_owner">
    owner</a>
  </td><td>
    []
  </td><td>
    (external services only) Set the owner of any OS processes an
    external service creates.
  </td></tr><tr><td>
    nice
  </td><td>
    0
  </td><td>
    (external services only) Set the nice value of any
    OS processes an external service creates.
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_cgroup">
    cgroup</a>
  </td><td>
    undefined
  </td><td>
    (external services only) Set the cgroup membership of any
    OS processes an external service creates.
  </td></tr><tr><td>
    chroot
  </td><td>
    undefined
  </td><td>
    (external services only) Set the root directory of any
    OS processes an external service creates.
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_syscall_lock">
    syscall_lock</a>
  </td><td>
    undefined
  </td><td>
    (external services only) Set the permitted syscalls of any
    OS processes an external service creates.
  </td></tr><tr><td>
    directory
  </td><td>
    undefined
  </td><td>
    (external services only) Set the current working directory of any
    OS processes an external service creates.
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_aspects_init_after">
    aspects_init_after</a>
  </td><td>
    []
  </td><td>
    A list of
    <a href="#2_services_add_config_opts_aspects_init_after">
    Erlang functions</a> to call in-order after the
    service initialization (after an internal service has
    executed cloudi_service_init/3 or an external service has
    executed the poll function).
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_aspects_request_before">
    aspects_request_before</a>
  </td><td>
    []
  </td><td>
    A list of
    <a href="#2_services_add_config_opts_aspects_request_before">
    Erlang functions</a> to call in-order before the
    service request function executes (before an internal service has
    executed cloudi_service_handle_request/11 or an external service has
    executed the callback function).
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_aspects_request_after">
    aspects_request_after</a>
  </td><td>
    []
  </td><td>
    A list of
    <a href="#2_services_add_config_opts_aspects_request_after">
    Erlang functions</a> to call in-order after the
    service request function executes (after an internal service has
    executed cloudi_service_handle_request/11 or an external service has
    executed the callback function).
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_aspects_info_before">
    aspects_info_before</a>
  </td><td>
    []
  </td><td>
    (internal services only) A list of
    <a href="#2_services_add_config_opts_aspects_info_before">
    Erlang functions</a> to call in-order
    before the cloudi_service_handle_info/3 function executes.
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_aspects_info_after">
    aspects_info_after</a>
  </td><td>
    []
  </td><td>
    (internal services only) A list of
    <a href="#2_services_add_config_opts_aspects_info_after">
    Erlang functions</a> to call in-order
    after the cloudi_service_handle_info/3 function executes.
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_aspects_terminate_before">
    aspects_terminate_before</a>
  </td><td>
    []
  </td><td>
    A list of
    <a href="#2_services_add_config_opts_aspects_terminate_before">
    Erlang functions</a> to call in-order before the
    service termination (before an internal service has
    executed cloudi_service_terminate/2 or an external service's
    process terminates).
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_aspects_suspend_resume">
    aspects_suspend</a>
  </td><td>
    []
  </td><td>
    A list of
    <a href="#2_services_add_config_opts_aspects_suspend_resume">
    Erlang functions</a> to call in-order before the
    service is suspended.
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_aspects_suspend_resume">
    aspects_resume</a>
  </td><td>
    []
  </td><td>
    A list of
    <a href="#2_services_add_config_opts_aspects_suspend_resume">
    Erlang functions</a> to call in-order before the
    service is resumed.
  </td></tr><tr><td>
    duo_mode
  </td><td>
    false
  </td><td>
    (internal services only) Use two Erlang processes instead of one Erlang
    process, so that more incoming service throughput can be handled with
    low latency.  If duo_mode is true, cloudi_service_handle_info/3
    should contain no cloudi_service:send_sync or cloudi_service:recv_async
    function calls (cloudi_service:send_async_active or a separate Erlang
    process can be used instead).
  </td></tr><tr><td>
    <a href="#2_services_add_config_opts_hibernate">
    hibernate
    </a>
  </td><td>
    false
  </td><td>
    (internal services only) Always make the service Erlang processes hibernate
    to conserve memory by using more frequent garbage collections, if set to
    true.  When set to a list ([])
    <a href="#2_services_add_config_opts_hibernate">
    options can be provided</a>.
    Enabling hibernate may decrease overall service performance
    (the service may be less responsive with service requests taking longer
     when examining the average response time),
    though it can improve worst-case service response time
    (i.e., the maximum response time) by avoiding less frequent
    garbage collections that create larger amounts of latency.
  </td></tr><tr><td>
    reload
  </td><td>
    false
  </td><td>
    (internal services only) Automatically reload the service module or any of
    the modules within a service application when the module's beam file is
    updated on the filesystem.
  </td></tr><tr><td>
    application_name
  </td><td>
    undefined
  </td><td>
    (internal services only) Use a different name when loading an Erlang
    application and its dependencies for this internal service.
  </td></tr><tr><td>
    automatic_loading
  </td><td>
    true
  </td><td>
    Determines if external services load modules automatically or if
    internal services load their dependencies automatically
    (which includes the associated Erlang application,
    the Erlang application dependencies, module loading,
    and module compilation if necessary).
  </td></tr><tr><td>
    dispatcher_pid_options
  </td><td>
    []
  </td><td>
    <a href="https://www.erlang.org/doc/man/erlang.html#spawn_opt-2" rel="noreferrer" target="_blank">erlang:spawn_opt/2</a>
    options to control memory usage of the service dispatcher
    process (priority, fullsweep_after, min_heap_size, min_bin_vheap_size,
    max_heap_size, sensitive, message_queue_data).  The dispatcher process
    lifetime is tied to the service lifetime, making it a long-lived
    Erlang process that avoids the accumulation of memory.  The dispatcher
    process is used in internal services to execute cloudi_service_init/4 if
    duo_mode is false (otherwise the info process is used).
  </td></tr><tr><td>
    init_pid_options
  </td><td>
    []
  </td><td>
    (internal services only) <a href="https://www.erlang.org/doc/man/erlang.html#spawn_opt-2" rel="noreferrer" target="_blank">erlang:spawn_opt/2</a>
    options to control memory usage of the service dispatcher
    process used during service initialization
    (priority, fullsweep_after, min_heap_size, min_bin_vheap_size,
    max_heap_size, sensitive, message_queue_data).
  </td></tr><tr><td>
    request_pid_uses
  </td><td>
    1
  </td><td>
    (internal services only) How many service requests to handle before
    utilizing a new Erlang process for a new incoming service request.
  </td></tr><tr><td>
    request_pid_options
  </td><td>
    []
  </td><td>
    (internal services only) <a href="https://www.erlang.org/doc/man/erlang.html#spawn_opt-2" rel="noreferrer" target="_blank">erlang:spawn_opt/2</a>
    options to control memory usage of the service request handling Erlang
    process (priority, fullsweep_after, min_heap_size, min_bin_vheap_size,
    max_heap_size, sensitive, message_queue_data).
  </td></tr><tr><td>
    info_pid_uses
  </td><td>
    infinity
  </td><td>
    (internal services only) How many info messages to handle before
    utilizing a new Erlang process for a new incoming info message.  This
    Erlang process is the second process that is utilized when duo_mode is true
    (duo_mode requires that this is set to infinity).
  </td></tr><tr><td>
    info_pid_options
  </td><td>
    []
  </td><td>
    (internal services only) <a href="https://www.erlang.org/doc/man/erlang.html#spawn_opt-2" rel="noreferrer" target="_blank">erlang:spawn_opt/2</a>
    options to control memory usage of the info message handling Erlang
    process (priority, fullsweep_after, min_heap_size, min_bin_vheap_size,
    max_heap_size, sensitive, message_queue_data).
  </td></tr></table>
  <h4 id="2_services_add_config_opts_rate_request_max">rate_request_max:</h4>
  <table><tr><th>
    Option
  </th><th>
    Default
  </th><th>
    Details
  </th></tr><tr><td>
    period
  </td><td>
    5
  </td><td>
    Time period (in seconds) for determining the current rate of
    service requests.
  </td></tr><tr><td>
    value
  </td><td>
    1000
  </td><td>
    Maximum requests per second.  If the current rate of service requests
    exceeds this limit the service process discards later service requests
    for the time remaining during the current time period.
  </td></tr></table>
  <h4 id="2_services_add_config_opts_count_process_dynamic">count_process_dynamic:</h4>
  <table><tr><th>
    Option
  </th><th>
    Default
  </th><th>
    Details
  </th></tr><tr><td>
    period
  </td><td>
    5
  </td><td>
    Time period (in seconds) for determining the current rate of
    service requests.
  </td></tr><tr><td>
    rate_request_max
  </td><td>
    1000
  </td><td>
    Maximum requests per second.  If the current rate of service requests
    exceeds this limit the process count is increased as much as is required
    to keep the current rate of service requests under the maximum.
  </td></tr><tr><td>
    rate_request_min
  </td><td>
    100
  </td><td>
    Minimum requests per second.  If the current rate of service requests
    is lower than this limit the process count is decreased as much as is
    required to keep the current rate of service requests above the minimum.
  </td></tr><tr><td>
    count_max
  </td><td>
    4.0
  </td><td>
    The maximum process count value that can be used for this service.
    An integer provides an absolute number while a floating point number is
    used as a CPU multiplier (in the same way as ProcessCount).
  </td></tr><tr><td>
    count_min
  </td><td>
    0.5
  </td><td>
    The minimum process count value that can be used for this service.
    An integer provides an absolute number while a floating point number is
    used as a CPU multiplier (in the same way as ProcessCount).
  </td></tr></table>
  <h4 id="2_services_add_config_opts_restart_delay">restart_delay:</h4>
  <table><tr><th>
    Option
  </th><th>
    Default
  </th><th>
    Details
  </th></tr><tr><td>
    time_exponential_min
  </td><td>
    1
  </td><td>
    The first delay (in milliseconds) used during a restart with other
    delays increasing exponentially (using a base of 2 to provide
    binary exponential backoff).
  </td></tr><tr><td>
    time_exponential_max
  </td><td>
    500
  </td><td>
    A maximum (in milliseconds) for the exponential growth of the delay
    during a restart.
  </td></tr><tr><td>
    time_linear_min
  </td><td>
    undefined
  </td><td>
    A minimum delay (in milliseconds) used during a restart with other
    delays increasing linearly (using the time_linear_slope setting).
  </td></tr><tr><td>
    time_linear_max
  </td><td>
    undefined
  </td><td>
    A maximum (in milliseconds) for the linear growth of the delay
    during a restart.
  </td></tr><tr><td>
    time_linear_slope
  </td><td>
    undefined
  </td><td>
    The delay increase (in milliseconds) to be used for each restart with
    the 0-based restart count (i.e., the first restart will limited to the
    time_linear_min setting).
  </td></tr><tr><td>
    time_absolute
  </td><td>
    undefined
  </td><td>
    A single delay (in milliseconds) will be used for each restart and
    the delay will not change based on the restart count.
  </td></tr></table>
  <h4 id="2_services_add_config_opts_monkey_latency">monkey_latency:</h4>
  <table><tr><th>
    Option
  </th><th>
    Default
  </th><th>
    Details
  </th></tr><tr><td>
    time_uniform_min
  </td><td>
    undefined
  </td><td>
    Minimum amount of latency (in milliseconds) to be applied from a
    uniform distribution of random values.
  </td></tr><tr><td>
    time_uniform_max
  </td><td>
    undefined
  </td><td>
    Maximum amount of latency (in milliseconds) to be applied from a
    uniform distribution of random values.
  </td></tr><tr><td>
    time_gaussian_mean
  </td><td>
    undefined
  </td><td>
    Average amount of latency (in milliseconds) to be applied from a
    gaussian distribution of random values.
  </td></tr><tr><td>
    time_gaussian_stddev
  </td><td>
    undefined
  </td><td>
    Standard deviation of the gaussian distribution
    used for random latency values.
  </td></tr><tr><td>
    time_absolute
  </td><td>
    5000
  </td><td>
    Use a single value (in milliseconds) for the amount of latency.
  </td></tr></table>
  <h4 id="2_services_add_config_opts_monkey_chaos">monkey_chaos:</h4>
  <table><tr><th>
    Option
  </th><th>
    Default
  </th><th>
    Details
  </th></tr><tr><td>
    probability_request
  </td><td>
    1.0
  </td><td>
    The probability a service request or info message will
    terminate a service process (50% == 0.5).
  </td></tr><tr><td>
    probability_day
  </td><td>
    undefined
  </td><td>
    The probability that a service process will be terminated at a random
    point during the day.
  </td></tr></table>
  <h4 id="2_services_add_config_opts_bind">bind:</h4>
  <p class="paragraph">
    If a string value is provided all logical processors are assigned
    explicitly based on the string contents.  The string may contain
    comma delimited non-negative integers with hyphens for integer ranges.
    All internal service processes and external service threads need
    exactly one logical processor specified.
    For example, the string value "1,13,3,15,5,17,7,19,9,21" could be used
    with an internal service that has 10 processes or an external service
    that has 10 total threads.  To understand what logical processors are
    available, check the result of the Erlang function <a href="https://www.erlang.org/doc/man/erlang.html#system_info_cpu_topology" rel="noreferrer" target="_blank">erlang:system_info(cpu_topology)</a>.
  </p>
  <p class="paragraph">
    The bind service configuration option support depends on programming
    language support of bind functionality.  That means bind use currently
    is supported by the ATS, C/C++, Erlang and Python/C CloudI APIs.
    Using the bind service configuration option should be preferred instead of
    using the <a href="api.html#2_services_add_config_opts_cgroup">cgroup</a>
    service configuration option with "cpuset.cpus" because bind has
    cross-platform support with less CloudI execution user privileges required.
  </p>
  <h4 id="2_services_add_config_opts_limit">limit:</h4>
  <p class="paragraph">
    The value for any option can be an integer or 'infinity' to set the
    current limit or a list to set both the current and the maximum
    (setting the maximum requires that the user executing CloudI
     has permission to set the maximum limit)
    (e.g., {limit, [{stack, [{current, 8388608}, {maximum, infinity}]}]}).
  </p>
  <table><tr><th>
    Option
  </th><th>
    Details
  </th></tr><tr><td>
    as
  </td><td>
    The maximum size allowed for an OS process' virtual memory (address space)
    in bytes (total available memory).
  </td></tr><tr><td>
    core
  </td><td>
    The size allowed for generating a core dump file in bytes from an
    OS process that crashes.
  </td></tr><tr><td>
    cpu
  </td><td>
    An absolute CPU time limit in seconds for an OS process.
  </td></tr><tr><td>
    data
  </td><td>
    The maximum size allowed for an OS process' data segment (initialized data,
    uninitialized data and heap data) in bytes.
  </td></tr><tr><td>
    fsize
  </td><td>
    The maximum size allowed for any file that the OS process may use
    in bytes.
  </td></tr><tr><td>
    memlock
  </td><td>
    The maximum size allowed for an OS process to lock into RAM in bytes.
  </td></tr><tr><td>
    msgqueue
  </td><td>
    The maximum size allowed for an OS process to allocate for POSIX
    message queues is bytes.
  </td></tr><tr><td>
    nice
  </td><td>
    A ceiling on an OS process' nice value (20 - ceiling == value where
    -20 &le; ceiling &le; 20).
  </td></tr><tr><td>
    nofile
  </td><td>
    A value one greater than the maximum number of file descriptors the OS
    process may use.
  </td></tr><tr><td>
    nproc
  </td><td>
    The maximum number of OS processes that may be created by the OS process.
  </td></tr><tr><td>
    rss
  </td><td>
    The maximum size of the OS process' resident set (the number of
    virtual pages resident in RAM) in pages.
  </td></tr><tr><td>
    rtprio
  </td><td>
    A ceiling on an OS process' real-time priority setting.
  </td></tr><tr><td>
    rttime
  </td><td>
    An absolute CPU time limit to consume without making a blocking system call
    in microseconds for an OS process.
  </td></tr><tr><td>
    sigpending
  </td><td>
    The maximum number of signals that may be queued by the OS process.
  </td></tr><tr><td>
    stack
  </td><td>
    The maximum size of an OS process' stack in bytes.
  </td></tr><tr><td>
    vmem
  </td><td>
    The maximum size of an OS process' mapped address space in bytes.
  </td></tr></table>
  <p class="paragraph">
    (see your OS manpage for setrlimit to check availability)
  </p>
  <h4 id="2_services_add_config_opts_owner">owner:</h4>
  <p class="paragraph">
    Set the owner of an external service's OS processes.
  </p>
  <table><tr><th>
    Option
  </th><th>
    Details
  </th></tr><tr><td>
    user
  </td><td>
    Set the user as either a positive integer user id or a string username.
    If a group is not specified in the owner service configuration option the
    user's group is used.
  </td></tr><tr><td>
    group
  </td><td>
    Set the group as either a positive integer group id or a string group name.
  </td></tr></table>
  <h4 id="2_services_add_config_opts_cgroup">cgroup:</h4>
  <p class="paragraph">
    Set the cgroup membership of an external service's OS processes.
  </p>
  <table><tr><th>
    Option
  </th><th>
    Default
  </th><th>
    Details
  </th></tr><tr><td>
    name
  </td><td>
    undefined
  </td><td>
    Set the cgroup name as a relative path (e.g., "group1/nested1").
  </td></tr><tr><td>
    parameters
  </td><td>
    []
  </td><td>
    Set any parameters that should be set on the cgroup before OS processes
    are added.  The parameter names are cgroups mount version-specific
    (e.g., <a href="https://github.com/torvalds/linux/blob/master/Documentation/admin-guide/cgroup-v2.rst" rel="noreferrer" target="_blank">v2</a>
     could use [{"memory.high", "64m"}]
     and <a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt" rel="noreferrer" target="_blank">v1</a>
     could use [{"memory.limit_in_bytes", "64m"}]).
  </td></tr><tr><td>
    update_or_create
  </td><td>
    true
  </td><td>
    Specify whether a cgroup should be created if it doesn't already exist.
  </td></tr></table>
  <h4 id="2_services_add_config_opts_syscall_lock">syscall_lock:</h4>
  <p class="paragraph">
    Set the syscall names that are permitted in any OS processes an external
    service creates.  All other syscalls will cause the OS process to
    exit with an uncatchable signal.
  </p>
  <table><tr><th>
    Option
  </th><th>
    Default
  </th><th>
    Details
  </th></tr><tr><td>
    type
  </td><td>
    pledge | function
  </td><td>
    Set the type of syscall names for configuration.
    The default is set based on the OS<br />
    (OpenBSD&nbsp;==&nbsp;pledge and Linux&nbsp;==&nbsp;function).
  </td></tr><tr><td>
    names
  </td><td>
    []
  </td><td>
    The syscall names are provided as a list of strings.
  </td></tr></table>
  <p class="paragraph">
    The syscalls used by a service executable can change due to:
  </p>
  <ul>
    <li>using dynamic linking</li>
    <li>using static linking</li>
    <li>an OS version change</li>
    <li>a kernel version change</li>
    <li>a libc version change</li>
  </ul>
  <p class="paragraph">
    Examples of syscall_lock names used for only C/C++ CloudI API use
    (http_req test) with comments is below:
  </p>
<pre>
% Example 1: OpenBSD 6.8
{syscall_lock,
 [{type, pledge},
  {names,
   [
    % C/C++ CloudI API use
    "stdio",
    % dynamically linked library loading
    "rpath"
   ]}]}
% Example 2: Ubuntu 20.04 Linux (5.4.0 kernel, glibc 2.31)
{syscall_lock,
 [{type, function},
  {names,
   [
    % C/C++ CloudI API use
    "execve","clock_gettime","poll","read","write","close","exit",
    "brk","mmap","munmap", % (malloc/free)
    % Linux-specific
    "exit_group",
    % dynamically linked library loading
    "arch_prctl","mprotect","access","openat","stat","fstat","pread64"
    % static linking requires
    %"arch_prctl","mprotect","uname","readlink"
   ]}]}
</pre>
  <p class="paragraph">
    Adding the syscall_lock configuration requires knowing all the
    syscalls a service may call.  To log syscall information from a
    running service, it is possible to run the service with ktrace or strace:
  </p>
<pre>
OpenBSD: /usr/bin/ktrace -t c -f /tmp/ktrace.out SERVICE
Linux:   /usr/bin/strace -o /tmp/strace.log SERVICE
</pre>
  <p class="paragraph">
    On Linux, the CloudI service configuration would have the
    file_path as "/usr/bin/strace" and the
    args as "-o /tmp/strace.log SERVICE" with SERVICE as the path
    to the external service executable.
  </p>
  <h4 id="2_services_add_config_opts_aspects_init_after">aspects_init_after:</h4>
  <p class="paragraph">
    Provide a list of functions with the type specification shown below,
    with each function as either an anonymous Erlang function or
    an Erlang tuple "{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}".
    Will not be called if initialization does not occur successfully
    (<a href="#2_services_add_config_opts_aspects_terminate_before">aspects_terminate_before</a>
     will still be called with the State as 'undefined').
  </p>
  <table><tr><th>
    Service Type
  </th><th>
    Function
  </th></tr><tr><td>
    Internal
  </td><td>
<pre class="code">
fun((Args :: list(),
     Prefix :: cloudi_service:service_name_pattern(),
     Timeout :: cloudi_service_api:timeout_milliseconds(),
     State :: any(),
     Dispatcher :: cloudi_service:dispatcher()) -&gt;
    {ok, NewState :: any()} |
    {stop, Reason :: any(), NewState :: any()}).
</pre>
  </td></tr><tr><td>
    External
  </td><td>
<pre class="code">
% the first function call has State =:= undefined
fun((CommandLine :: list(string()),
     Prefix :: cloudi:service_name_pattern(),
     Timeout :: cloudi_service_api:timeout_milliseconds(),
     State :: any()) -&gt;
    {ok, NewState :: any()} |
    {stop, Reason :: any(), NewState :: any()}).
</pre>
  </td></tr></table>
  <p class="paragraph">
    It is also possible to use the Erlang tuple
    "{{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}}" to specify an
    arity 0 function that returns an anonymous function as described above.
  </p>
  <h4 id="2_services_add_config_opts_aspects_request_before">aspects_request_before:</h4>
  <p class="paragraph">
    Provide a list of functions with the type specification shown below,
    with each function as either an anonymous Erlang function or
    an Erlang tuple "{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}".
  </p>
  <table><tr><th>
    Service Type
  </th><th>
    Function
  </th></tr><tr><td>
    Internal
  </td><td>
<pre class="code">
fun((RequestType :: cloudi_service:request_type(),
     Name :: cloudi_service:service_name(),
     Pattern :: cloudi_service:service_name_pattern(),
     RequestInfo :: cloudi_service:request_info(),
     Request :: cloudi_service:request(),
     Timeout :: cloudi_service:timeout_value_milliseconds(),
     Priority :: cloudi_service:priority(),
     TransId :: cloudi_service:trans_id(),
     Source :: cloudi_service:source(),
     State :: any(),
     Dispatcher :: cloudi_service:dispatcher()) -&gt;
    {ok, NewState :: any()} |
    {stop, Reason :: any(), NewState :: any()}).
</pre>
  </td></tr><tr><td>
    External
  </td><td>
<pre class="code">
fun((RequestType :: cloudi_service:request_type(),
     Name :: cloudi_service:service_name(),
     Pattern :: cloudi_service:service_name_pattern(),
     RequestInfo :: cloudi_service:request_info(),
     Request :: cloudi_service:request(),
     Timeout :: cloudi_service:timeout_value_milliseconds(),
     Priority :: cloudi_service:priority(),
     TransId :: cloudi_service:trans_id(),
     Source :: cloudi_service:source(),
     State :: any()) -&gt;
    {ok, NewState :: any()} |
    {stop, Reason :: any(), NewState :: any()}).
</pre>
  </td></tr></table>
  <p class="paragraph">
    It is also possible to use the Erlang tuple
    "{{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}}" to specify an
    arity 0 function that returns an anonymous function as described above.
  </p>
  <h4 id="2_services_add_config_opts_aspects_request_after">aspects_request_after:</h4>
  <p class="paragraph">
    Provide a list of functions with the type specification shown below,
    with each function as either an anonymous Erlang function or
    an Erlang tuple "{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}".
  </p>
  <table><tr><th>
    Service Type
  </th><th>
    Function
  </th></tr><tr><td>
    Internal
  </td><td>
<pre class="code">
fun((RequestType :: cloudi_service:request_type(),
     Name :: cloudi_service:service_name(),
     Pattern :: cloudi_service:service_name_pattern(),
     RequestInfo :: cloudi_service:request_info(),
     Request :: cloudi_service:request(),
     Timeout :: cloudi_service:timeout_value_milliseconds(),
     Priority :: cloudi_service:priority(),
     TransId :: cloudi_service:trans_id(),
     Source :: cloudi_service:source(),
     Result :: cloudi_service:request_result(),
     State :: any(),
     Dispatcher :: cloudi_service:dispatcher()) -&gt;
    {ok, NewState :: any()} |
    {stop, Reason :: any(), NewState :: any()}).
</pre>
  </td></tr><tr><td>
    External
  </td><td>
<pre class="code">
fun((RequestType :: cloudi_service:request_type(),
     Name :: cloudi_service:service_name(),
     Pattern :: cloudi_service:service_name_pattern(),
     RequestInfo :: cloudi_service:request_info(),
     Request :: cloudi_service:request(),
     Timeout :: cloudi_service:timeout_value_milliseconds(),
     Priority :: cloudi_service:priority(),
     TransId :: cloudi_service:trans_id(),
     Source :: cloudi_service:source(),
     Result :: cloudi_service:request_result(),
     State :: any()) -&gt;
    {ok, NewState :: any()} |
    {stop, Reason :: any(), NewState :: any()}).
</pre>
  </td></tr></table>
  <p class="paragraph">
    It is also possible to use the Erlang tuple
    "{{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}}" to specify an
    arity 0 function that returns an anonymous function as described above.
  </p>
  <h4 id="2_services_add_config_opts_aspects_info_before">aspects_info_before:</h4>
  <p class="paragraph">
    Provide a list of functions with the type specification shown below,
    with each function as either an anonymous Erlang function or
    an Erlang tuple "{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}".
  </p>
  <table><tr><th>
    Service Type
  </th><th>
    Function
  </th></tr><tr><td>
    Internal
  </td><td>
<pre class="code">
fun((Request :: any(),
     State :: any(),
     Dispatcher :: cloudi_service:dispatcher()) -&gt;
    {ok, NewState :: any()} |
    {stop, Reason :: any(), NewState :: any()}).
</pre>
  </td></tr></table>
  <p class="paragraph">
    It is also possible to use the Erlang tuple
    "{{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}}" to specify an
    arity 0 function that returns an anonymous function as described above.
  </p>
  <h4 id="2_services_add_config_opts_aspects_info_after">aspects_info_after:</h4>
  <p class="paragraph">
    Provide a list of functions with the type specification shown below,
    with each function as either an anonymous Erlang function or
    an Erlang tuple "{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}".
  </p>
  <table><tr><th>
    Service Type
  </th><th>
    Function
  </th></tr><tr><td>
    Internal
  </td><td>
<pre class="code">
fun((Request :: any(),
     State :: any(),
     Dispatcher :: cloudi_service:dispatcher()) -&gt;
    {ok, NewState :: any()} |
    {stop, Reason :: any(), NewState :: any()}).
</pre>
  </td></tr></table>
  <p class="paragraph">
    It is also possible to use the Erlang tuple
    "{{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}}" to specify an
    arity 0 function that returns an anonymous function as described above.
  </p>
  <h4 id="2_services_add_config_opts_aspects_terminate_before">aspects_terminate_before:</h4>
  <p class="paragraph">
    Provide a list of functions with the type specification shown below,
    with each function as either an anonymous Erlang function or
    an Erlang tuple "{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}".
    Will still be called if initialization does not occur successfully
    (with State as 'undefined').
  </p>
  <table><tr><th>
    Service Type
  </th><th>
    Function
  </th></tr><tr><td>
    Internal and External
  </td><td>
<pre class="code">
fun((Reason :: any(),
     Timeout :: cloudi_service_api:timeout_milliseconds(),
     State :: any()) -&gt;
    {ok, State :: any()}).
</pre>
  </td></tr></table>
  <p class="paragraph">
    It is also possible to use the Erlang tuple
    "{{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}}" to specify an
    arity 0 function that returns an anonymous function as described above.
  </p>
  <h4 id="2_services_add_config_opts_aspects_suspend_resume">aspects_suspend and aspects_resume:</h4>
  <p class="paragraph">
    Provide a list of functions with the type specification shown below,
    with each function as either an anonymous Erlang function or
    an Erlang tuple "{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}".
    Each function will be called immediately before the service becomes
    suspended or resumed.
  </p>
<pre class="code">
fun((State :: any()) -&gt;
    {ok, State :: any()}).
</pre>
  <p class="paragraph">
    It is also possible to use the Erlang tuple
    "{{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}}" to specify an
    arity 0 function that returns an anonymous function as described above.
  </p>
  <h4 id="2_services_add_config_opts_hibernate">hibernate:</h4>
  <table><tr><th>
    Option
  </th><th>
    Default
  </th><th>
    Details
  </th></tr><tr><td>
    period
  </td><td>
    5
  </td><td>
    Time period (in seconds) for determining the current rate of
    service requests.
  </td></tr><tr><td>
    rate_request_min
  </td><td>
    1
  </td><td>
    Minimum requests per second.  If the current rate of service requests
    is lower than this limit the service will hibernate.
  </td></tr></table>
  <p class="paragraph">
    Please see the configuration file <a href="https://github.com/CloudI/CloudI/blob/master/src/cloudi_tests.conf.in" rel="noopener" target="_blank">/usr/local/etc/cloudi/cloudi.conf</a>
    for more specific examples.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_services_remove">2.6 - services_remove</h3>
<p class="code">
curl -X POST -d '["6e81f0a6-7a1f-11e2-d40e-a5dd00000058", "6e81f0ec-7a1f-11e2-d40e-a5dd00000058"]' http://localhost:6464/cloudi/api/rpc/services_remove.erl
</p>
  <p class="paragraph">
    Provide the Service UUIDs for the services that should be stopped.
    The Service UUID is shown in the output of
    <a href="#2_services">services</a>.  When the service is stopped, its
    running instance is removed from CloudI, but does not impact any
    other running instances (even if they are the same service
    module or binary).
  </p>
  <p class="paragraph">
    When an internal service is removed and it is the last instance of the
    service module, the service module is purged to avoid later module
    conflicts.  All instances of the internal service module should be
    configured in the same way (either a single module, an application, or
    a release with an application), so that the last instance is removed
    completely.  If an application was used that is named the same as the
    service module, the application and its dependencies are removed
    (applications are stopped, modules are purged, and applications are
     unloaded) if the dependencies are not utilized by other applications.
    The same occurs if a release was used to start an application that
    contains the service module (the single top-level application of the
    release is used to determine dependencies, where the single top-level
    application within the release is the application that includes the
    service module).
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_services_restart">2.7 - services_restart</h3>
<p class="code">
curl -X POST -d '["6a675470-7a1f-11e2-d40e-a5dd00000058"]' http://localhost:6464/cloudi/api/rpc/services_restart.erl
</p>
  <p class="paragraph">
    Restart the services with the UUIDs provided.
    The service UUID is shown in the output of
    <a href="#2_services">services</a>.  When the service is restarted,
    the old instance is stopped and a new instance is started.  During the
    restart delay, it is possible to lose queued service requests and
    received asynchronous responses.  Keeping the state separate between
    the service instances is important to prevent failures within the new
    instance.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_services_suspend">2.8 - services_suspend</h3>
<p class="code">
curl -X POST -d '["6a675470-7a1f-11e2-d40e-a5dd00000058"]' http://localhost:6464/cloudi/api/rpc/services_suspend.erl
</p>
  <p class="paragraph">
    Suspend the services with the UUIDs provided.
    Suspended services will not process more service requests
    (internal services will also not process info messages) and will only
    keep the data queued for processing in the future
    (allowing service requests to expire based on their timeout values).
    Suspended services can be updated while they are suspended.
    If a service is already suspended, services_suspend will have no effect.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_services_resume">2.9 - services_resume</h3>
<p class="code">
curl -X POST -d '["6a675470-7a1f-11e2-d40e-a5dd00000058"]' http://localhost:6464/cloudi/api/rpc/services_resume.erl
</p>
  <p class="paragraph">
    Resume the services with the UUIDs provided.
    Resumed services will continue processing service requests
    (internal services will also process info messages).
    If a service is not suspended, services_resume will have no effect.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_services_search">2.10 - services_search</h3>
<p class="code">
curl -X POST -d '"/tests/http/text/post"' http://localhost:6464/cloudi/api/rpc/services_search.erl
</p>
<p class="code">
curl -X POST -d '{cloudi_service_test_msg_size, "/tests/msg_size/erlang"}' http://localhost:6464/cloudi/api/rpc/services_search.erl
</p>
  <p class="paragraph">
    List the service configuration parameters with each service's UUID that
    are receiving service requests for a given service name.  To search within
    a custom scope, provide both the scope and the service name within a tuple.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_services_status">2.11 - services_status</h3>
<p class="code">
curl -X POST -d '[]' http://localhost:6464/cloudi/api/rpc/services_status.erl
</p>
<p class="code">
curl -X POST -d '["65762d3262a511e882359563d34a433e"]' http://localhost:6464/cloudi/api/rpc/services_status.erl
</p>
  <p class="paragraph">
    For each service UUID, provide the current uptime, downtime, interrupt and
    availability estimates at a single point in time.
    Each service has a {UUID,&nbsp;Status} pair with the Status described below:
  </p>
<pre>
[{type, internal | external},
 {prefix, service_name_pattern()},
 {module, atom()},                             % internal service only
 {file_path, file:filename()},                 % external service only
 {count_process, pos_integer()},               % count_process_dynamic may vary
 {count_thread, pos_integer()},                % external service only
 {pids_os, list(pos_integer())},               % external service only
 {pids_erlang, list(pid())},
 {size_erlang, pos_integer()},
 {suspended, boolean()},
 {uptime_total, nonempty_string()},
 {uptime_running, nonempty_string()},
 {uptime_processing, nonempty_string()},
 {uptime_restarts, nonempty_string()},
 {downtime_day_restarting, nonempty_string()},
 {downtime_week_restarting, nonempty_string()},
 {downtime_month_restarting, nonempty_string()},
 {downtime_year_restarting, nonempty_string()},
 {outages_day_restarting, nonempty_string()},
 {outages_week_restarting, nonempty_string()},
 {outages_month_restarting, nonempty_string()},
 {outages_year_restarting, nonempty_string()},
 {interrupt_day_updating, nonempty_string()},
 {interrupt_week_updating, nonempty_string()},
 {interrupt_month_updating, nonempty_string()},
 {interrupt_year_updating, nonempty_string()},
 {interrupt_day_suspended, nonempty_string()},
 {interrupt_week_suspended, nonempty_string()},
 {interrupt_month_suspended, nonempty_string()},
 {interrupt_year_suspended, nonempty_string()},
 {availability_day_total, nonempty_string()},
 {availability_day_running, nonempty_string()},
 {availability_day_updated, nonempty_string()},
 {availability_day_processing, nonempty_string()},
 {availability_week_total, nonempty_string()},
 {availability_week_running, nonempty_string()},
 {availability_week_updated, nonempty_string()},
 {availability_week_processing, nonempty_string()},
 {availability_month_total, nonempty_string()},
 {availability_month_running, nonempty_string()},
 {availability_month_updated, nonempty_string()},
 {availability_month_processing, nonempty_string()},
 {availability_year_total, nonempty_string()},
 {availability_year_running, nonempty_string()},
 {availability_year_updated, nonempty_string()},
 {availability_year_processing, nonempty_string()}]
</pre>
  <p class="paragraph">
    The amount of time elapsed is provided in the string format
    "0&nbsp;days&nbsp;0&nbsp;hours&nbsp;0&nbsp;seconds&nbsp;0&nbsp;nanoseconds"
    (with the largest 0 durations omitted and a singular unit if 1)
    for the uptime, downtime and interrupt values in the status.
    The <strong>total</strong> time shows how long the
    service has been running, including all restarts (in uptime_total).
    The <strong>running</strong> time shows how long the last restart
    of the service has been running (in uptime_running).
    The <strong>processing</strong> time
    shows how long the service has been processing service requests
    in the currently running service processes.  The total
    number of restarts during the lifetime of the service is provided in
    uptime_restarts.
  </p>
  <p class="paragraph">
    The service downtime spent restarting service processes is provided
    for the past day, week, month and year.  The downtime elapsed due to
    restarting is measured as the time period from immediately before
    termination starts until the end of the initialization within the
    new service instance.  The downtime values are used to determine the
    total availability values (e.g.,&nbsp;availability_day_total,
    availability_week_total, availability_month_total and
    availability_year_total).
  </p>
  <p class="paragraph">
    The service outage due to restarting is shown visually as a count
    in the time period for each "outages" string value.
    The outages_day_restarting value shows a single string character for
    each 30 minute segment after 00:00 UTC.  Each restart causes an integer
    count to be updated in the string character associated with the restart
    time period.  If a restart time period crosses a string character boundary
    all associated string characters will have an integer count updated.
    If the count is above 9 for a single character it is
    represented as a X character.  The | (pipe) character is a cursor that
    shows the position of the current time in the string.  Any characters
    after the cursor are representing the previous time period.
    The outages_week_restarting value shows a single string character for
    each 4 hour segment after 00:00 UTC on Monday of the current week.
    The outages_month_restarting value shows a single string character for
    each day of the current month.
    The outages_year_restarting value shows a single string character for
    each 1/3rd of a month during the current year.
  </p>
  <p class="paragraph">
    The service interrupt spent updating service processes is provided
    for the past day, week, month and year.  The interrupt elapsed will
    always overestimate the amount of time spent updating, by including
    extra coordination delay and should be considered the total time
    spent updating all service processes.  Only the time spent updating
    the most recent service processes gets tracked as the interrupt
    (i.e., a fraction of the <strong>running</strong> time period which
    is after any restarts occurred).  The interrupt values are used to
    determine the updated availability values
    (e.g.,&nbsp;availability_day_updated, availability_week_updated,
     availability_month_updated and availability_year_updated).
  </p>
  <p class="paragraph">
    The service interrupt spent with service processes suspended is provided
    for the past day, week, month and year.  The <strong>processing</strong>
    time is the <strong>running</strong> time minus the
    updating interruptions and the suspended interruptions.
  </p>
  <p class="paragraph">
    The amount of time the service has been running since any restarts
    occurred is used to determine the running availability values
    (e.g.,&nbsp;availability_day_running, availability_week_running,
     availability_month_running and availability_year_running).
    All the availability values are percentages to describe the <a href="https://en.wikipedia.org/wiki/High_availability#Percentage_calculation" rel="noreferrer" target="_blank">fraction of estimated uptime during each time period</a>.
    All status data is determined using the same point in time, so the values
    may be compared among separate services.
  </p>
  <p class="paragraph">
    The currently executing Erlang processes for each service are provided
    in pids_erlang.  These Erlang processes that represent the service are the
    source pids provided when handling a CloudI service request.
    The current external service OS pids are provided in pids_os.
    Both lists are ordered by process index and may be smaller
    than expected (based on count_process and count_thread) if the service
    is not initialized.
  </p>
  <p class="paragraph">
    The size_erlang value provides the size of the service within the Erlang VM
    as the size of all the pids_erlang Erlang processes in bytes.
    The size_erlang value represents the memory used for the most critical
    parts of a CloudI service in the Erlang VM related to receiving CloudI
    service requests and responses (i.e., the source pids).
    For internal services the size_erlang value will not include the size
    of the info_pid or the request_pid if the duo_mode service configuration
    option is false (the default value).  If an internal service has the
    duo_mode service configuration option set to true, the size_erlang value
    will not include the size of the dispatcher_pid or the request_pid.
    That means the size_erlang value always represents the long-lived
    CloudI service memory in the Erlang VM.
  </p>
  <p class="paragraph">
    Example output is available at<br />
    <a href="https://cloudi.org/config.html#services_status">https://cloudi.org/config.html#services_status</a>.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_services_update">2.12 - services_update</h3>
<p class="code">
curl -X POST -d '[{"", [{module, cloudi_service_test_messaging}, {modules_load, [cloudi_service_test_messaging]}, {sync, false}]}]' http://localhost:6464/cloudi/api/rpc/services_update.erl
</p>
  <p class="paragraph">
    Update services while they are running without any interruption in
    their operation.  Each update that should occur is specified as a
    {UUID,&nbsp;Options} pair with the Options described below:
  </p>
<pre>
% internal service update options
[{type, internal},
 {module, atom()},                            % only required field
 {module_state, module_state_internal()},     % update service state
 {sync, boolean()},                           % defaults to true
 {modules_load, list(atom())},                % defaults to []
 {modules_unload, list(atom())},              % defaults to []
 {code_paths_add, list(string())},            % defaults to []
 {code_paths_remove, list(string())},         % defaults to []
 {dest_refresh, dest_refresh()},              % update service configuration
 {timeout_init, timeout_milliseconds()},      % update service configuration
 {timeout_async, timeout_milliseconds()},     % update service configuration
 {timeout_sync, timeout_milliseconds()},      % update service configuration
 {dest_list_deny, dest_list()},               % update service configuration
 {dest_list_allow, dest_list()},              % update service configuration
 {options, <a href="#2_services_update_config_opts_internal">service_update_plan_options_internal()</a>}] % update service configuration options
</pre>
  <p class="paragraph">
    Internal service updates require a module field provide the service
    module name.  If the module is used in more than one service instance,
    provide the service UUID as "" to ensure the update applies to all
    service instances that use the module.  If the module needs to be
    reloaded, it must be added to the modules_load list and the new
    module will be loaded using Erlang hot-code loading during the update.
    If the service state needs to be modified during the update, a function
    can be provided in the module_state field.
  </p>
  <p class="paragraph">
    The module_state value for an internal service update can be provided as
    an anonymous Erlang function or an Erlang tuple
    "{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}" with the types below:
  </p>
<pre class="code">
fun((OldModuleVersion :: list(any()),
     NewModuleVersion :: list(any()),
     OldState :: any()) -&gt;
    {ok, NewState :: any()} |
    {error, Reason :: any()}).
</pre>
  <p class="paragraph">
    It is also possible to use the Erlang tuple
    "{{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}}" to specify an
    arity 0 function that returns an anonymous function as described above.
    Providing the module version before and after the module update can
    help guide any upgrade or downgrade logic to return the appropriate
    state data.  If the module_state function returns an error (or any
    other problem occurs during the update), the update does not change
    any service state, though the module and code_path modifications
    take effect after the update has been processed
    (i.e., modules_load, modules_unload, code_paths_add, code_paths_remove,
     all occur even when an update fails).
  </p>
  <p class="paragraph">
    External service updates require either the type be set to external or
    that the file_path, args, or env field be set (to cause the OS process
    of the external service to restart during the update).
  </p>
<pre>
% external service update options
[{type, external},
 {file_path, string()},                       % restarts OS process
 {args, string()},                            % restarts OS process
 {env, list({string(), string()})},           % restarts OS process
 {sync, boolean()},                           % defaults to true
 {modules_load, list(atom())},                % defaults to []
 {modules_unload, list(atom())},              % defaults to []
 {code_paths_add, list(string())},            % defaults to []
 {code_paths_remove, list(string())},         % defaults to []
 {dest_refresh, dest_refresh()},              % update service configuration
 {timeout_init, timeout_milliseconds()},      % update service configuration
 {timeout_async, timeout_milliseconds()},     % update service configuration
 {timeout_sync, timeout_milliseconds()},      % update service configuration
 {dest_list_deny, dest_list()},               % update service configuration
 {dest_list_allow, dest_list()},              % update service configuration
 {options, <a href="#2_services_update_config_opts_external">service_update_plan_options_external()</a>}] % update service configuration options
</pre>
  <p class="paragraph">
    The sync field is used to determine whether the update occurs while
    no service processes are processing a service request.  If global state
    is being used while handling a service request, it is safest to have sync
    set to true, which is the default.  If a service sends synchronous
    service requests to itself, the update can timeout when sync is set to
    true but can succeed with sync set to false.
  </p>
  <p class="paragraph">
    Do not set the sync field to false unless the service update requires it
    (due to the service having a cyclic dependency on itself,
     as described above).  If an internal service update has the sync field
    set to false and the service's module is present in the modules_load
    list, the service's request process may use the new module prematurely
    if the request process is spawned slower than the module load
    (or if it calls any exported functions within the module) and
    that would occur before the module_state function gets called.
  </p>
  <p class="paragraph">
    A subset of the service configuration options can be updated:
  </p>
<pre id="2_services_update_config_opts_internal">
% internal service configuration options that are updatable
[{priority_default, priority()} |
 {queue_limit, undefined | non_neg_integer()} |
 {queue_size, undefined | pos_integer()} |
 {rate_request_max,
  list({period, period_seconds()} |
       {value, number()}) | number() | undefined} |
 {dest_refresh_start, dest_refresh_delay_milliseconds()} |
 {dest_refresh_delay, dest_refresh_delay_milliseconds()} |
 {request_name_lookup, sync | async} |
 {request_timeout_adjustment, boolean()} |
 {request_timeout_immediate_max,
  request_timeout_immediate_max_milliseconds()} |
 {response_timeout_adjustment, boolean()} |
 {response_timeout_immediate_max,
  response_timeout_immediate_max_milliseconds()} |
 {monkey_latency,
  list({time_uniform_min, latency_time_milliseconds()} |
       {time_uniform_max, latency_time_milliseconds()} |
       {time_gaussian_mean, latency_time_milliseconds()} |
       {time_gaussian_stddev, float()} |
       {time_absolute, latency_time_milliseconds()}) | system | false} |
 {monkey_chaos,
  list({probability_request, float()} |
       {probability_day, float()}) | system | false} |
 {dispatcher_pid_options,
  list({priority, low | normal | high} |
       {fullsweep_after, non_neg_integer()} |
       {min_heap_size, non_neg_integer()} |
       {min_bin_vheap_size, non_neg_integer()} |
       {max_heap_size, non_neg_integer() |
                       #{size =&gt; non_neg_integer(),
                         kill =&gt; boolean(),
                         error_logger =&gt; boolean()}} |
       {sensitive, boolean()} |
       {message_queue_data, off_heap | on_heap})} |
 {aspects_init_after, list(aspect_init_after_internal())} |
 {aspects_request_before, list(aspect_request_before_internal())} |
 {aspects_request_after, list(aspect_request_after_internal())} |
 {aspects_info_before, list(aspect_info_before_internal())} |
 {aspects_info_after, list(aspect_info_after_internal())} |
 {aspects_terminate_before, list(aspect_terminate_before_internal())} |
 {aspects_suspend, list(aspect_suspend())} |
 {aspects_resume, list(aspect_resume())} |
 {init_pid_options,
  list({priority, low | normal | high} |
       {fullsweep_after, non_neg_integer()} |
       {min_heap_size, non_neg_integer()} |
       {min_bin_vheap_size, non_neg_integer()} |
       {max_heap_size, non_neg_integer() |
                       #{size =&gt; non_neg_integer(),
                         kill =&gt; boolean(),
                         error_logger =&gt; boolean()}} |
       {sensitive, boolean()} |
       {message_queue_data, off_heap | on_heap})} |
 {request_pid_uses, infinity | pos_integer()} |
 {request_pid_options,
  list({priority, low | normal | high} |
       {fullsweep_after, non_neg_integer()} |
       {min_heap_size, non_neg_integer()} |
       {min_bin_vheap_size, non_neg_integer()} |
       {max_heap_size, non_neg_integer() |
                       #{size =&gt; non_neg_integer(),
                         kill =&gt; boolean(),
                         error_logger =&gt; boolean()}} |
       {sensitive, boolean()} |
       {message_queue_data, off_heap | on_heap})} |
 {info_pid_uses, infinity | pos_integer()} |
 {info_pid_options,
  list({priority, low | normal | high} |
       {fullsweep_after, non_neg_integer()} |
       {min_heap_size, non_neg_integer()} |
       {min_bin_vheap_size, non_neg_integer()} |
       {max_heap_size, non_neg_integer() |
                       #{size =&gt; non_neg_integer(),
                         kill =&gt; boolean(),
                         error_logger =&gt; boolean()}} |
       {sensitive, boolean()} |
       {message_queue_data, off_heap | on_heap})} |
 {hibernate,
  list({period, period_seconds()} |
       {rate_request_min, number()}) | boolean()} |
 {reload, boolean()}]
</pre>
<pre id="2_services_update_config_opts_external">
% external service configuration options that are updatable
[{priority_default, ?PRIORITY_HIGH..?PRIORITY_LOW} |
 {queue_limit, undefined | non_neg_integer()} |
 {queue_size, undefined | pos_integer()} |
 {rate_request_max,
  list({period, period_seconds()} |
       {value, number()}) | number() | undefined} |
 {dest_refresh_start, dest_refresh_delay_milliseconds()} |
 {dest_refresh_delay, dest_refresh_delay_milliseconds()} |
 {request_name_lookup, sync | async} |
 {request_timeout_adjustment, boolean()} |
 {request_timeout_immediate_max,
  request_timeout_immediate_max_milliseconds()} |
 {response_timeout_adjustment, boolean()} |
 {response_timeout_immediate_max,
  response_timeout_immediate_max_milliseconds()} |
 {monkey_latency,
  list({time_uniform_min, latency_time_milliseconds()} |
       {time_uniform_max, latency_time_milliseconds()} |
       {time_gaussian_mean, latency_time_milliseconds()} |
       {time_gaussian_stddev, float()} |
       {time_absolute, latency_time_milliseconds()}) | system | false} |
 {monkey_chaos,
  list({probability_request, float()} |
       {probability_day, float()}) | system | false} |
 {dispatcher_pid_options,
  list({priority, low | normal | high} |
       {fullsweep_after, non_neg_integer()} |
       {min_heap_size, non_neg_integer()} |
       {min_bin_vheap_size, non_neg_integer()} |
       {max_heap_size, non_neg_integer() |
                       #{size =&gt; non_neg_integer(),
                         kill =&gt; boolean(),
                         error_logger =&gt; boolean()}} |
       {sensitive, boolean()} |
       {message_queue_data, off_heap | on_heap})} |
 {aspects_init_after, list(aspect_init_after_external())} |
 {aspects_request_before, list(aspect_request_before_external())} |
 {aspects_request_after, list(aspect_request_after_external())} |
 {aspects_terminate_before, list(aspect_terminate_before_external())} |
 {aspects_suspend, list(aspect_suspend())} |
 {aspects_resume, list(aspect_resume())}]
</pre>
  <p class="paragraph">
    For more information about a specific service configuration option
    refer to the <a href="#2_services_add_config_opts">service configuration documentation</a>.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_services">2.13 - services</h3>
<p class="code">
curl http://localhost:6464/cloudi/api/rpc/services.erl
</p>
  <p class="paragraph">
    List the service configuration parameters with each service's UUID.
    Any default service configuration options are omitted to keep the
    output concise.  The service tuple format is provided in the output
    after any defaults have been assigned, as described in
    <a href="#2_services_add">services_add</a>.
  </p>
<pre>
% service tuple format list
[{UUID,
  {internal,
   Prefix :: service_name_pattern(),
   Module :: atom(),
   Args :: list(),
   DestRefresh :: <a href="#1_Intro_dest">dest_refresh()</a>,
   TimeoutInit :: timeout_initialize_milliseconds(),
   TimeoutAsync :: timeout_send_async_milliseconds(),
   TimeoutSync :: timeout_send_sync_milliseconds(),
   DestListDeny :: dest_list(),
   DestListAllow :: dest_list(),
   CountProcess :: pos_integer(),
   MaxR :: non_neg_integer(),
   MaxT :: seconds(),
   Options :: <a href="#2_services_add_config_opts">service_options_internal()</a>} |
  {external,
   Prefix :: service_name_pattern(),
   FilePath :: file:filename(),
   Args :: string(),
   Env :: list({string(), string()}),
   DestRefresh :: <a href="#1_Intro_dest">dest_refresh()</a>,
   Protocol :: local | tcp | udp,
   BufferSize :: pos_integer(),
   TimeoutInit :: timeout_initialize_milliseconds(),
   TimeoutAsync :: timeout_send_async_milliseconds(),
   TimeoutSync :: timeout_send_sync_milliseconds(),
   DestListDeny :: dest_list(),
   DestListAllow :: dest_list(),
   CountProcess :: pos_integer(),
   CountThread :: pos_integer(),
   MaxR :: non_neg_integer(),
   MaxT :: seconds(),
   Options :: <a href="#2_services_add_config_opts">service_options_external()</a>}}]
</pre>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_nodes_set">2.14 - nodes_set</h3>
<p class="code">
curl -X POST -d "[{reconnect_delay, 300}]" http://localhost:6464/cloudi/api/rpc/nodes_set.erl
</p>
  <p class="paragraph">
    Set the node configuration to specify how CloudI node
    connections are handled (using distributed Erlang).
  </p>
  <table id="2_nodes_set_config"><tr><th>
    Option
  </th><th>
    Default
  </th><th>
    Details
  </th></tr><tr><td>
    set
  </td><td>
    all
  </td><td>
    Whether the settings should be set on 'all' nodes or only the 'local' node.
  </td></tr><tr><td>
    nodes
  </td><td>
    []
  </td><td>
    Exact node names for distributed Erlang connections
  </td></tr><tr><td>
    reconnect_start
  </td><td>
    300
  </td><td>
    The delay (in seconds) before attempting to connect to any
    distributed Erlang nodes, for the first time.
  </td></tr><tr><td>
    reconnect_delay
  </td><td>
    60
  </td><td>
    The delay (in seconds) before attempting to reconnect to any
    distributed Erlang nodes.
  </td></tr><tr><td>
    listen
  </td><td>
    visible
  </td><td>
    What distributed Erlang node connections should be monitored:
    'visible' or 'all' (to include hidden nodes).
    If it is not set, it is inferred from connect.
  </td></tr><tr><td>
    connect
  </td><td>
    visible
  </td><td>
    What distributed Erlang node connections to create:
    'visible' or 'hidden'
    (single link, not part of a fully connected network topology)
  </td></tr><tr><td>
    timestamp_type
  </td><td>
    erlang
  </td><td>
    What timestamp to use for generating unique service request
    transaction ids:
    'erlang' (strictly monotonically increasing time),
    'os' (OS time, weakest ordering possible)
    or 'warp' (time adjusted gradually)
  </td></tr><tr><td>
    <a href="#2_nodes_set_config_discovery">
    discovery</a>
  </td><td>
    undefined
  </td><td>
    Distributed Erlang node auto-discovery mechanism configuration.
  </td></tr><tr><td>
    cost
  </td><td>
    []
  </td><td>
    A list of node-cost pairs.  A default cost may be provided by using
    'default' as the node name (e.g., [{default, 0.02225}]).  The node cost
    is the amount of currency per hour (for tracking electricity costs
    it is: average kilowatts * currency per kilowatt-hour (kWh)).
  </td></tr><tr><td>
    cost_precision
  </td><td>
    2
  </td><td>
    Cost currency decimal places.
  </td></tr><tr><td>
    log_reconnect
  </td><td>
    info
  </td><td>
    The loglevel used to log the currently disconnected nodes before a
    reconnect attempt occurs.
  </td></tr></table>
  <h4 id="2_nodes_set_config_discovery">discovery:</h4>
  <table><tr><th>
    Option
  </th><th>
    Default
  </th><th>
    Details
  </th></tr><tr><td>
    <a href="#2_nodes_set_config_discovery_multicast">
    multicast</a>
  </td><td>
    []
  </td><td>
    LAN multicast distributed Erlang node auto-discovery configuration.
  </td></tr><tr><td>
    <a href="#2_nodes_set_config_discovery_ec2">
    ec2</a>
  </td><td>
    []
  </td><td>
    Amazon Web Services (AWS) EC2 distributed Erlang node auto-discovery
    configuration (auto-discovery within a single region).
    Requires custom configuration that provides
    <a href="#2_nodes_set_config_discovery_ec2">EC2 access credentials</a>.
  </td></tr></table>
  <h4 id="2_nodes_set_config_discovery_multicast">multicast:</h4>
  <table><tr><th>
    Option
  </th><th>
    Default
  </th><th>
    Details
  </th></tr><tr><td>
    interface
  </td><td>
    {0,0,0,0}
  </td><td>
    The interface address (for UDP).
  </td></tr><tr><td>
    address
  </td><td>
    {224,0,0,1}
  </td><td>
    The LAN multicast address (for UDP).
  </td></tr><tr><td>
    port
  </td><td>
    4475
  </td><td>
    The multicast port (for UDP).
  </td></tr><tr><td>
    ttl
  </td><td>
    1
  </td><td>
    The multicast TTL
    (<a href="https://www.rfc-editor.org/rfc/rfc2730.txt" rel="noreferrer" target="_blank">RFC</a>, <a href="https://tldp.org/HOWTO/Multicast-HOWTO-2.html#ss2.3" rel="noreferrer" target="_blank">Linux</a>).
  </td></tr></table>
  <p class="paragraph">
    LAN multicast auto-discovery requires that ntpd is running to keep
    the time of all LAN nodes as close as possible.  However, all CloudI nodes
    should have ntpd running to keep all transaction ids similar
    (even if LAN multicast auto-discovery is not used).
  </p>
  <h4 id="2_nodes_set_config_discovery_ec2">ec2:</h4>
  <table><tr><th>
    Option
  </th><th>
    Default
  </th><th>
    Details
  </th></tr><tr><td>
    access_key_id
  </td><td>
    undefined
  </td><td>
    AWS Access Key ID as a string (e.g.&nbsp;"${AWS_ACCESS_KEY_ID}").
  </td></tr><tr><td>
    secret_access_key
  </td><td>
    undefined
  </td><td>
    AWS Secret Access Key as a string (e.g.&nbsp;"${AWS_SECRET_ACCESS_KEY}").
  </td></tr><tr><td>
    host
  </td><td>
    "ec2.amazonaws.com"
  </td><td>
    AWS EC2 API <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region" rel="noreferrer" target="_blank">endpoint</a>
    (e.g.,&nbsp;"ec2.${AWS_DEFAULT_REGION}.amazonaws.com").
  </td></tr><tr><td>
    groups
  </td><td>
    []
  </td><td>
    EC2 security groups selection to limit the instances selected
    during EC2 distributed Erlang node auto-discovery.
  </td></tr><tr><td>
    tags
  </td><td>
    []
  </td><td>
    EC2 tags selection to limit the instances selected
    during EC2 distributed Erlang node auto-discovery.
  </td></tr></table>
  <p class="paragraph">
    EC2 auto-discovery configuration requires setting
    'access_key_id' and 'secret_access_key' with either
    'groups' and/or 'tags'.  Both 'groups' and 'tags' allow boolean expressions
    with nesting (specified as a list), e.g.:
  </p>
<pre>
[TAG | GROUP | OPERATOR]                 % implicitly an OR relationship
{'OR', [TAG | GROUP | OPERATOR]}         % OR boolean OPERATOR
{'AND', [TAG | GROUP | OPERATOR]}        % AND boolean OPERATOR

"security-group-name"                    % GROUP

"key1" | ["key3", "key4"]                % TAG (key names)

{"key2", "value2"} |                     % TAG (key/value combinations)
{["key5", "key6"], "value5"} |           %
{"key5", ["value5", "value6"]} |         %
{["key5", "key6"], ["value5", "value6"]} %

% groups example #1 (implicit OR relationship):
["security-group-a", "security-group-b"]

% groups example #2 (explicit AND relationship):
[{'AND', ["security-group-a", "security-group-b"]}]

% groups example #3 (explicit OR relationship, same functionally as #1):
[{'OR', ["security-group-a", "security-group-b"]}]

% tags example
[{'AND', [{"deployment", "development"}, {"cluster", "project42"}]}]
</pre>
  <p class="paragraph">
    The EC2 auto-discovery requires that the security group(s) used
    by the instances expose distributed Erlang ports (with TCP rules):
  </p>
  <ul>
    <li>port 4369 (epmd) <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html" rel="noreferrer" target="_blank">10.0.0.0/8</a></li>
    <li>ports 4374-4474 (inet_dist_listen) <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html" rel="noreferrer" target="_blank">10.0.0.0/8</a></li>
  </ul>
  <p class="paragraph">
    The EC2 auto-discovery needs distributed Erlang longnames usage
    so -name should be used instead of -sname within the vm.args
    configuration file.  All EC2 nodes that will be discovered need to be
    using longnames to avoid distributed Erlang error log messages.
    EC2 auto-discovery requires that all Erlang nodes that want to be
    discovered use the same -name and the same -setcookie.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_nodes_get">2.15 - nodes_get</h3>
<p class="code">
curl http://localhost:6464/cloudi/api/rpc/nodes_get.erl
</p>
  <p class="paragraph">
    List the current nodes configuration in the same format provided to
    <a href="#2_nodes_set">nodes_set</a> with default settings ignored
    to keep the output concise.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_nodes_add">2.16 - nodes_add</h3>
<p class="code">
curl -X POST -d "['cloud001@cluster1']" http://localhost:6464/cloudi/api/rpc/nodes_add.erl
</p>
  <p class="paragraph">
    Explicitly add a CloudI node name, so that services between all other
    CloudI nodes and the added nodes can send each other service requests.
    A nodes_add call is similar to nodes_set with
    [{set, all}, {nodes, Nodes}] where Nodes is the final list of all nodes
    (all connected nodes are modified).
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_nodes_remove">2.17 - nodes_remove</h3>
<p class="code">
curl -X POST -d "['cloud001@cluster1']" http://localhost:6464/cloudi/api/rpc/nodes_remove.erl
</p>
  <p class="paragraph">
    Explicitly remove a CloudI node name.  The CloudI node must have
    been added explicitly to be removed explicitly
    (not added by an auto-discovery method).
    A nodes_remove call is similar to nodes_set with
    [{set, all}, {nodes, Nodes}] where Nodes is the final list of all nodes
    (all connected nodes are modified).
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_nodes_alive">2.18 - nodes_alive</h3>
<p class="code">
curl http://localhost:6464/cloudi/api/rpc/nodes_alive.erl
</p>
  <p class="paragraph">
    List all the CloudI nodes known to be connected.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_nodes_dead">2.19 - nodes_dead</h3>
<p class="code">
curl http://localhost:6464/cloudi/api/rpc/nodes_dead.erl
</p>
  <p class="paragraph">
    List all the CloudI nodes that are disconnected but expected to
    reconnect.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_nodes_status">2.20 - nodes_status</h3>
<p class="code">
curl -X POST -d '[]' http://localhost:6464/cloudi/api/rpc/nodes_status.erl
</p>
<p class="code">
curl -X POST -d "['cloudi@hostname']" http://localhost:6464/cloudi/api/rpc/nodes_status.erl
</p>
  <p class="paragraph">
    Provide information about all the CloudI nodes (including the local node).
    Each node has a {Node, Status} pair with the Status described below:
  </p>
<pre>
[{services_running, nonempty_string()},
 {services_restarted, nonempty_string()},
 {services_failed, nonempty_string()},
 {uptime, nonempty_string()},
 {uptime_cost_total, nonempty_string()},
 {uptime_cost_day, nonempty_string()},
 {uptime_cost_week, nonempty_string()},
 {uptime_cost_month, nonempty_string()},
 {uptime_cost_year, nonempty_string()},
 {tracked, nonempty_string()},
 {tracked_cost_total, nonempty_string()},
 {tracked_cost_day, nonempty_string()},
 {tracked_cost_week, nonempty_string()},
 {tracked_cost_month, nonempty_string()},
 {tracked_cost_year, nonempty_string()},
 {tracked_disconnects, nonempty_string()},
 {disconnected, boolean()},
 {downtime_day_disconnected, nonempty_string()},
 {downtime_week_disconnected, nonempty_string()},
 {downtime_month_disconnected, nonempty_string()},
 {downtime_year_disconnected, nonempty_string()},
 {outages_day_disconnected, nonempty_string()},
 {outages_week_disconnected, nonempty_string()},
 {outages_month_disconnected, nonempty_string()},
 {outages_year_disconnected, nonempty_string()},
 {availability_day, nonempty_string()},
 {availability_week, nonempty_string()},
 {availability_month, nonempty_string()},
 {availability_year, nonempty_string()}]
</pre>
  <p class="paragraph">
    The local node will provide <b>uptime</b> results while remote nodes
    will provide <b>tracked</b> results and information related to being
    disconnected.  If cost was provided with
    <a href="#2_nodes_set">nodes_set</a>
    the cumulative cost of the node will also be present.
    All the status information is provided from information stored on the
    local node.
  </p>
  <p class="paragraph">
    The connection outage due to a disconnected remote node is shown visually
    as a count in the time period for each "outages" string value.
    The outages_day_disconnected value shows a single string character for
    each 30 minute segment after 00:00 UTC.  Each disconnect causes an integer
    count to be updated in the string character associated with the disconnect
    time period.  If a disconnect time period crosses a string character
    boundary all associated string characters will have an integer count
    updated.  If the count is above 9 for a single character it is
    represented as a X character.  The | (pipe) character is a cursor that
    shows the position of the current time in the string.  Any characters
    after the cursor are representing the previous time period.
    The outages_week_disconnected value shows a single string character for
    each 4 hour segment after 00:00 UTC on Monday of the current week.
    The outages_month_disconnected value shows a single string character for
    each day of the current month.
    The outages_year_disconnected value shows a single string character for
    each 1/3rd of a month during the current year.
  </p>
  <p class="paragraph">
    Example output is available at<br />
    <a href="https://cloudi.org/config.html#nodes_status">https://cloudi.org/config.html#nodes_status</a>.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_nodes">2.21 - nodes</h3>
<p class="code">
curl http://localhost:6464/cloudi/api/rpc/nodes.erl
</p>
  <p class="paragraph">
    List both the connected and disconnected CloudI nodes.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_logging_set">2.22 - logging_set</h3>
<p class="code">
curl -X POST -d '[{file, undefined}, {syslog, []}]' http://localhost:6464/cloudi/api/rpc/logging_set.erl
</p>
  <p class="paragraph">
    Set the logging configuration for a CloudI node.
  </p>
<pre>
% logging configuration options
[<a href="#2_logging_file_set">{file, undefined | string()}</a>,                % defaults to "cloudi.log"
 <a href="#2_logging_set_config_opts_file_sync">{file_sync,
  logging_file_sync_milliseconds()}</a>,          % defaults to 0 milliseconds
 <a href="#2_logging_level_set">{level, off | fatal | error |
         warn | info | debug | trace}</a>,        % defaults to trace
 <a href="#2_logging_redirect_set">{redirect, undefined | node()}</a>,              % defaults to undefined
 <a href="#2_logging_syslog_set">{syslog, undefined | list()}</a>,                % defaults to undefined
 <a href="#2_logging_stdout_set">{stdout, boolean()}</a>,                         % defaults to false
 <a href="#2_logging_set_config_opts_queue_mode_async">{queue_mode_async, pos_integer()}</a>,           % defaults to 750
 <a href="#2_logging_set_config_opts_queue_mode_sync">{queue_mode_sync, pos_integer()}</a>,            % defaults to 1000
 <a href="#2_logging_set_config_opts_queue_mode_overload">{queue_mode_overload, pos_integer()}</a>,        % defaults to 10000
 <a href="#2_logging_formatters_set">{formatters, undefined | list()}</a>,            % defaults to undefined
 <a href="#2_logging_set_config_opts_log_time_offset">{log_time_offset,
  off | fatal | error |
  warn | info | debug | trace}</a>,               % defaults to off
 <a href="#2_logging_set_config_opts_aspects_log_before">{aspects_log_before,
  list(aspects_log_before())}</a>,                % defaults to []
 <a href="#2_logging_set_config_opts_aspects_log_after">{aspects_log_after,
  list(aspects_log_after())}</a>]                 % defaults to []
</pre>
  <h4 id="2_logging_set_config_opts_file_sync">file_sync:</h4>
  <p class="paragraph">
    Ensure all log file data has been written to the file by flushing
    any operating system buffers that contain pending write data,
    with the interval provided in milliseconds.
  </p>
  <h4 id="2_logging_set_config_opts_queue_mode_async">queue_mode_async:</h4>
  <p class="paragraph">
    The logger process will use asynchronous mode while its message queue
    length is less than the configured value.
  </p>
  <h4 id="2_logging_set_config_opts_queue_mode_sync">queue_mode_sync:</h4>
  <p class="paragraph">
    The logger process will use synchronous mode when its message queue
    length is greater than the configured value.  The gap between
    queue_mode_async and queue_mode_sync values avoids latency associated
    with changing the queue_mode.  The sync queue_mode will cause all
    services to log more slowly while the logger process writes its
    pending log requests (messages) as quickly as possible.
  </p>
  <h4 id="2_logging_set_config_opts_queue_mode_overload">queue_mode_overload:</h4>
  <p class="paragraph">
    The logger process will use overload mode when its message queue
    length is greater than the configured value.  The value prevents
    CloudI from terminating due to extreme memory consumption.
  </p>
  <h4 id="2_logging_set_config_opts_log_time_offset">log_time_offset:</h4>
  <p class="paragraph">
    Log when the Erlang VM adjusts its
    <a href="https://www.erlang.org/doc/apps/erts/time_correction.html#Erlang_System_Time" rel="noreferrer" target="_blank">internal view of the system time</a>
    with the size of the change in nanoseconds using the provided loglevel.
  </p>
  <h4 id="2_logging_set_config_opts_aspects_log_before">aspects_log_before:</h4>
  <p class="paragraph">
    Provide a list of functions with the type specification shown below,
    with each function as either an anonymous Erlang function or
    an Erlang tuple "{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}".
    Each function will be called before the log data is stored to disk.
  </p>
<pre class="code">
fun((Level :: fatal | error | warn | info | debug | trace,
     Timestamp :: erlang:timestamp(),
     Node :: node(),
     Pid :: pid(),
     Module :: module(),
     Line :: pos_integer(),
     Function :: atom() | undefined,
     Arity :: arity() | undefined,
     MetaData :: list({atom(), any()}),
     LogMessage :: iodata()) -&gt;
    ok.
</pre>
  <p class="paragraph">
    It is also possible to use the Erlang tuple
    "{{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}}" to specify an
    arity 0 function that returns an anonymous function as described above.
  </p>
  <h4 id="2_logging_set_config_opts_aspects_log_after">aspects_log_after:</h4>
  <p class="paragraph">
    Provide a list of functions with the type specification shown below,
    with each function as either an anonymous Erlang function or
    an Erlang tuple "{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}".
    Each function will be called after the log data is stored to disk.
  </p>
<pre class="code">
fun((Level :: fatal | error | warn | info | debug | trace,
     Timestamp :: erlang:timestamp(),
     Node :: node(),
     Pid :: pid(),
     Module :: module(),
     Line :: pos_integer(),
     Function :: atom() | undefined,
     Arity :: arity() | undefined,
     MetaData :: list({atom(), any()}),
     LogMessage :: iodata()) -&gt;
    ok.
</pre>
  <p class="paragraph">
    It is also possible to use the Erlang tuple
    "{{module(),&nbsp;FunctionName&nbsp;::&nbsp;atom()}}" to specify an
    arity 0 function that returns an anonymous function as described above.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_logging_file_set">2.23 - logging_file_set</h3>
<p class="code">
curl -X POST -d '"different_filename.log"' http://localhost:6464/cloudi/api/rpc/logging_file_set.erl
</p>
  <p class="paragraph">
    Set the file path for logging output.  If set to 'undefined', logging
    output will only be sent to syslog and formatters with an output module.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_logging_level_set">2.24 - logging_level_set</h3>
<p class="code">
curl -X POST -d 'warn' http://localhost:6464/cloudi/api/rpc/logging_level_set.erl
</p>
  <p class="paragraph">
    Modify the loglevel.  The loglevel is changed with an Erlang module
    update internally so any logging statements that are turned off
    create no latency.  If set to 'undefined' or 'off', logging
    output will only be sent to syslog and formatters with an output module.
    The available log levels values are:
    off, fatal, error, warn, info, debug, trace.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_logging_stdout_set">2.25 - logging_stdout_set</h3>
<p class="code">
curl -X POST -d 'true' http://localhost:6464/cloudi/api/rpc/logging_stdout_set.erl
</p>
  <p class="paragraph">
    Send all logging output to stdout.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_logging_syslog_set">2.26 - logging_syslog_set</h3>
<p class="code">
curl -X POST -d '[{identity, "CloudI"}, {facility, local0}, {level, trace}]' http://localhost:6464/cloudi/api/rpc/logging_syslog_set.erl
</p>
  <p class="paragraph">
    Send all logging output to syslog.
  </p>
  <table id="2_logging_syslog_set_config"><tr><th>
    Option
  </th><th>
    Default
  </th><th>
    Details
  </th></tr><tr><td>
    identity
  </td><td>
    "CloudI"
  </td><td>
    String syslog identity (referred to as the APP-NAME in
    <a href="https://datatracker.ietf.org/doc/html/rfc5424#section-6.2.5" rel="noreferrer" target="_blank">RFC5424</a>).
  </td></tr><tr><td>
    facility
  </td><td>
    local0
  </td><td>
    A syslog facility provided as a name
    (kernel | user | mail | daemon | auth0 | syslog |
     print | news | uucp | clock0 | auth1 | ftp | ntp |
     auth2 | auth3 | clock1 | local0 | local1 | local2 |
     local3 | local4 | local5 | local6 | local7) or as an integer (&ge; 0).
  </td></tr><tr><td>
    level
  </td><td>
    trace
  </td><td>
    The syslog loglevel specified with a CloudI loglevel
    (with the CloudI&nbsp;loglevel&nbsp;-&gt;&nbsp;syslog&nbsp;level
     equivalence below):
    <br />
    fatal&nbsp;-&gt;&nbsp;critical&nbsp;(2),
    <br />
    error&nbsp;-&gt;&nbsp;error&nbsp;(3),
    <br />
    warn&nbsp;-&gt;&nbsp;warning&nbsp;(4),
    <br />
    info&nbsp;-&gt;&nbsp;notice&nbsp;(5),
    <br />
    debug&nbsp;-&gt;&nbsp;informational&nbsp;(6),
    <br />
    trace&nbsp;-&gt;&nbsp;debug&nbsp;(7).
  </td></tr><tr><td>
    transport
  </td><td>
    local
  </td><td>
    The transport to use for syslog data (local | udp | tcp | tls).
  </td></tr><tr><td>
    transport_options
  </td><td>
    []
  </td><td>
    The transport options to use for the syslog socket.
  </td></tr><tr><td>
    protocol
  </td><td>
    rfc3164
  </td><td>
    The syslog protocol to use (rfc3164 | rfc5424).
  </td></tr><tr><td>
    path
  </td><td>
    "/dev/log"
  </td><td>
    The filesystem path to use for the local transport destination.
  </td></tr><tr><td>
    host
  </td><td>
    {127,0,0,1}
  </td><td>
    The host to use for the udp, tcp or tls transport destination.
  </td></tr><tr><td>
    port
  </td><td>
    undefined
  </td><td>
    The port to use for the transport destination
    (undefined uses the default port for the transport).
  </td></tr></table>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_logging_formatters_set">2.27 - logging_formatters_set</h3>
<p class="code">
curl -X POST -d '[{any, [{output, lager_file_backend}, {output_args, [{file, "lager.log"}]}, {formatter, lager_default_formatter}, {level, trace}]}]' http://localhost:6464/cloudi/api/rpc/logging_formatters_set.erl
</p>
  <p class="paragraph">
    Provide integration with lager-compatible formatters and
    lager-compatible backends.  Each formatter entry specifies a list of
    modules for the source of the logging output to match against paired with
    formatter options (e.g.,&nbsp;{[module1,&nbsp;module2],&nbsp;Options}).
    A separate formatter entry with an 'any' atom instead of a list of modules
    is used if the source of the logging output is not provided
    (e.g.,&nbsp;{any,&nbsp;Options}).
    Use 'STDOUT' and 'STDERR' as a module name entry to control
    the stdout and stderr output coming from external services
    (logging output for both streams provides the OS pid next to the stream
     name, instead of a module line number).
    If only a formatter is specified (i.e., without an output module, 
    a lager-compatible backend), the formatter transforms the logging output
    to be logged to the CloudI log file and/or syslog.  If an output module is
    provided (that implements the gen_event Erlang/OTP behaviour),
    it will consume the logging output separately from the CloudI log file
    and syslog.
  </p>
  <table id="2_logging_formatters_set_config"><tr><th>
    Option
  </th><th>
    Default
  </th><th>
    Details
  </th></tr><tr><td>
    level
  </td><td>
    trace
  </td><td>
    The formatter loglevel specified with a CloudI loglevel or a lager loglevel
    (with the lager&nbsp;loglevel&nbsp;-&gt;&nbsp;CloudI&nbsp;loglevel
     equivalence below):
    <br />
    emergency&nbsp;-&gt;&nbsp;fatal,
    <br />
    alert&nbsp;(becomes&nbsp;emergency)&nbsp;-&gt;&nbsp;fatal,
    <br />
    critical&nbsp;(becomes&nbsp;emergency)&nbsp;-&gt;&nbsp;fatal,
    <br />
    error&nbsp;-&gt;&nbsp;error,
    <br />
    warning&nbsp;-&gt;&nbsp;warn,
    <br />
    notice&nbsp;(becomes&nbsp;warning)&nbsp;-&gt;&nbsp;warn,
    <br />
    info&nbsp;-&gt;&nbsp;info,
    <br />
    debug&nbsp;-&gt;&nbsp;debug,
    <br />
    none&nbsp;-&gt;&nbsp;off.
  </td></tr><tr><td>
    output
  </td><td>
    undefined
  </td><td>
    The lager-compatible backend module which implements the gen_event
    Erlang/OTP behaviour.
  </td></tr><tr><td>
    output_args
  </td><td>
    []
  </td><td>
    Arguments to provide to the output module's init/1 function.
  </td></tr><tr><td>
    output_max_r
  </td><td>
    5
  </td><td>
    The maximum number of restarts allowed for an output module that crashes.
  </td></tr><tr><td>
    output_max_t
  </td><td>
    300
  </td><td>
    The maximum time period for restarts to occur in when an
    output module crashes.
  </td></tr><tr><td>
    formatter
  </td><td>
    undefined
  </td><td>
    The lager-compatible formatter module which provides formatting for either
    the other logging methods (CloudI file and/or syslog) or the output module.
    A formatter module must export a <a href="https://github.com/basho/lager/#custom-formatting" rel="noopener" target="_blank">format/2 function</a>.
  </td></tr><tr><td>
    formatter_config
  </td><td>
    []
  </td><td>
    Configuration provided to the formatter module's <a href="https://github.com/basho/lager/#custom-formatting" rel="noopener" target="_blank">format/2 function</a>'s second parameter.
  </td></tr></table>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_logging_redirect_set">2.28 - logging_redirect_set</h3>
<p class="code">
curl -X POST -d 'cloudi@host' http://localhost:6464/cloudi/api/rpc/logging_redirect_set.erl
</p>
  <p class="paragraph">
    Redirect all local log output to a remote CloudI node.  Use 'undefined'
    as the node name to log locally.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_logging_status">2.29 - logging_status</h3>
<p class="code">
curl http://localhost:6464/cloudi/api/rpc/logging_status.erl
</p>
  <p class="paragraph">
    Provide the current logging status.  If any errors occur when writing
    to the log file, the error information is provided in the logging status
    output.
  </p>
<pre>
[{queue_mode, async | sync | overload},
 {queue_mode_sync_last_start, nonempty_string()},
 {queue_mode_sync_last_start_event, nonempty_string()},
 {queue_mode_sync_last_end, nonempty_string()},
 {queue_mode_sync_last_end_event, nonempty_string()},
 {queue_mode_sync_last_total, nonempty_string()},
 {queue_mode_overload_last_start, nonempty_string()},
 {queue_mode_overload_last_start_event, nonempty_string()},
 {queue_mode_overload_last_end, nonempty_string()},
 {queue_mode_overload_last_end_event, nonempty_string()},
 {queue_mode_overload_last_total, nonempty_string()},
 {time_offset_last_change, nonempty_string()},
 {time_offset_last_event, nonempty_string()},
 {file_messages_fatal, nonempty_string()},
 {file_messages_error, nonempty_string()},
 {file_messages_warn, nonempty_string()},
 {file_messages_info, nonempty_string()},
 {file_messages_debug, nonempty_string()},
 {file_messages_trace, nonempty_string()},
 {file_sync_fail_count, nonempty_string()},
 {file_sync_fail_types, nonempty_list(atom())},
 {file_write_fail_count, nonempty_string()},
 {file_write_fail_types, nonempty_list(atom())},
 {file_read_fail_count, nonempty_string()},
 {file_read_fail_types, nonempty_list(atom())}]
</pre>
  <p class="paragraph">
    The queue_mode is async while logging is occurring asynchronously
    (the default).  If the logger receives a large number of logging requests,
    it will change to sync (synchronous) mode which forces Erlang service
    processes to wait until their logging request has finished.  The logger
    may still receive too many logging requests if it is the destination of
    a redirect and that could cause the logger to use overload mode.
    In overload mode, the logger will discard logging requests as quickly
    as possible (i.e., without any write to the log occurring) to reduce the
    extreme memory consumption until it is possible to go back to sync mode
    (each mode has a limit set by <a href="#2_logging_set">logging_set</a>).
  </p>
  <p class="paragraph">
    When the overload mode transitions to sync mode an error is logged with
    the duration of the overload mode.  The most recent durations of both
    sync mode and overload mode are provided in the logging status output
    (if either modes were used during CloudI's runtime).  The event timestamps
    are the same timestamps present in the log output while the start/end
    timestamps may change based on changes to the OS time.  The logging status
    output will also provide the last OS time change in seconds
    (if an OS time change occurred during CloudI's runtime).
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_logging_status_reset">2.30 - logging_status_reset</h3>
<p class="code">
curl http://localhost:6464/cloudi/api/rpc/logging_status_reset.erl
</p>
  <p class="paragraph">
    Reset the logging status.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_logging">2.31 - logging</h3>
<p class="code">
curl http://localhost:6464/cloudi/api/rpc/logging.erl
</p>
  <p class="paragraph">
    List the current logging configuration in the same format provided to
    the configuration file with default settings ignored to keep the output
    concise.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_code_path_add">2.32 - code_path_add</h3>
<p class="code">
curl -X POST -d '"/home/user/code/services"' http://localhost:6464/cloudi/api/rpc/code_path_add.erl
</p>
  <p class="paragraph">
    Add a directory to the CloudI Erlang VM code server's search paths.
    The path is always appended to the list of search paths
    (you should not need to rely on search path order because of unique naming).
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_code_path_remove">2.33 - code_path_remove</h3>
<p class="code">
curl -X POST -d '"/home/user/code/services"' http://localhost:6464/cloudi/api/rpc/code_path_remove.erl
</p>
  <p class="paragraph">
    Remove a directory from the CloudI Erlang VM code server's search paths.
    This doesn't impact any running services, only services that will be
    started in the future.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_code_path">2.34 - code_path</h3>
<p class="code">
curl http://localhost:6464/cloudi/api/rpc/code_path.erl
</p>
  <p class="paragraph">
    List all the CloudI Erlang VM code server search paths
    (in the same order the directories are searched).
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

  <h3 id="2_code_status">2.35 - code_status</h3>
<p class="code">
curl http://localhost:6464/cloudi/api/rpc/code_status.erl
</p>
  <p class="paragraph">
    Provide information about the execution environment:
  </p>
<pre>
[{build_machine, nonempty_string()},
 {build_kernel_version, nonempty_string()},
 {build_operating_system, nonempty_string()},
 {build_erlang_otp_release, nonempty_string()},
 {build_cloudi_time, nonempty_string()},
 {build_cloudi_version, nonempty_string()},
 {build_cloudi_cxx_compiler_version, nonempty_string()},
 {build_cloudi_cxx_dependencies_versions, nonempty_string()},
 {build_erlang_erts_c_compiler_version, nonempty_string()},
 {install_erlang_erts_time, nonempty_string()},        % ISO8601 timestamp
 {install_erlang_kernel_time, nonempty_string()},      % ISO8601 timestamp
 {install_erlang_stdlib_time, nonempty_string()},      % ISO8601 timestamp
 {install_erlang_sasl_time, nonempty_string()},        % ISO8601 timestamp
 {install_erlang_compiler_time, nonempty_string()},    % ISO8601 timestamp
 {install_cloudi_time, nonempty_string()},             % ISO8601 timestamp
 {runtime_erlang_erts_version, nonempty_string()},
 {runtime_erlang_kernel_version, nonempty_string()},
 {runtime_erlang_stdlib_version, nonempty_string()},
 {runtime_erlang_sasl_version, nonempty_string()},
 {runtime_erlang_compiler_version, nonempty_string()},
 {runtime_erlang_compilation, nonempty_string()},      % "aot" | "jit"
 {runtime_cloudi_version, nonempty_string()},
 {runtime_machine_processors, pos_integer()},          % logical processors
 {runtime_start, nonempty_string()},                   % ISO8601 timestamp
 {runtime_clock, nonempty_string()},                   % ISO8601 timestamp
 {runtime_clock_offset, nonempty_string()},            % offset to HW clock
 {runtime_total, nonempty_string()},
 {runtime_cloudi_start, nonempty_string()},            % ISO8601 timestamp
 {runtime_cloudi_total, nonempty_string()},
 {runtime_cloudi_changes,                              % service file changes
  list([{type, internal | external},
        {file_age, nonempty_string()},
        {file_path, nonempty_string()},
        {service_ids, nonempty_list(service_id())}])}]
</pre>
  <p class="paragraph">
    The runtime_cloudi_changes list shows CloudI service files that have changed
    on the filesystem after CloudI started.  The files may have changed due to
    <a href="#2_services_update">services_update</a> use.
  </p>
  <p class="paragraph">
    Example output is available at<br />
    <a href="https://cloudi.org/config.html#code_status">https://cloudi.org/config.html#code_status</a>.
  </p>
  <div class="top"><a href="#CloudI">Top</a></div>

</div>

<script>clipboard_copy_init();</script>

</body>
</html>
